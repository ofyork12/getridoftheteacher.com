 <!DOCTYPE html>
<!-- Created by Hughesmath -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10.0, user-scalable=yes">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Squares Game 2 - Type Answers</title>
  <style>
    :root {
      --circle-size: clamp(10px, 6vw, 60px); /* Allow much smaller when zoomed out */
      --circle-border: 0.5px; /* Smallest possible border while maintaining tangential connection */
      --circle-total: calc(var(--circle-size) + var(--circle-border) * 2);
      --section-gap: clamp(10px, 6vw, 60px);
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      gap: var(--section-gap);
      padding: 40px 12px 120px;
      overflow-y: auto;
      overflow-x: auto;
      -webkit-tap-highlight-color: transparent;
    }
    /* No transforms needed - text reads normally, just reversed order */
    /* Center content vertically on mobile devices */
    @media (max-width: 768px) {
      html, body {
        overflow-x: auto;
        overflow-y: auto;
        width: 100%;
      }
      body {
        justify-content: center;
        align-items: center;
        padding: 20px 0;
        min-height: 100vh;
      }
      /* Sets contain grids - allow horizontal scroll */
      .set {
        align-items: center;
        width: 100vw;
        padding: 0;
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: column;
        overflow-x: auto;
        overflow-y: visible;
        -webkit-overflow-scrolling: touch;
      }
      /* Center grids in sets */
      .set > [class*="grid-"],
      .set > .grid-dynamic,
      .set > .grid-two,
      .set > .grid-three,
      .set > .grid-four,
      .set > .grid-five {
        margin: 0 auto;
        flex-shrink: 0;
      }
    }
    .game-navigation {
      display: flex;
      gap: 40px;
      margin: 30px 0;
      justify-content: center;
      flex-wrap: wrap;
      order: -1;
    }
    .game-nav-button {
      padding: 36px 72px;
      font-size: 46.08px;
      font-weight: bold;
      background: transparent;
      color: #fff;
      border: 5.76px solid #fff;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }
    .game-nav-button:hover {
      background: #fff;
      color: #000;
    }
    .game-nav-button.active {
      background: #fff;
      color: #000;
    }
    /* Answer input field styling - bottom left corner, much smaller */
    .answer-input-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: rgba(0, 0, 0, 0.9);
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #fff;
    }
    .answer-input-container label {
      font-size: 10px;
      font-weight: bold;
      margin: 0;
      white-space: nowrap;
    }
    .answer-input-wrapper {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    #answerInput {
      font-size: 14px;
      padding: 5px 8px;
      border: 1px solid #fff;
      border-radius: 4px;
      background: #000;
      color: #fff;
      text-align: center;
      width: 60px;
      font-weight: bold;
    }
    #answerInput:focus {
      outline: none;
      border-color: #00ff00;
      box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
    }
    #answerInput.correct {
      border-color: #00ff00;
      background: rgba(0, 255, 0, 0.2);
    }
    #answerInput.incorrect {
      border-color: #ff0000;
      background: rgba(255, 0, 0, 0.2);
    }
    #submitAnswer {
      font-size: 12px;
      padding: 5px 10px;
      border: 1px solid #fff;
      border-radius: 4px;
      background: transparent;
      color: #fff;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    #submitAnswer:hover {
      background: #fff;
      color: #000;
    }
    .next-square-hint {
      font-size: 10px;
      color: #aaa;
      margin: 0;
      white-space: nowrap;
    }
    /* Celebration styles */
    .celebration-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.5s ease;
    }
    .celebration-overlay.show {
      display: flex;
    }
    .celebration-content {
      text-align: center;
      color: #fff;
      animation: scaleIn 0.5s ease;
    }
    .celebration-title {
      font-size: clamp(48px, 8vw, 120px);
      font-weight: bold;
      margin-bottom: 20px;
      background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: rainbow 3s ease infinite;
    }
    .celebration-time {
      font-size: clamp(24px, 4vw, 60px);
      margin: 20px 0;
      color: #00ff00;
    }
    .celebration-message {
      font-size: clamp(18px, 3vw, 36px);
      margin: 20px 0;
    }
    .celebration-confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff0000;
      animation: confettiFall 3s linear infinite;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes scaleIn {
      from { transform: scale(0.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    @keyframes rainbow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    @keyframes confettiFall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }
    /* Highlight current square */
    .set.current-square {
      border: 4px solid #00ff00;
      border-radius: 10px;
      padding: 10px;
      transition: all 0.3s ease;
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 0, 0.6); }
      50% { box-shadow: 0 0 50px rgba(0, 255, 0, 0.9); }
    }
    /* Colored square when attempted */
    .set.attempted {
      border: 3px solid #00ff00;
      border-radius: 10px;
      padding: 10px;
      transition: all 0.3s ease;
    }
    .set.attempted.correct {
      border-color: #00ff00;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    }
    .set.attempted.incorrect {
      border-color: #ff0000;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    }
    .set {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 100%;
      min-width: min-content;
      text-align: center;
      overflow-x: visible;
      position: relative;
    }
    .set > :last-child:not(.answer-display) {
      margin: 0 auto;
    }
    /* Answer display should never be centered or visible unless showing */
    .set > .answer-display {
      margin: 0 !important;
      position: absolute !important;
      left: -9999px !important;
      top: -9999px !important;
    }
    /* Grid wrapper to keep grids centered in viewport */
    .grid-wrapper {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
    }
    .grid-wrapper::-webkit-scrollbar {
      height: 8px;
    }
    .grid-wrapper::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }
    .grid-wrapper::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }
    .set h2 {
      margin: 0;
      font-size: 84px;
      font-weight: 700;
      letter-spacing: 6px;
      text-transform: uppercase;
    }
    .set {
      margin-bottom: 40px;
    }
    .answer-display {
      margin-top: 15px;
      font-size: 72px;
      font-weight: bold;
      min-height: 90px;
      opacity: 0 !important;
      visibility: hidden !important;
      display: none !important;
      position: absolute !important;
      left: -9999px !important;
      top: -9999px !important;
      transition: opacity 0.3s ease;
      pointer-events: none !important;
      user-select: none !important;
      -webkit-user-select: none !important;
      color: transparent !important;
      text-shadow: none !important;
      z-index: -9999 !important;
      clip: rect(0, 0, 0, 0) !important;
      clip-path: inset(100%) !important;
    }
    /* Completely hide answer display when not showing */
    .answer-display:not(.show) {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      height: 0 !important;
      width: 0 !important;
      overflow: hidden !important;
      margin: 0 !important;
      padding: 0 !important;
      font-size: 0 !important;
      line-height: 0 !important;
      text-indent: -9999px !important;
    }
    .answer-display.show {
      opacity: 1 !important;
      visibility: visible !important;
      display: block !important;
      position: static !important;
      left: auto !important;
      top: auto !important;
    }
    /* Prevent any content from showing via CSS pseudo-elements */
    .answer-display:not(.show)::before,
    .answer-display:not(.show)::after {
      content: none !important;
      display: none !important;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      margin-bottom: 40px;
      justify-content: center;
      order: -2;
    }
    .lang-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    .controls button {
      padding: 45px 90px;
      border: 7.2px solid #fff;
      border-radius: 999px;
      background: transparent;
      color: #fff;
      font-size: 57.6px;
      cursor: pointer;
      transition: background 0.3s ease, color 0.3s ease;
    }
    .controls button.active {
      background: #fff;
      color: #000;
    }
    .controls button.dual {
      font-size: 46.8px;
      padding: 36px 72px;
      opacity: 0.85;
      border-style: dashed;
    }
    .circle {
      width: var(--circle-total);
      height: var(--circle-total);
      border-radius: 50%;
      background: #222;
      border: 0.5px solid #fff !important;
      border-width: 0.5px !important;
      cursor: pointer;
      transition: background 0.25s ease;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }
    .circle:focus-visible,
    .circle:focus,
    .circle:active {
      outline: none;
    }
    .circle.red { background: #ff0000; }
    .circle.orange { background: #ff6200; }
    .circle.yellow { background: #ffe600; }
    .circle.green { background: #00a12c; }
    .circle.blue { background: #0030ff; }
    .circle.purple { background: #6a1b9a; }
    .circle.brown { background: #7a3b00; }
    .circle.pink { background: #ff3fa6; }
    .circle.sky { background: #38c7ff; }
    .circle.red-final { background: #ff0000; }
    
    /* 26×26 through 30×30 grids with numbers - larger circles */
    /* Removed old rules for grids 676, 729, 784, 841, 900 - now using same size as 13×13 grid */
    /* 6×6 (36) through 12×12 (144) grids - same size as 13×13 grid */
    .grid-36 {
      --circle-total-36: calc(var(--circle-total) * 13 / 6);
      grid-template-columns: repeat(6, var(--circle-total-36)) !important;
      grid-template-rows: repeat(6, var(--circle-total-36)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-36 .circle {
      width: var(--circle-total-36) !important;
      height: var(--circle-total-36) !important;
      border-width: 0.5px !important;
    }
    .grid-49 {
      --circle-total-49: calc(var(--circle-total) * 13 / 7);
      grid-template-columns: repeat(7, var(--circle-total-49)) !important;
      grid-template-rows: repeat(7, var(--circle-total-49)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-49 .circle {
      width: var(--circle-total-49) !important;
      height: var(--circle-total-49) !important;
      border-width: 0.5px !important;
    }
    .grid-64 {
      --circle-total-64: calc(var(--circle-total) * 13 / 8);
      grid-template-columns: repeat(8, var(--circle-total-64)) !important;
      grid-template-rows: repeat(8, var(--circle-total-64)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-64 .circle {
      width: var(--circle-total-64) !important;
      height: var(--circle-total-64) !important;
      border-width: 0.5px !important;
    }
    .grid-81 {
      --circle-total-81: calc(var(--circle-total) * 13 / 9);
      grid-template-columns: repeat(9, var(--circle-total-81)) !important;
      grid-template-rows: repeat(9, var(--circle-total-81)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-81 .circle {
      width: var(--circle-total-81) !important;
      height: var(--circle-total-81) !important;
      border-width: 0.5px !important;
    }
    .grid-100 {
      --circle-total-100: calc(var(--circle-total) * 13 / 10);
      grid-template-columns: repeat(10, var(--circle-total-100)) !important;
      grid-template-rows: repeat(10, var(--circle-total-100)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-100 .circle {
      width: var(--circle-total-100) !important;
      height: var(--circle-total-100) !important;
      border-width: 0.5px !important;
    }
    .grid-121 {
      --circle-total-121: calc(var(--circle-total) * 13 / 11);
      grid-template-columns: repeat(11, var(--circle-total-121)) !important;
      grid-template-rows: repeat(11, var(--circle-total-121)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-121 .circle {
      width: var(--circle-total-121) !important;
      height: var(--circle-total-121) !important;
      border-width: 0.5px !important;
    }
    .grid-144 {
      --circle-total-144: calc(var(--circle-total) * 13 / 12);
      grid-template-columns: repeat(12, var(--circle-total-144)) !important;
      grid-template-rows: repeat(12, var(--circle-total-144)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-144 .circle {
      width: var(--circle-total-144) !important;
      height: var(--circle-total-144) !important;
      border-width: 0.5px !important;
    }
    /* 13×13 (169), 14×14 (196), and 15×15 (225) grids - same size */
    .grid-169 {
      grid-template-columns: repeat(13, var(--circle-total)) !important;
      grid-template-rows: repeat(13, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-196 {
      --circle-total-196: calc(var(--circle-total) * 13 / 14);
      grid-template-columns: repeat(14, var(--circle-total-196)) !important;
      grid-template-rows: repeat(14, var(--circle-total-196)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-196 .circle {
      width: var(--circle-total-196) !important;
      height: var(--circle-total-196) !important;
      border-width: 0.5px !important;
    }
    .grid-225 {
      --circle-total-225: calc(var(--circle-total) * 13 / 15);
      grid-template-columns: repeat(15, var(--circle-total-225)) !important;
      grid-template-rows: repeat(15, var(--circle-total-225)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-225 .circle {
      width: var(--circle-total-225) !important;
      height: var(--circle-total-225) !important;
      border-width: 0.5px !important;
    }
    .grid-256 {
      --circle-total-256: calc(var(--circle-total) * 13 / 16);
      grid-template-columns: repeat(16, var(--circle-total-256)) !important;
      grid-template-rows: repeat(16, var(--circle-total-256)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-256 .circle {
      width: var(--circle-total-256) !important;
      height: var(--circle-total-256) !important;
      border-width: 0.5px !important;
    }
    .grid-289 {
      --circle-total-289: calc(var(--circle-total) * 13 / 17);
      grid-template-columns: repeat(17, var(--circle-total-289)) !important;
      grid-template-rows: repeat(17, var(--circle-total-289)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-289 .circle {
      width: var(--circle-total-289) !important;
      height: var(--circle-total-289) !important;
      border-width: 0.5px !important;
    }
    .grid-324 {
      --circle-total-324: calc(var(--circle-total) * 13 / 18);
      grid-template-columns: repeat(18, var(--circle-total-324)) !important;
      grid-template-rows: repeat(18, var(--circle-total-324)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-324 .circle {
      width: var(--circle-total-324) !important;
      height: var(--circle-total-324) !important;
      border-width: 0.5px !important;
    }
    .grid-361 {
      --circle-total-361: calc(var(--circle-total) * 13 / 19);
      grid-template-columns: repeat(19, var(--circle-total-361)) !important;
      grid-template-rows: repeat(19, var(--circle-total-361)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-361 .circle {
      width: var(--circle-total-361) !important;
      height: var(--circle-total-361) !important;
      border-width: 0.5px !important;
    }
    .grid-400 {
      --circle-total-400: calc(var(--circle-total) * 13 / 20);
      grid-template-columns: repeat(20, var(--circle-total-400)) !important;
      grid-template-rows: repeat(20, var(--circle-total-400)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-400 .circle {
      width: var(--circle-total-400) !important;
      height: var(--circle-total-400) !important;
      border-width: 0.5px !important;
    }
    .grid-441 {
      --circle-total-441: calc(var(--circle-total) * 13 / 21);
      grid-template-columns: repeat(21, var(--circle-total-441)) !important;
      grid-template-rows: repeat(21, var(--circle-total-441)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-441 .circle {
      width: var(--circle-total-441) !important;
      height: var(--circle-total-441) !important;
      border-width: 0.5px !important;
    }
    .grid-484 {
      --circle-total-484: calc(var(--circle-total) * 13 / 22);
      grid-template-columns: repeat(22, var(--circle-total-484)) !important;
      grid-template-rows: repeat(22, var(--circle-total-484)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-484 .circle {
      width: var(--circle-total-484) !important;
      height: var(--circle-total-484) !important;
      border-width: 0.5px !important;
    }
    .grid-529 {
      --circle-total-529: calc(var(--circle-total) * 13 / 23);
      grid-template-columns: repeat(23, var(--circle-total-529)) !important;
      grid-template-rows: repeat(23, var(--circle-total-529)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-529 .circle {
      width: var(--circle-total-529) !important;
      height: var(--circle-total-529) !important;
      border-width: 0.5px !important;
    }
    .grid-576 {
      --circle-total-576: calc(var(--circle-total) * 13 / 24);
      grid-template-columns: repeat(24, var(--circle-total-576)) !important;
      grid-template-rows: repeat(24, var(--circle-total-576)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-576 .circle {
      width: var(--circle-total-576) !important;
      height: var(--circle-total-576) !important;
      border-width: 0.5px !important;
    }
    .grid-625 {
      --circle-total-625: calc(var(--circle-total) * 13 / 25);
      grid-template-columns: repeat(25, var(--circle-total-625)) !important;
      grid-template-rows: repeat(25, var(--circle-total-625)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-625 .circle {
      width: var(--circle-total-625) !important;
      height: var(--circle-total-625) !important;
      border-width: 0.5px !important;
    }
    .grid-676 {
      --circle-total-676: calc(var(--circle-total) * 13 / 26);
      grid-template-columns: repeat(26, var(--circle-total-676)) !important;
      grid-template-rows: repeat(26, var(--circle-total-676)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-676 .circle {
      width: var(--circle-total-676) !important;
      height: var(--circle-total-676) !important;
      border-width: 0.5px !important;
    }
    .grid-729 {
      --circle-total-729: calc(var(--circle-total) * 13 / 27);
      grid-template-columns: repeat(27, var(--circle-total-729)) !important;
      grid-template-rows: repeat(27, var(--circle-total-729)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-729 .circle {
      width: var(--circle-total-729) !important;
      height: var(--circle-total-729) !important;
      border-width: 0.5px !important;
    }
    .grid-784 {
      --circle-total-784: calc(var(--circle-total) * 13 / 28);
      grid-template-columns: repeat(28, var(--circle-total-784)) !important;
      grid-template-rows: repeat(28, var(--circle-total-784)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-784 .circle {
      width: var(--circle-total-784) !important;
      height: var(--circle-total-784) !important;
      border-width: 0.5px !important;
    }
    .grid-841 {
      --circle-total-841: calc(var(--circle-total) * 13 / 29);
      grid-template-columns: repeat(29, var(--circle-total-841)) !important;
      grid-template-rows: repeat(29, var(--circle-total-841)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-841 .circle {
      width: var(--circle-total-841) !important;
      height: var(--circle-total-841) !important;
      border-width: 0.5px !important;
    }
    .grid-900 {
      --circle-total-900: calc(var(--circle-total) * 13 / 30);
      grid-template-columns: repeat(30, var(--circle-total-900)) !important;
      grid-template-rows: repeat(30, var(--circle-total-900)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-900 .circle {
      width: var(--circle-total-900) !important;
      height: var(--circle-total-900) !important;
      border-width: 0.5px !important;
    }
    .grid-961 {
      --circle-total-961: calc(var(--circle-total) * 13 / 31);
      grid-template-columns: repeat(31, var(--circle-total-961)) !important;
      grid-template-rows: repeat(31, var(--circle-total-961)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-961 .circle {
      width: var(--circle-total-961) !important;
      height: var(--circle-total-961) !important;
      border-width: 0.5px !important;
    }
    .grid-1024 {
      --circle-total-1024: calc(var(--circle-total) * 13 / 32);
      grid-template-columns: repeat(32, var(--circle-total-1024)) !important;
      grid-template-rows: repeat(32, var(--circle-total-1024)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1024 .circle {
      width: var(--circle-total-1024) !important;
      height: var(--circle-total-1024) !important;
      border-width: 0.5px !important;
    }
    .grid-1089 {
      --circle-total-1089: calc(var(--circle-total) * 13 / 33);
      grid-template-columns: repeat(33, var(--circle-total-1089)) !important;
      grid-template-rows: repeat(33, var(--circle-total-1089)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1089 .circle {
      width: var(--circle-total-1089) !important;
      height: var(--circle-total-1089) !important;
      border-width: 0.5px !important;
    }
    /* Grids 34×34 through 60×60 - make them bigger */
    .grid-1521, .grid-1600,
    .grid-1681, .grid-1764, .grid-1849, .grid-1936, .grid-2025, .grid-2116, .grid-2209,
    .grid-2304, .grid-2401, .grid-2500, .grid-2601, .grid-2704, .grid-2809, .grid-2916,
    .grid-3025, .grid-3136, .grid-3249, .grid-3364, .grid-3481, .grid-3600, .grid-3721, .grid-3844, .grid-3969, .grid-4096, .grid-4225, .grid-4356, .grid-4489, .grid-4624, .grid-4761, .grid-4900, .grid-5041, .grid-5184, .grid-5329, .grid-5476, .grid-5625, .grid-5776, .grid-5929, .grid-6084, .grid-6241, .grid-6400, .grid-6561, .grid-6724, .grid-6889, .grid-7056, .grid-7225, .grid-7396, .grid-7569, .grid-7744, .grid-7921, .grid-8100, .grid-8281, .grid-8464, .grid-8649, .grid-8836, .grid-9025, .grid-9216, .grid-9409, .grid-9604, .grid-9801, .grid-10000 {
      --circle-size-large: clamp(12px, 7vw, 70px); /* Allow much smaller when zoomed out */
      --circle-total-large: calc(var(--circle-size-large) + var(--circle-border) * 2);
    }
    /* 34×34 (1156) - same size as 13×13 grid */
    .grid-1156 {
      --circle-total-1156: calc(var(--circle-total) * 13 / 34);
      grid-template-columns: repeat(34, var(--circle-total-1156)) !important;
      grid-template-rows: repeat(34, var(--circle-total-1156)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1156 .circle {
      width: var(--circle-total-1156) !important;
      height: var(--circle-total-1156) !important;
      border-width: 0.5px !important;
    }
    /* 35×35 (1225) - same size as 13×13 grid */
    .grid-1225 {
      --circle-total-1225: calc(var(--circle-total) * 13 / 35);
      grid-template-columns: repeat(35, var(--circle-total-1225)) !important;
      grid-template-rows: repeat(35, var(--circle-total-1225)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1225 .circle {
      width: var(--circle-total-1225) !important;
      height: var(--circle-total-1225) !important;
      border-width: 0.5px !important;
    }
    /* 36×36 (1296) - same size as 13×13 grid */
    .grid-1296 {
      --circle-total-1296: calc(var(--circle-total) * 13 / 36);
      grid-template-columns: repeat(36, var(--circle-total-1296)) !important;
      grid-template-rows: repeat(36, var(--circle-total-1296)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1296 .circle {
      width: var(--circle-total-1296) !important;
      height: var(--circle-total-1296) !important;
      border-width: 0.5px !important;
    }
    /* 37×37 (1369) - same size as 13×13 grid */
    .grid-1369 {
      --circle-total-1369: calc(var(--circle-total) * 13 / 37);
      grid-template-columns: repeat(37, var(--circle-total-1369)) !important;
      grid-template-rows: repeat(37, var(--circle-total-1369)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1369 .circle {
      width: var(--circle-total-1369) !important;
      height: var(--circle-total-1369) !important;
      border-width: 0.5px !important;
    }
    /* 38×38 (1444) - same size as 13×13 grid */
    .grid-1444 {
      --circle-total-1444: calc(var(--circle-total) * 13 / 38);
      grid-template-columns: repeat(38, var(--circle-total-1444)) !important;
      grid-template-rows: repeat(38, var(--circle-total-1444)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1444 .circle {
      width: var(--circle-total-1444) !important;
      height: var(--circle-total-1444) !important;
      border-width: 0.5px !important;
    }
    /* 39×39 (1521) - same size as 13×13 grid - MUST come after general rule to override */
    .grid-1521 {
      --circle-total-1521: calc(var(--circle-total) * 13 / 39);
      grid-template-columns: repeat(39, var(--circle-total-1521)) !important;
      grid-template-rows: repeat(39, var(--circle-total-1521)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1521 .circle {
      width: var(--circle-total-1521) !important;
      height: var(--circle-total-1521) !important;
      border-width: 0.5px !important;
    }
    /* 40×40 (1600) - same size as 13×13 grid */
    .grid-1600 {
      --circle-total-1600: calc(var(--circle-total) * 13 / 40);
      grid-template-columns: repeat(40, var(--circle-total-1600)) !important;
      grid-template-rows: repeat(40, var(--circle-total-1600)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1600 .circle {
      width: var(--circle-total-1600) !important;
      height: var(--circle-total-1600) !important;
      border-width: 0.5px !important;
    }
    /* 41×41 (1681) - same size as 13×13 grid */
    .grid-1681 {
      --circle-total-1681: calc(var(--circle-total) * 13 / 41);
      grid-template-columns: repeat(41, var(--circle-total-1681)) !important;
      grid-template-rows: repeat(41, var(--circle-total-1681)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1681 .circle {
      width: var(--circle-total-1681) !important;
      height: var(--circle-total-1681) !important;
      border-width: 0.5px !important;
    }
    /* 42×42 (1764) - same size as 13×13 grid */
    .grid-1764 {
      --circle-total-1764: calc(var(--circle-total) * 13 / 42);
      grid-template-columns: repeat(42, var(--circle-total-1764)) !important;
      grid-template-rows: repeat(42, var(--circle-total-1764)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1764 .circle {
      width: var(--circle-total-1764) !important;
      height: var(--circle-total-1764) !important;
      border-width: 0.5px !important;
    }
    /* 43×43 (1849) - same size as 13×13 grid */
    .grid-1849 {
      --circle-total-1849: calc(var(--circle-total) * 13 / 43);
      grid-template-columns: repeat(43, var(--circle-total-1849)) !important;
      grid-template-rows: repeat(43, var(--circle-total-1849)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1849 .circle {
      width: var(--circle-total-1849) !important;
      height: var(--circle-total-1849) !important;
      border-width: 0.5px !important;
    }
    /* 44×44 (1936) - same size as 13×13 grid */
    .grid-1936 {
      --circle-total-1936: calc(var(--circle-total) * 13 / 44);
      grid-template-columns: repeat(44, var(--circle-total-1936)) !important;
      grid-template-rows: repeat(44, var(--circle-total-1936)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-1936 .circle {
      width: var(--circle-total-1936) !important;
      height: var(--circle-total-1936) !important;
      border-width: 0.5px !important;
    }
    /* 45×45 (2025) - same size as 13×13 grid */
    .grid-2025 {
      --circle-total-2025: calc(var(--circle-total) * 13 / 45);
      grid-template-columns: repeat(45, var(--circle-total-2025)) !important;
      grid-template-rows: repeat(45, var(--circle-total-2025)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2025 .circle {
      width: var(--circle-total-2025) !important;
      height: var(--circle-total-2025) !important;
      border-width: 0.5px !important;
    }
    /* 46×46 (2116) - same size as 13×13 grid */
    .grid-2116 {
      --circle-total-2116: calc(var(--circle-total) * 13 / 46);
      grid-template-columns: repeat(46, var(--circle-total-2116)) !important;
      grid-template-rows: repeat(46, var(--circle-total-2116)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2116 .circle {
      width: var(--circle-total-2116) !important;
      height: var(--circle-total-2116) !important;
      border-width: 0.5px !important;
    }
    /* 47×47 (2209) - same size as 13×13 grid */
    .grid-2209 {
      --circle-total-2209: calc(var(--circle-total) * 13 / 47);
      grid-template-columns: repeat(47, var(--circle-total-2209)) !important;
      grid-template-rows: repeat(47, var(--circle-total-2209)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2209 .circle {
      width: var(--circle-total-2209) !important;
      height: var(--circle-total-2209) !important;
      border-width: 0.5px !important;
    }
    /* 48×48 (2304) - same size as 13×13 grid */
    .grid-2304 {
      --circle-total-2304: calc(var(--circle-total) * 13 / 48);
      grid-template-columns: repeat(48, var(--circle-total-2304)) !important;
      grid-template-rows: repeat(48, var(--circle-total-2304)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2304 .circle {
      width: var(--circle-total-2304) !important;
      height: var(--circle-total-2304) !important;
      border-width: 0.5px !important;
    }
    /* 49×49 (2401) - same size as 13×13 grid */
    .grid-2401 {
      --circle-total-2401: calc(var(--circle-total) * 13 / 49);
      grid-template-columns: repeat(49, var(--circle-total-2401)) !important;
      grid-template-rows: repeat(49, var(--circle-total-2401)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2401 .circle {
      width: var(--circle-total-2401) !important;
      height: var(--circle-total-2401) !important;
      border-width: 0.5px !important;
    }
    /* 50×50 (2500) - same size as 13×13 grid */
    .grid-2500 {
      --circle-total-2500: calc(var(--circle-total) * 13 / 50);
      grid-template-columns: repeat(50, var(--circle-total-2500)) !important;
      grid-template-rows: repeat(50, var(--circle-total-2500)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2500 .circle {
      width: var(--circle-total-2500) !important;
      height: var(--circle-total-2500) !important;
      border-width: 0.5px !important;
    }
    /* 51×51 (2601) - same size as 13×13 grid */
    .grid-2601 {
      --circle-total-2601: calc(var(--circle-total) * 13 / 51);
      grid-template-columns: repeat(51, var(--circle-total-2601)) !important;
      grid-template-rows: repeat(51, var(--circle-total-2601)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2601 .circle {
      width: var(--circle-total-2601) !important;
      height: var(--circle-total-2601) !important;
      border-width: 0.5px !important;
    }
    /* 52×52 (2704) - same size as 13×13 grid */
    .grid-2704 {
      --circle-total-2704: calc(var(--circle-total) * 13 / 52);
      grid-template-columns: repeat(52, var(--circle-total-2704)) !important;
      grid-template-rows: repeat(52, var(--circle-total-2704)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2704 .circle {
      width: var(--circle-total-2704) !important;
      height: var(--circle-total-2704) !important;
      border-width: 0.5px !important;
    }
    /* 53×53 (2809) - same size as 13×13 grid */
    .grid-2809 {
      --circle-total-2809: calc(var(--circle-total) * 13 / 53);
      grid-template-columns: repeat(53, var(--circle-total-2809)) !important;
      grid-template-rows: repeat(53, var(--circle-total-2809)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2809 .circle {
      width: var(--circle-total-2809) !important;
      height: var(--circle-total-2809) !important;
      border-width: 0.5px !important;
    }
    /* 54×54 (2916) - same size as 13×13 grid */
    .grid-2916 {
      --circle-total-2916: calc(var(--circle-total) * 13 / 54);
      grid-template-columns: repeat(54, var(--circle-total-2916)) !important;
      grid-template-rows: repeat(54, var(--circle-total-2916)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-2916 .circle {
      width: var(--circle-total-2916) !important;
      height: var(--circle-total-2916) !important;
      border-width: 0.5px !important;
    }
    /* 55×55 (3025) - same size as 13×13 grid */
    .grid-3025 {
      --circle-total-3025: calc(var(--circle-total) * 13 / 55);
      grid-template-columns: repeat(55, var(--circle-total-3025)) !important;
      grid-template-rows: repeat(55, var(--circle-total-3025)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3025 .circle {
      width: var(--circle-total-3025) !important;
      height: var(--circle-total-3025) !important;
      border-width: 0.5px !important;
    }
    /* 56×56 (3136) - same size as 13×13 grid */
    .grid-3136 {
      --circle-total-3136: calc(var(--circle-total) * 13 / 56);
      grid-template-columns: repeat(56, var(--circle-total-3136)) !important;
      grid-template-rows: repeat(56, var(--circle-total-3136)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3136 .circle {
      width: var(--circle-total-3136) !important;
      height: var(--circle-total-3136) !important;
      border-width: 0.5px !important;
    }
    /* 57×57 (3249) - same size as 13×13 grid */
    .grid-3249 {
      --circle-total-3249: calc(var(--circle-total) * 13 / 57);
      grid-template-columns: repeat(57, var(--circle-total-3249)) !important;
      grid-template-rows: repeat(57, var(--circle-total-3249)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3249 .circle {
      width: var(--circle-total-3249) !important;
      height: var(--circle-total-3249) !important;
      border-width: 0.5px !important;
    }
    /* 58×58 (3364) - same size as 13×13 grid */
    .grid-3364 {
      --circle-total-3364: calc(var(--circle-total) * 13 / 58);
      grid-template-columns: repeat(58, var(--circle-total-3364)) !important;
      grid-template-rows: repeat(58, var(--circle-total-3364)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3364 .circle {
      width: var(--circle-total-3364) !important;
      height: var(--circle-total-3364) !important;
      border-width: 0.5px !important;
    }
    /* 59×59 (3481) - same size as 13×13 grid */
    .grid-3481 {
      --circle-total-3481: calc(var(--circle-total) * 13 / 59);
      grid-template-columns: repeat(59, var(--circle-total-3481)) !important;
      grid-template-rows: repeat(59, var(--circle-total-3481)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3481 .circle {
      width: var(--circle-total-3481) !important;
      height: var(--circle-total-3481) !important;
      border-width: 0.5px !important;
    }
    /* 60×60 (3600) - same size as 13×13 grid */
    .grid-3600 {
      --circle-total-3600: calc(var(--circle-total) * 13 / 60);
      grid-template-columns: repeat(60, var(--circle-total-3600)) !important;
      grid-template-rows: repeat(60, var(--circle-total-3600)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3600 .circle {
      width: var(--circle-total-3600) !important;
      height: var(--circle-total-3600) !important;
      border-width: 0.5px !important;
    }
    /* 61×61 (3721) - same size as 13×13 grid */
    .grid-3721 {
      --circle-total-3721: calc(var(--circle-total) * 13 / 61);
      grid-template-columns: repeat(61, var(--circle-total-3721)) !important;
      grid-template-rows: repeat(61, var(--circle-total-3721)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3721 .circle {
      width: var(--circle-total-3721) !important;
      height: var(--circle-total-3721) !important;
      border-width: 0.5px !important;
    }
    .grid-3844 {
      --circle-total-3844: calc(var(--circle-total) * 13 / 62);
      grid-template-columns: repeat(62, var(--circle-total-3844)) !important;
      grid-template-rows: repeat(62, var(--circle-total-3844)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3844 .circle {
      width: var(--circle-total-3844) !important;
      height: var(--circle-total-3844) !important;
      border-width: 0.5px !important;
    }
    .grid-3969 {
      --circle-total-3969: calc(var(--circle-total) * 13 / 63);
      grid-template-columns: repeat(63, var(--circle-total-3969)) !important;
      grid-template-rows: repeat(63, var(--circle-total-3969)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-3969 .circle {
      width: var(--circle-total-3969) !important;
      height: var(--circle-total-3969) !important;
      border-width: 0.5px !important;
    }
    .grid-4096 {
      --circle-total-4096: calc(var(--circle-total) * 13 / 64);
      grid-template-columns: repeat(64, var(--circle-total-4096)) !important;
      grid-template-rows: repeat(64, var(--circle-total-4096)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-4096 .circle {
      width: var(--circle-total-4096) !important;
      height: var(--circle-total-4096) !important;
      border-width: 0.5px !important;
    }
    .grid-4225 {
      --circle-total-4225: calc(var(--circle-total) * 13 / 65);
      grid-template-columns: repeat(65, var(--circle-total-4225)) !important;
      grid-template-rows: repeat(65, var(--circle-total-4225)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-4225 .circle {
      width: var(--circle-total-4225) !important;
      height: var(--circle-total-4225) !important;
      border-width: 0.5px !important;
    }
    .grid-4356 {
      --circle-total-4356: calc(var(--circle-total) * 13 / 66);
      grid-template-columns: repeat(66, var(--circle-total-4356)) !important;
      grid-template-rows: repeat(66, var(--circle-total-4356)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-4356 .circle {
      width: var(--circle-total-4356) !important;
      height: var(--circle-total-4356) !important;
      border-width: 0.5px !important;
    }
    .grid-4489 {
      --circle-total-4489: calc(var(--circle-total) * 13 / 67);
      grid-template-columns: repeat(67, var(--circle-total-4489)) !important;
      grid-template-rows: repeat(67, var(--circle-total-4489)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-4489 .circle {
      width: var(--circle-total-4489) !important;
      height: var(--circle-total-4489) !important;
      border-width: 0.5px !important;
    }
    .grid-4624 {
      --circle-total-4624: calc(var(--circle-total) * 13 / 68);
      grid-template-columns: repeat(68, var(--circle-total-4624)) !important;
      grid-template-rows: repeat(68, var(--circle-total-4624)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-4624 .circle {
      width: var(--circle-total-4624) !important;
      height: var(--circle-total-4624) !important;
      border-width: 0.5px !important;
    }
    .grid-4761 {
      --circle-total-4761: calc(var(--circle-total) * 13 / 69);
      grid-template-columns: repeat(69, var(--circle-total-4761)) !important;
      grid-template-rows: repeat(69, var(--circle-total-4761)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-4761 .circle {
      width: var(--circle-total-4761) !important;
      height: var(--circle-total-4761) !important;
      border-width: 0.5px !important;
    }
    .grid-4900 {
      --circle-total-4900: calc(var(--circle-total) * 13 / 70);
      grid-template-columns: repeat(70, var(--circle-total-4900)) !important;
      grid-template-rows: repeat(70, var(--circle-total-4900)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-4900 .circle {
      width: var(--circle-total-4900) !important;
      height: var(--circle-total-4900) !important;
      border-width: 0.5px !important;
    }
    /* All grids 71×71 through 100×100 - same size as 13×13 grid */
    .grid-5041 {
      --circle-total-5041: calc(var(--circle-total) * 13 / 71);
      grid-template-columns: repeat(71, var(--circle-total-5041)) !important;
      grid-template-rows: repeat(71, var(--circle-total-5041)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-5041 .circle {
      width: var(--circle-total-5041) !important;
      height: var(--circle-total-5041) !important;
      border-width: 0.5px !important;
    }
    .grid-5184 {
      --circle-total-5184: calc(var(--circle-total) * 13 / 72);
      grid-template-columns: repeat(72, var(--circle-total-5184)) !important;
      grid-template-rows: repeat(72, var(--circle-total-5184)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-5184 .circle {
      width: var(--circle-total-5184) !important;
      height: var(--circle-total-5184) !important;
      border-width: 0.5px !important;
    }
    .grid-5329 {
      --circle-total-5329: calc(var(--circle-total) * 13 / 73);
      grid-template-columns: repeat(73, var(--circle-total-5329)) !important;
      grid-template-rows: repeat(73, var(--circle-total-5329)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-5329 .circle {
      width: var(--circle-total-5329) !important;
      height: var(--circle-total-5329) !important;
      border-width: 0.5px !important;
    }
    .grid-5476 {
      --circle-total-5476: calc(var(--circle-total) * 13 / 74);
      grid-template-columns: repeat(74, var(--circle-total-5476)) !important;
      grid-template-rows: repeat(74, var(--circle-total-5476)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-5476 .circle {
      width: var(--circle-total-5476) !important;
      height: var(--circle-total-5476) !important;
      border-width: 0.5px !important;
    }
    .grid-5625 {
      --circle-total-5625: calc(var(--circle-total) * 13 / 75);
      grid-template-columns: repeat(75, var(--circle-total-5625)) !important;
      grid-template-rows: repeat(75, var(--circle-total-5625)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-5625 .circle {
      width: var(--circle-total-5625) !important;
      height: var(--circle-total-5625) !important;
      border-width: 0.5px !important;
    }
    .grid-5776 {
      --circle-total-5776: calc(var(--circle-total) * 13 / 76);
      grid-template-columns: repeat(76, var(--circle-total-5776)) !important;
      grid-template-rows: repeat(76, var(--circle-total-5776)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-5776 .circle {
      width: var(--circle-total-5776) !important;
      height: var(--circle-total-5776) !important;
      border-width: 0.5px !important;
    }
    .grid-5929 {
      --circle-total-5929: calc(var(--circle-total) * 13 / 77);
      grid-template-columns: repeat(77, var(--circle-total-5929)) !important;
      grid-template-rows: repeat(77, var(--circle-total-5929)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-5929 .circle {
      width: var(--circle-total-5929) !important;
      height: var(--circle-total-5929) !important;
      border-width: 0.5px !important;
    }
    .grid-6084 {
      --circle-total-6084: calc(var(--circle-total) * 13 / 78);
      grid-template-columns: repeat(78, var(--circle-total-6084)) !important;
      grid-template-rows: repeat(78, var(--circle-total-6084)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-6084 .circle {
      width: var(--circle-total-6084) !important;
      height: var(--circle-total-6084) !important;
      border-width: 0.5px !important;
    }
    .grid-6241 {
      --circle-total-6241: calc(var(--circle-total) * 13 / 79);
      grid-template-columns: repeat(79, var(--circle-total-6241)) !important;
      grid-template-rows: repeat(79, var(--circle-total-6241)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-6241 .circle {
      width: var(--circle-total-6241) !important;
      height: var(--circle-total-6241) !important;
      border-width: 0.5px !important;
    }
    .grid-6400 {
      --circle-total-6400: calc(var(--circle-total) * 13 / 80);
      grid-template-columns: repeat(80, var(--circle-total-6400)) !important;
      grid-template-rows: repeat(80, var(--circle-total-6400)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-6400 .circle {
      width: var(--circle-total-6400) !important;
      height: var(--circle-total-6400) !important;
      border-width: 0.5px !important;
    }
    .grid-6561 {
      --circle-total-6561: calc(var(--circle-total) * 13 / 81);
      grid-template-columns: repeat(81, var(--circle-total-6561)) !important;
      grid-template-rows: repeat(81, var(--circle-total-6561)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-6561 .circle {
      width: var(--circle-total-6561) !important;
      height: var(--circle-total-6561) !important;
      border-width: 0.5px !important;
    }
    .grid-6724 {
      --circle-total-6724: calc(var(--circle-total) * 13 / 82);
      grid-template-columns: repeat(82, var(--circle-total-6724)) !important;
      grid-template-rows: repeat(82, var(--circle-total-6724)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-6724 .circle {
      width: var(--circle-total-6724) !important;
      height: var(--circle-total-6724) !important;
      border-width: 0.5px !important;
    }
    .grid-6889 {
      --circle-total-6889: calc(var(--circle-total) * 13 / 83);
      grid-template-columns: repeat(83, var(--circle-total-6889)) !important;
      grid-template-rows: repeat(83, var(--circle-total-6889)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-6889 .circle {
      width: var(--circle-total-6889) !important;
      height: var(--circle-total-6889) !important;
      border-width: 0.5px !important;
    }
    .grid-7056 {
      --circle-total-7056: calc(var(--circle-total) * 13 / 84);
      grid-template-columns: repeat(84, var(--circle-total-7056)) !important;
      grid-template-rows: repeat(84, var(--circle-total-7056)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-7056 .circle {
      width: var(--circle-total-7056) !important;
      height: var(--circle-total-7056) !important;
      border-width: 0.5px !important;
    }
    .grid-7225 {
      --circle-total-7225: calc(var(--circle-total) * 13 / 85);
      grid-template-columns: repeat(85, var(--circle-total-7225)) !important;
      grid-template-rows: repeat(85, var(--circle-total-7225)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-7225 .circle {
      width: var(--circle-total-7225) !important;
      height: var(--circle-total-7225) !important;
      border-width: 0.5px !important;
    }
    .grid-7396 {
      --circle-total-7396: calc(var(--circle-total) * 13 / 86);
      grid-template-columns: repeat(86, var(--circle-total-7396)) !important;
      grid-template-rows: repeat(86, var(--circle-total-7396)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-7396 .circle {
      width: var(--circle-total-7396) !important;
      height: var(--circle-total-7396) !important;
      border-width: 0.5px !important;
    }
    .grid-7569 {
      --circle-total-7569: calc(var(--circle-total) * 13 / 87);
      grid-template-columns: repeat(87, var(--circle-total-7569)) !important;
      grid-template-rows: repeat(87, var(--circle-total-7569)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-7569 .circle {
      width: var(--circle-total-7569) !important;
      height: var(--circle-total-7569) !important;
      border-width: 0.5px !important;
    }
    .grid-7744 {
      --circle-total-7744: calc(var(--circle-total) * 13 / 88);
      grid-template-columns: repeat(88, var(--circle-total-7744)) !important;
      grid-template-rows: repeat(88, var(--circle-total-7744)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-7744 .circle {
      width: var(--circle-total-7744) !important;
      height: var(--circle-total-7744) !important;
      border-width: 0.5px !important;
    }
    .grid-7921 {
      --circle-total-7921: calc(var(--circle-total) * 13 / 89);
      grid-template-columns: repeat(89, var(--circle-total-7921)) !important;
      grid-template-rows: repeat(89, var(--circle-total-7921)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-7921 .circle {
      width: var(--circle-total-7921) !important;
      height: var(--circle-total-7921) !important;
      border-width: 0.5px !important;
    }
    .grid-8100 {
      --circle-total-8100: calc(var(--circle-total) * 13 / 90);
      grid-template-columns: repeat(90, var(--circle-total-8100)) !important;
      grid-template-rows: repeat(90, var(--circle-total-8100)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-8100 .circle {
      width: var(--circle-total-8100) !important;
      height: var(--circle-total-8100) !important;
      border-width: 0.5px !important;
    }
    .grid-8281 {
      --circle-total-8281: calc(var(--circle-total) * 13 / 91);
      grid-template-columns: repeat(91, var(--circle-total-8281)) !important;
      grid-template-rows: repeat(91, var(--circle-total-8281)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-8281 .circle {
      width: var(--circle-total-8281) !important;
      height: var(--circle-total-8281) !important;
      border-width: 0.5px !important;
    }
    .grid-8464 {
      --circle-total-8464: calc(var(--circle-total) * 13 / 92);
      grid-template-columns: repeat(92, var(--circle-total-8464)) !important;
      grid-template-rows: repeat(92, var(--circle-total-8464)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-8464 .circle {
      width: var(--circle-total-8464) !important;
      height: var(--circle-total-8464) !important;
      border-width: 0.5px !important;
    }
    .grid-8649 {
      --circle-total-8649: calc(var(--circle-total) * 13 / 93);
      grid-template-columns: repeat(93, var(--circle-total-8649)) !important;
      grid-template-rows: repeat(93, var(--circle-total-8649)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-8649 .circle {
      width: var(--circle-total-8649) !important;
      height: var(--circle-total-8649) !important;
      border-width: 0.5px !important;
    }
    .grid-8836 {
      --circle-total-8836: calc(var(--circle-total) * 13 / 94);
      grid-template-columns: repeat(94, var(--circle-total-8836)) !important;
      grid-template-rows: repeat(94, var(--circle-total-8836)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-8836 .circle {
      width: var(--circle-total-8836) !important;
      height: var(--circle-total-8836) !important;
      border-width: 0.5px !important;
    }
    .grid-9025 {
      --circle-total-9025: calc(var(--circle-total) * 13 / 95);
      grid-template-columns: repeat(95, var(--circle-total-9025)) !important;
      grid-template-rows: repeat(95, var(--circle-total-9025)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-9025 .circle {
      width: var(--circle-total-9025) !important;
      height: var(--circle-total-9025) !important;
      border-width: 0.5px !important;
    }
    .grid-9216 {
      --circle-total-9216: calc(var(--circle-total) * 13 / 96);
      grid-template-columns: repeat(96, var(--circle-total-9216)) !important;
      grid-template-rows: repeat(96, var(--circle-total-9216)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-9216 .circle {
      width: var(--circle-total-9216) !important;
      height: var(--circle-total-9216) !important;
      border-width: 0.5px !important;
    }
    .grid-9409 {
      --circle-total-9409: calc(var(--circle-total) * 13 / 97);
      grid-template-columns: repeat(97, var(--circle-total-9409)) !important;
      grid-template-rows: repeat(97, var(--circle-total-9409)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-9409 .circle {
      width: var(--circle-total-9409) !important;
      height: var(--circle-total-9409) !important;
      border-width: 0.5px !important;
    }
    .grid-9604 {
      --circle-total-9604: calc(var(--circle-total) * 13 / 98);
      grid-template-columns: repeat(98, var(--circle-total-9604)) !important;
      grid-template-rows: repeat(98, var(--circle-total-9604)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-9604 .circle {
      width: var(--circle-total-9604) !important;
      height: var(--circle-total-9604) !important;
      border-width: 0.5px !important;
    }
    .grid-9801 {
      --circle-total-9801: calc(var(--circle-total) * 13 / 99);
      grid-template-columns: repeat(99, var(--circle-total-9801)) !important;
      grid-template-rows: repeat(99, var(--circle-total-9801)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-9801 .circle {
      width: var(--circle-total-9801) !important;
      height: var(--circle-total-9801) !important;
      border-width: 0.5px !important;
    }
    .grid-10000 {
      --circle-total-10000: calc(var(--circle-total) * 13 / 100);
      grid-template-columns: repeat(100, var(--circle-total-10000)) !important;
      grid-template-rows: repeat(100, var(--circle-total-10000)) !important;
      width: calc(var(--circle-total) * 13) !important;
      height: calc(var(--circle-total) * 13) !important;
    }
    .grid-10000 .circle {
      width: var(--circle-total-10000) !important;
      height: var(--circle-total-10000) !important;
      border-width: 0.5px !important;
    }
    /* Removed old circle size rules for 676, 729, 784, 841, 900 - now using grid-specific sizes */
    /* Circle sizes for grids 34×34 through 50×50 */
    /* 1156, 1225 use regular size like square 33 (1089) */
    /* 1296 (36×36) uses larger size for readability */
    /* Removed circle-1156 and circle-1225 - now using grid-specific sizes */
    /* Removed circle-1296, circle-1369, and circle-1444 - now using grid-specific sizes */
    /* Removed circle-1600, circle-1681, circle-1764, circle-1849, circle-1936, circle-2025, circle-2116 - now using grid-specific sizes */
    .circle-1521, .circle-2209,
    .circle-2304, .circle-2401, .circle-2500, .circle-2601, .circle-2704, .circle-2809, .circle-2916, .circle-3025, .circle-3136, .circle-3249, .circle-3364, .circle-3481, .circle-3600, .circle-3721, .circle-3844, .circle-3969, .circle-4096, .circle-4225, .circle-4356, .circle-4489, .circle-4624, .circle-4761, .circle-4900, .circle-5041, .circle-5184, .circle-5329, .circle-5476, .circle-5625, .circle-5776, .circle-5929, .circle-6084, .circle-6241, .circle-6400, .circle-6561, .circle-6724, .circle-6889, .circle-7056, .circle-7225, .circle-7396, .circle-7569, .circle-7744, .circle-7921, .circle-8100, .circle-8281, .circle-8464, .circle-8649, .circle-8836, .circle-9025, .circle-9216, .circle-9409, .circle-9604, .circle-9801, .circle-10000 {
      width: var(--circle-total) !important;
      height: var(--circle-total) !important;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    /* Number styling for 26×26 through 30×30 grids */
    .circle-number {
      font-size: clamp(4px, 1.2vw, 12px); /* Smaller font size */
      font-weight: bold;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8), -1px -1px 2px rgba(0, 0, 0, 0.8);
      pointer-events: none;
      user-select: none;
      z-index: 1;
      line-height: 1;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }
    /* Larger numbers for very large squares 39×39 and above */
    .circle-1521 .circle-number {
      font-size: clamp(10px, 3vw, 32px); /* Allow smaller when zoomed out */
      font-weight: bold;
    }
    /* Numbers for 40×40 through 44×44 grids - scale with circle size */
    .circle-1600 .circle-number {
      font-size: clamp(3px, calc(var(--circle-total-1600) * 0.4), 8px) !important;
    }
    .circle-1681 .circle-number {
      font-size: clamp(3px, calc(var(--circle-total-1681) * 0.4), 8px) !important;
    }
    .circle-1764 .circle-number {
      font-size: clamp(3px, calc(var(--circle-total-1764) * 0.4), 8px) !important;
    }
    .circle-1849 .circle-number {
      font-size: clamp(3px, calc(var(--circle-total-1849) * 0.4), 8px) !important;
    }
    .circle-1936 .circle-number {
      font-size: clamp(3px, calc(var(--circle-total-1936) * 0.4), 8px) !important;
    }
    /* Numbers for 45×45 grid - scale with circle size */
    .circle-2025 .circle-number {
      font-size: clamp(3px, calc(var(--circle-total-2025) * 0.4), 8px) !important;
    }
    /* Numbers for 46×46 grid - scale with circle size */
    .circle-2116 .circle-number {
      font-size: clamp(3px, calc(var(--circle-total-2116) * 0.4), 8px) !important;
    }
    .circle-2209 .circle-number,
    .circle-2209 .circle-number,
    .circle-2304 .circle-number,
    .circle-2401 .circle-number,
    .circle-2500 .circle-number,
    .circle-2601 .circle-number,
    .circle-2704 .circle-number,
    .circle-2809 .circle-number,
    .circle-2916 .circle-number,
    .circle-3025 .circle-number,
    .circle-3136 .circle-number,
    .circle-3249 .circle-number,
    .circle-3364 .circle-number,
    .circle-3481 .circle-number,
    .circle-3600 .circle-number,
    .circle-3721 .circle-number,
    .circle-3844 .circle-number,
    .circle-3969 .circle-number,
    .circle-4096 .circle-number,
    .circle-4225 .circle-number,
    .circle-4356 .circle-number,
    .circle-4489 .circle-number,
    .circle-4624 .circle-number,
    .circle-4761 .circle-number,
    .circle-4900 .circle-number,
    .circle-5041 .circle-number,
    .circle-5184 .circle-number,
    .circle-5329 .circle-number,
    .circle-5476 .circle-number,
    .circle-5625 .circle-number,
    .circle-5776 .circle-number,
    .circle-5929 .circle-number,
    .circle-6084 .circle-number,
    .circle-6241 .circle-number,
    .circle-6400 .circle-number,
    .circle-6561 .circle-number,
    .circle-6724 .circle-number,
    .circle-6889 .circle-number,
    .circle-7056 .circle-number,
    .circle-7225 .circle-number,
    .circle-7396 .circle-number,
    .circle-7569 .circle-number,
    .circle-7744 .circle-number,
    .circle-7921 .circle-number,
    .circle-8100 .circle-number,
    .circle-8281 .circle-number,
    .circle-8464 .circle-number,
    .circle-8649 .circle-number,
    .circle-8836 .circle-number,
    .circle-9025 .circle-number,
    .circle-9216 .circle-number,
    .circle-9409 .circle-number,
    .circle-9604 .circle-number,
    .circle-9801 .circle-number,
    .circle-10000 .circle-number {
      font-size: clamp(10px, 3vw, 32px); /* Allow smaller when zoomed out */
      font-weight: bold;
    }
    .circle.red .circle-number,
    .circle.orange .circle-number,
    .circle.yellow .circle-number,
    .circle.green .circle-number,
    .circle.blue .circle-number,
    .circle.purple .circle-number,
    .circle.brown .circle-number,
    .circle.pink .circle-number,
    .circle.sky .circle-number,
    .circle.red-final .circle-number {
      color: #fff;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9), -1px -1px 3px rgba(0, 0, 0, 0.9);
    }

    /* Single circle */
    .single-circle {
      width: var(--circle-total);
      height: var(--circle-total);
    }

    /* 2x2 grid (4 circles) */
    .grid-two {
      display: grid;
      grid-template-columns: repeat(2, var(--circle-total));
      grid-template-rows: repeat(2, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 2);
      height: calc(var(--circle-total) * 2);
    }
    .grid-two .circle {
      position: static;
    }

    /* 3x3 grid (9 circles) */
    .grid-three {
      display: grid;
      grid-template-columns: repeat(3, var(--circle-total));
      grid-template-rows: repeat(3, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 3);
      height: calc(var(--circle-total) * 3);
    }
    .grid-three .circle {
      position: static;
    }

    /* 4x4 grid (16 circles) */
    .grid-four {
      display: grid;
      grid-template-columns: repeat(4, var(--circle-total));
      grid-template-rows: repeat(4, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 4);
      height: calc(var(--circle-total) * 4);
    }
    .grid-four .circle {
      position: static;
    }

    /* 5x5 grid (25 circles) */
    .grid-five {
      display: grid;
      grid-template-columns: repeat(5, var(--circle-total));
      grid-template-rows: repeat(5, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 5);
      height: calc(var(--circle-total) * 5);
    }
    .grid-five .circle {
      position: static;
    }

    /* Dynamic grid classes for larger squares */
    .grid-dynamic {
      display: grid;
      gap: 0;
      cursor: pointer;
      overflow: visible;
      min-width: min-content;
    }
    /* Ensure all grids can overflow and be scrollable */
    [class*="grid-"], .grid-dynamic {
      overflow: visible;
      min-width: min-content;
    }
    .grid-dynamic .circle {
      position: static;
    }
  </style>
</head>
<body>
  <!-- Navigation and controls moved to top of DOM so they appear at bottom visually with column-reverse -->
  <div class="game-navigation">
    <a href="index.html" class="game-nav-button">← Go Back</a>
    <a href="bigger-smaller.html" class="game-nav-button">Bigger/Smaller</a>
    <a href="squares.html" class="game-nav-button">Squares</a>
    <a href="squares-opposite.html" class="game-nav-button">Squares Opposite</a>
    <a href="squares - game.html" class="game-nav-button">Squares Game</a>
    <a href="squares game2.html" class="game-nav-button active">Squares Game 2</a>
  </div>

  <div class="controls" role="group" aria-label="Language selector">
    <div class="lang-group">
      <button data-lang="en" class="active">English</button>
      <button class="dual" data-mode="sound">Sound</button>
    </div>
    <div class="lang-group">
      <button data-lang="vi">Tiếng Việt</button>
      <button class="dual" data-dual="vi">Tiếng Việt + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="zh">中文</button>
      <button class="dual" data-dual="zh">中文 + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="ko">한국어</button>
      <button class="dual" data-dual="ko">한국어 + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="es">Español</button>
      <button class="dual" data-dual="es">Español + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="fr">Français</button>
      <button class="dual" data-dual="fr">Français + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="hi">हिन्दी</button>
      <button class="dual" data-dual="hi">हिन्दी + English</button>
    </div>
  </div>

  <!-- Answer Input Field -->
  <div class="answer-input-container">
    <label for="answerInput">Type the square number:</label>
    <div class="answer-input-wrapper">
      <input type="number" id="answerInput" placeholder="?" min="1" autocomplete="off">
      <button id="submitAnswer">Submit</button>
    </div>
    <div class="next-square-hint" id="nextSquareHint">Next: 1² = 1</div>
  </div>

  <section class="set" data-square="1" data-base="1">
    <h2>1²</h2>
    <div class="single-circle">
      <div class="circle" id="one"></div>
    </div>
    <div class="answer-display" data-answer="1"></div>
  </section>

  <section class="set" data-square="4" data-base="2">
    <h2>2²</h2>
    <div class="grid-two" id="four">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="4"></div>
  </section>

  <section class="set" data-square="9" data-base="3">
    <h2>3²</h2>
    <div class="grid-three" id="nine">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="9"></div>
  </section>

  <section class="set" data-square="16" data-base="4">
    <h2>4²</h2>
    <div class="grid-four" id="sixteen">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="16"></div>
  </section>

  <section class="set" data-square="25" data-base="5">
    <h2>5²</h2>
    <div class="grid-five" id="square-25"></div>
    <div class="answer-display" data-answer="25"></div>
  </section>

  <div id="moreSquares"></div>

<script>
const COLOR_CLASSES = ["orange","yellow","green","blue","purple","brown","pink","sky","red-final"];

// Performance optimization: Batch DOM updates for faster rendering
function batchUpdateCircles(circles, indices, colorClass, removeClasses = COLOR_CLASSES) {
  if (!circles || !indices || indices.length === 0) return;
  
  // For very large batches (1000+), use requestAnimationFrame to avoid blocking
  if (indices.length > 1000) {
    const batchSize = 500;
    let currentIndex = 0;
    
    const processBatch = () => {
      const endIndex = Math.min(currentIndex + batchSize, indices.length);
      
      // Batch DOM reads first
      const updates = [];
      for (let i = currentIndex; i < endIndex; i++) {
        const idx = indices[i];
        if (circles[idx]) {
          updates.push({ circle: circles[idx], idx });
        }
      }
      
      // Then batch DOM writes
      updates.forEach(({ circle }) => {
        circle.classList.remove(...removeClasses, 'red');
        if (colorClass) {
          circle.classList.add(colorClass);
        }
      });
      
      currentIndex = endIndex;
      
      if (currentIndex < indices.length) {
        requestAnimationFrame(processBatch);
      }
    };
    
    requestAnimationFrame(processBatch);
  } else {
    // For smaller batches, do it synchronously but still batch the operations
    // Use DocumentFragment approach: batch all reads first, then all writes
    const updates = indices.map(idx => circles[idx]).filter(Boolean);
    
    // Batch remove classes
    updates.forEach(circle => {
      circle.classList.remove(...removeClasses, 'red');
    });
    
    // Batch add classes
    if (colorClass) {
      updates.forEach(circle => {
        circle.classList.add(colorClass);
      });
    }
  }
}

// Fast fill function for simple patterns (all dots, rectangular areas)
function fastFillPattern(grid, gridSize, pattern, colorClass) {
  const circles = Array.from(grid.querySelectorAll('.circle'));
  if (!circles || circles.length === 0) return;
  
  let indicesToFill = [];
  
  switch(pattern.type) {
    case 'all':
      // Fill all circles
      indicesToFill = circles.map((_, i) => i);
      break;
    case 'rect':
      // Fill rectangular area
      const { startRow, endRow, startCol, endCol } = pattern;
      for (let row = startRow; row <= endRow && row < gridSize; row++) {
        for (let col = startCol; col <= endCol && col < gridSize; col++) {
          indicesToFill.push(row * gridSize + col);
        }
      }
      break;
    case 'bottom':
      // Fill from bottom up
      const count = pattern.count || circles.length;
      for (let row = gridSize - 1; row >= 0 && indicesToFill.length < count; row--) {
        for (let col = 0; col < gridSize && indicesToFill.length < count; col++) {
          indicesToFill.push(row * gridSize + col);
        }
      }
      indicesToFill = indicesToFill.slice(0, count);
      break;
    case 'top':
      // Fill from top down
      const topCount = pattern.count || circles.length;
      for (let row = 0; row < gridSize && indicesToFill.length < topCount; row++) {
        for (let col = 0; col < gridSize && indicesToFill.length < topCount; col++) {
          indicesToFill.push(row * gridSize + col);
        }
      }
      indicesToFill = indicesToFill.slice(0, topCount);
      break;
    case 'indices':
      // Use provided indices
      indicesToFill = pattern.indices || [];
      break;
  }
  
  batchUpdateCircles(circles, indicesToFill, colorClass);
}

// Generate number words up to 625
const basic = {
  en: ["zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"],
  zh: ["零","一","二","三","四","五","六","七","八","九","十","十一","十二","十三","十四","十五","十六","十七","十八","十九","二十"],
  es: ["cero","uno","dos","tres","cuatro","cinco","seis","siete","ocho","nueve","diez","once","doce","trece","catorce","quince","dieciséis","diecisiete","dieciocho","diecinueve","veinte"],
  fr: ["zéro","un","deux","trois","quatre","cinq","six","sept","huit","neuf","dix","onze","douze","treize","quatorze","quinze","seize","dix-sept","dix-huit","dix-neuf","vingt"],
  hi: ["शून्य","एक","दो","तीन","चार","पांच","छह","सात","आठ","नौ","दस","ग्यारह","बारह","तेरह","चौदह","पंद्रह","सोलह","सत्रह","अठारह","उन्नीस","बीस"],
  ko: ["영","일","이","삼","사","오","육","칠","팔","구","십","십일","십이","십삼","십사","십오","십육","십칠","십팔","십구","이십"],
  vi: ["không","một","hai","ba","bốn","năm","sáu","bảy","tám","chín","mười","mười một","mười hai","mười ba","mười bốn","mười lăm","mười sáu","mười bảy","mười tám","mười chín","hai mươi"]
};

// Helper function to generate Chinese number words
function generateChineseNumber(num) {
  if (num <= 20) {
    return basic.zh[num] || num.toString();
  }
  
  if (num < 100) {
    const tens = Math.floor(num / 10);
    const ones = num % 10;
    if (tens === 1) {
      return "十" + (ones > 0 ? basic.zh[ones] : "");
    } else {
      return basic.zh[tens] + "十" + (ones > 0 ? basic.zh[ones] : "");
    }
  }
  
  if (num < 1000) {
    const hundreds = Math.floor(num / 100);
    const remainder = num % 100;
    const hundredsWord = basic.zh[hundreds] + "百";
    
    if (remainder === 0) {
      return hundredsWord;
    } else if (remainder < 10) {
      return hundredsWord + "零" + basic.zh[remainder];
    } else {
      return hundredsWord + generateChineseNumber(remainder);
    }
  }
  
  if (num < 10000) {
    const thousands = Math.floor(num / 1000);
    const remainder = num % 1000;
    const thousandsWord = basic.zh[thousands] + "千";
    
    if (remainder === 0) {
      return thousandsWord;
    } else if (remainder < 100) {
      return thousandsWord + "零" + generateChineseNumber(remainder);
    } else {
      return thousandsWord + generateChineseNumber(remainder);
    }
  }
  
  // For numbers >= 10000, use simple format
  return num.toString();
}

// Helper function to generate Vietnamese number words
function generateVietnameseNumber(num) {
  if (num <= 20) {
    return basic.vi[num] || num.toString();
  }
  
  if (num < 100) {
    const tens = Math.floor(num / 10);
    const ones = num % 10;
    let tensWord;
    
    if (tens === 2) {
      tensWord = "hai mươi";
    } else if (tens === 3) {
      tensWord = "ba mươi";
    } else if (tens === 4) {
      tensWord = "bốn mươi";
    } else if (tens === 5) {
      tensWord = "năm mươi";
    } else if (tens === 6) {
      tensWord = "sáu mươi";
    } else if (tens === 7) {
      tensWord = "bảy mươi";
    } else if (tens === 8) {
      tensWord = "tám mươi";
    } else if (tens === 9) {
      tensWord = "chín mươi";
    } else {
      tensWord = basic.vi[tens] + " mươi";
    }
    
    if (ones === 0) {
      return tensWord;
    } else if (ones === 1) {
      return tensWord + " mốt";
    } else if (ones === 5) {
      return tensWord + " lăm";
    } else {
      return tensWord + " " + basic.vi[ones];
    }
  }
  
  if (num < 1000) {
    const hundreds = Math.floor(num / 100);
    const remainder = num % 100;
    const hundredsWord = hundreds === 1 ? "một trăm" : (basic.vi[hundreds] + " trăm");
    
    if (remainder === 0) {
      return hundredsWord;
    } else if (remainder < 10) {
      return hundredsWord + " lẻ " + basic.vi[remainder];
    } else {
      return hundredsWord + " " + generateVietnameseNumber(remainder);
    }
  }
  
  // For numbers >= 1000, generate proper Vietnamese words
  if (num < 10000) {
    const thousands = Math.floor(num / 1000);
    const remainder = num % 1000;
    const thousandsWord = thousands === 1 ? "một nghìn" : (generateVietnameseNumber(thousands) + " nghìn");
    
    if (remainder === 0) {
      return thousandsWord;
    } else if (remainder < 100) {
      return thousandsWord + " lẻ " + generateVietnameseNumber(remainder);
    } else {
      return thousandsWord + " " + generateVietnameseNumber(remainder);
    }
  }
  
  // Handle 10000 specifically
  if (num === 10000) {
    return "mười nghìn";
  }
  
  // For very large numbers, use simple format but keep as Vietnamese text
  return num.toString();
}

function generateNumberWords(max) {
  const words = { en: [], zh: [], es: [], fr: [], hi: [], ko: [], vi: [] };
  
  for (let i = 0; i <= max && i <= 20; i++) {
    Object.keys(words).forEach(lang => {
      words[lang].push(basic[lang][i] || i.toString());
    });
  }
  
  // For numbers > 20, generate proper words
  for (let i = 21; i <= max; i++) {
    words.en.push(i.toString());
    words.zh.push(generateChineseNumber(i));
    words.es.push(i.toString());
    words.fr.push(i.toString());
    words.hi.push(i.toString());
    words.ko.push(i.toString());
    
    // Generate Vietnamese number words properly
    words.vi.push(generateVietnameseNumber(i));
  }
  
  return words;
}

// Helper function to generate Vietnamese number words
// Generate up to 9801 to support all grids including 99×99
const NUMBER_WORDS = generateNumberWords(10000);
const LANGUAGE_HINTS = {
  en: "English",
  zh: "zh-CN",
  es: "es",
  fr: "fr",
  hi: "hi",
  ko: "ko-KR",
  vi: "vi-VN"
};
let currentLang = "en";
let preferredVoice = null;
let englishVoice = null;
const dualLang = new Set();
let lastSpokenCount = 0;

function pickVoice(langCode) {
  if (!("speechSynthesis" in window)) return null;
  const voices = window.speechSynthesis.getVoices();
  if (!voices.length) return null;

  const hint = LANGUAGE_HINTS[langCode] || langCode;
  const langGroup = voices.filter(v => v.lang && v.lang.startsWith(hint));
  
  if (langCode === "vi") {
    // PRIORITY 1: Google Vietnamese voices (exclude American-sounding)
    const googleVi = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      const isGoogle = name.includes("google") && (name.includes("vietnamese") || name.includes("vi-") || name.includes("vi-vn"));
      const notAmerican = !name.includes("us") && !name.includes("en") && !name.includes("english") && !name.includes("united states");
      return isGoogle && notAmerican;
    });
    if (googleVi.length) {
      const femaleGoogle = googleVi.find(v => {
        const name = v.name.toLowerCase();
        return name.includes("female") || name.includes("f") || name.includes("nữ") || name.includes("woman") || (v.gender && v.gender.toLowerCase() === "female");
      });
      if (femaleGoogle) return femaleGoogle;
      return googleVi[0];
    }
    
    // PRIORITY 2: Microsoft Vietnamese voices (exclude American-sounding)
    const msVi = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      const isMs = name.includes("microsoft") && (name.includes("vietnamese") || name.includes("vi-") || name.includes("vi-vn"));
      const notAmerican = !name.includes("us") && !name.includes("en") && !name.includes("english") && !name.includes("united states");
      return isMs && notAmerican;
    });
    if (msVi.length) {
      const femaleMs = msVi.find(v => {
        const name = v.name.toLowerCase();
        return name.includes("female") || name.includes("f") || name.includes("nữ") || name.includes("woman") || (v.gender && v.gender.toLowerCase() === "female");
      });
      if (femaleMs) return femaleMs;
      return msVi[0];
    }
    
    // PRIORITY 3: Any Vietnamese voice that doesn't sound American
    const nonAmericanVi = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return !name.includes("us") && !name.includes("en") && !name.includes("english") && !name.includes("united states");
    });
    if (nonAmericanVi.length) return nonAmericanVi[0];
    
    // Fallback: any Vietnamese voice
    if (langGroup.length) return langGroup[0];
  }
  
  if (langCode === "en") {
    // PRIORITY 1: Female natural/neural American voices
    const femaleNaturalEn = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      const isFemale = name.includes("female") || name.includes("f") || name.includes("woman") || name.includes("zira") || name.includes("aria") || name.includes("susan") || name.includes("hazel") || name.includes("linda") || name.includes("karen") || name.includes("samantha") || (v.gender && v.gender.toLowerCase() === "female");
      const isNatural = name.includes("neural") || name.includes("natural") || name.includes("premium") || name.includes("enhanced") || name.includes("online") || name.includes("aria");
      const isAmerican = name.includes("us") || name.includes("united states") || name.includes("america");
      return isFemale && isNatural && isAmerican;
    });
    if (femaleNaturalEn.length) return femaleNaturalEn[0];
    
    // PRIORITY 2: High-quality female American voices
    const qualityFemaleEn = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return ((name.includes("aria") && name.includes("online")) || 
              (name.includes("google") && name.includes("female")) || 
              name.includes("zira") || name.includes("susan") || 
              name.includes("hazel") || name.includes("linda") || 
              name.includes("karen") || name.includes("samantha")) &&
             (name.includes("us") || name.includes("united states") || name.includes("america"));
    });
    if (qualityFemaleEn.length) return qualityFemaleEn[0];
    
    // PRIORITY 3: Any female American voice
    const femaleEn = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return (name.includes("female") || name.includes("f") || 
              name.includes("woman") || name.includes("zira") || 
              name.includes("aria") || name.includes("susan") || 
              name.includes("hazel") || name.includes("linda") ||
              name.includes("karen") || name.includes("samantha") ||
              (v.gender && v.gender.toLowerCase() === "female")) &&
             (name.includes("us") || name.includes("united states") || name.includes("america"));
    });
    if (femaleEn.length) return femaleEn[0];
    
    // Fallback: American English voices
    const americanEn = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return name.includes("us") || name.includes("united states") || name.includes("america");
    });
    if (americanEn.length) return americanEn[0];
    
    // Fallback: any English voice
    if (langGroup.length) return langGroup[0];
  }
  
  if (langCode === "zh") {
    // PRIORITY 1: Female Natural/Neural Chinese voices
    const femaleNaturalZh = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      const isFemale = name.includes("female") || name.includes("f") || 
                      name.includes("woman") || name.includes("huihui") ||
                      name.includes("yaoyao") ||
                      (v.gender && v.gender.toLowerCase() === "female");
      const isNatural = name.includes("neural") || name.includes("natural") || 
                       name.includes("premium") || name.includes("enhanced");
      return isFemale && isNatural;
    });
    if (femaleNaturalZh.length) return femaleNaturalZh[0];
    
    // PRIORITY 2: Any Natural/Neural Chinese voices
    const naturalZh = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return name.includes("neural") || name.includes("natural") || 
             name.includes("premium") || name.includes("enhanced");
    });
    if (naturalZh.length) {
      const femaleNatural = naturalZh.find(v => {
        const name = v.name.toLowerCase();
        return name.includes("female") || name.includes("f") || 
               name.includes("woman") || name.includes("huihui") ||
               name.includes("yaoyao") ||
               (v.gender && v.gender.toLowerCase() === "female");
      });
      if (femaleNatural) return femaleNatural;
      return naturalZh[0];
    }
    
    // PRIORITY 3: Female Chinese voices
    const femaleZh = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return name.includes("female") || name.includes("f") || 
             name.includes("woman") || name.includes("huihui") ||
             name.includes("yaoyao") ||
             (v.gender && v.gender.toLowerCase() === "female");
    });
    if (femaleZh.length) return femaleZh[0];
    
    // PRIORITY 4: Google Chinese voices
    const googleZh = langGroup.filter(v => 
      v.name.toLowerCase().includes("google")
    );
    if (googleZh.length) return googleZh[0];
    
    // Fallback: any Chinese voice
    if (langGroup.length) return langGroup[0];
  }
  
  if (langCode === "fr") {
    // PRIORITY 1: Female Natural/Neural French voices
    const femaleNaturalFr = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      const isFemale = name.includes("female") || name.includes("f") || 
                      name.includes("woman") || name.includes("denise") ||
                      name.includes("hélène") ||
                      (v.gender && v.gender.toLowerCase() === "female");
      const isNatural = name.includes("neural") || name.includes("natural") || 
                       name.includes("premium") || name.includes("enhanced");
      return isFemale && isNatural;
    });
    if (femaleNaturalFr.length) return femaleNaturalFr[0];
    
    // PRIORITY 2: Any Natural/Neural French voices
    const naturalFr = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return name.includes("neural") || name.includes("natural") || 
             name.includes("premium") || name.includes("enhanced");
    });
    if (naturalFr.length) {
      const femaleNatural = naturalFr.find(v => {
        const name = v.name.toLowerCase();
        return name.includes("female") || name.includes("f") || 
               name.includes("woman") || name.includes("denise") ||
               name.includes("hélène") ||
               (v.gender && v.gender.toLowerCase() === "female");
      });
      if (femaleNatural) return femaleNatural;
      return naturalFr[0];
    }
    
    // PRIORITY 3: Female French voices
    const femaleFr = langGroup.filter(v => {
      const name = v.name.toLowerCase();
      return name.includes("female") || name.includes("f") || 
             name.includes("woman") || name.includes("denise") ||
             name.includes("hélène") ||
             (v.gender && v.gender.toLowerCase() === "female");
    });
    if (femaleFr.length) return femaleFr[0];
    
    // PRIORITY 4: Google French voices
    const googleFr = langGroup.filter(v => 
      v.name.toLowerCase().includes("google")
    );
    if (googleFr.length) return googleFr[0];
    
    // Fallback: any French voice
    if (langGroup.length) return langGroup[0];
  }
  
  // For other languages, use first available voice
  if (langGroup.length) return langGroup[0];
  
  // Fallback for English
  const fallbacks = [
    "Microsoft Aria Online (Natural) - English (United States)",
    "Google US English",
    "Google UK English Female",
    "Microsoft Zira Desktop - English (United States)"
  ];
  for (const name of fallbacks) {
    const voice = voices.find(v => v.name === name);
    if (voice) return voice;
  }
  return voices.find(v => v.lang && v.lang.startsWith("en")) || voices[0];
}

function initVoices(lang = currentLang) {
  preferredVoice = pickVoice(lang);
  englishVoice = pickVoice("en");
}

if ("speechSynthesis" in window) {
  window.speechSynthesis.onvoiceschanged = initVoices;
  initVoices();
}

// Sound toggle state
let soundEnabled = true;

function speakNumber(count) {
  // Don't speak if sound is disabled
  if (!soundEnabled) return;
  
  const words = NUMBER_WORDS[currentLang] || NUMBER_WORDS.en;
  if (count < 0 || count >= words.length) return;
  if (!("speechSynthesis" in window)) return;
  
  // Ensure voices are initialized
  if (!preferredVoice) {
    initVoices();
  }
  
  lastSpokenCount = count;
  
  // Don't re-initialize voice - keep the same one for consistency
  // Only initialize if we don't have one yet
  if (!preferredVoice) {
    preferredVoice = pickVoice(currentLang);
  }
  
  // Cancel any ongoing speech
  window.speechSynthesis.cancel();
  
  // On mobile, ensure speech synthesis is ready
  if (window.speechSynthesis.pending) {
    window.speechSynthesis.cancel();
  }
  if (window.speechSynthesis.speaking) {
    window.speechSynthesis.cancel();
  }
  if (window.speechSynthesis.paused) {
    window.speechSynthesis.resume();
  }
  
  const utterance = new SpeechSynthesisUtterance(words[count]);
  utterance.rate = 1.0; // Slightly slower for mobile compatibility
  utterance.pitch = 1.0;
  utterance.volume = 1.0; // Full volume
  utterance.lang = LANGUAGE_HINTS[currentLang] || "en-US";
  
  // Always use the same preferred voice (female voice) - don't re-initialize to keep it consistent
  if (preferredVoice) {
    try {
      utterance.voice = preferredVoice;
    } catch (e) {
      // Voice might not be available, but don't re-initialize - keep same voice
      console.log('Voice not available, using default');
    }
  }
  
  // Error handling
  utterance.onerror = (e) => {
    console.log('Speech synthesis error:', e);
  };
  
  const isDual = dualLang.has(currentLang);
  const isEnglish = currentLang === 'en';
  
  // Set up onend handler before speaking
  if (isDual && !isEnglish) {
    // Dual mode: native first, then English
    utterance.onend = () => {
      const englishWord = NUMBER_WORDS.en[count];
      const follow = new SpeechSynthesisUtterance(englishWord);
      follow.rate = 1.0;
      follow.pitch = 1.0;
      follow.volume = 1.0;
      follow.lang = "en-US";
      try {
        if (englishVoice) follow.voice = englishVoice;
      } catch (e) {
        // Continue without voice
      }
      window.speechSynthesis.speak(follow);
    };
  }
  
  // Speak directly (no requestAnimationFrame for better mobile compatibility)
  try {
    window.speechSynthesis.speak(utterance);
  } catch (e) {
    console.log('Speech synthesis speak error:', e);
  }
}

function setupGroup(selector, palette) {
  const circles = Array.from(document.querySelectorAll(selector));
  const section = circles[0].closest('.set');
  const answerDisplay = section ? section.querySelector('.answer-display') : null;
  let clickCount = 0;

  function refreshColors() {
    circles.forEach(circle => circle.classList.remove(...COLOR_CLASSES));
    const active = circles.filter(circle => circle.classList.contains("red"));
    const color = palette[active.length];

    if (color) {
      active.forEach(circle => circle.classList.add(color));
    }
    return active.length;
  }

  circles.forEach(circle => {
    circle.addEventListener("click", () => {
      const wasActive = circle.classList.contains("red");
      circle.classList.toggle("red");
      const count = refreshColors();
      speakNumber(count);
      
      if (answerDisplay && count > 0 && !wasActive) {
        clickCount++;
        // Check if all dots are filled (count equals the total number of dots in this section)
        const section = circles[0].closest('.set');
        const totalDots = circles.length;
        const squareValue = section && section.dataset.square ? parseInt(section.dataset.square) : null;
        // Only show answer if at least one click has occurred and all dots are filled
        // CRITICAL: Never show answer display unless user has clicked
        if (clickCount > 0 && count >= totalDots && answerDisplay) {
          // Append to section only when showing
          if (!answerDisplay.parentNode) {
            section.appendChild(answerDisplay);
          }
          if (squareValue === 2500) {
            // For 2500, show answer only after second click and all dots filled
            if (clickCount >= 2) {
              const answer = answerDisplay.dataset.answer;
              answerDisplay.dataset.allowShow = 'true';
              answerDisplay.classList.add('show');
              answerDisplay.textContent = answer;
            }
          } else {
            // For all other squares, show answer when all dots are filled
            answerDisplay.dataset.allowShow = 'true';
            answerDisplay.classList.add('show');
            const answer = answerDisplay.dataset.answer;
            answerDisplay.textContent = answer;
          }
        }
      } else if (answerDisplay && count === 0) {
        clickCount = 0;
        answerDisplay.textContent = '';
        answerDisplay.classList.remove('show');
        // Remove from DOM when hiding
        if (answerDisplay.parentNode) {
          answerDisplay.parentNode.removeChild(answerDisplay);
        }
      }
    });
  });
}

// NUMBER 1 – single circle with voice feedback
const single = document.getElementById("one");
const section1 = single.closest('.set');
const answerDisplay1 = section1.querySelector('.answer-display');
single.addEventListener("click", function() {
  this.classList.toggle("red");
  const count = this.classList.contains("red") ? 1 : 0;
  speakNumber(count);
  
  if (count > 0) {
    // All dots are filled (1 dot), show the answer
    answerDisplay1.textContent = '1';
    answerDisplay1.classList.add('show');
  } else {
    answerDisplay1.textContent = '';
    answerDisplay1.classList.remove('show');
  }
});

// Language controls
const buttons = Array.from(document.querySelectorAll(".controls button[data-lang]"));
const dualButtons = Array.from(document.querySelectorAll(".controls button[data-dual]"));

function selectLanguage(lang, useDual, silent = false) {
  const isNewSelection = currentLang !== lang || useDual !== dualLang.has(lang);
  currentLang = lang;
  initVoices(lang);
  dualLang.clear();
  if (useDual && lang !== "en") {
    dualLang.add(lang);
  }
  
  // Save language selection to localStorage
  try {
    localStorage.setItem('selectedLanguage', lang);
    localStorage.setItem('useDualLanguage', useDual ? 'true' : 'false');
  } catch (e) {
    // Ignore localStorage errors
  }
  
  // Turn off sound button when selecting a language
  const soundToggle = document.querySelector('.controls button[data-mode="sound"]');
  if (soundToggle) {
    soundToggle.classList.remove("active");
    // If sound was disabled, re-enable it when selecting a language
    if (!soundEnabled) {
      soundEnabled = true;
      soundToggle.textContent = "Sound";
      soundToggle.classList.add("dual");
    }
  }
  
  // Turn off all language buttons first
  buttons.forEach(btn => {
    btn.classList.remove("active");
  });
  dualButtons.forEach(btn => {
    btn.classList.remove("active");
  });
  
  // Then turn on only the selected language button
  buttons.forEach(btn => {
    const active = btn.dataset.lang === lang && !useDual;
    btn.classList.toggle("active", active);
  });

  dualButtons.forEach(btn => {
    const active = btn.dataset.dual === lang && useDual;
    btn.classList.toggle("active", active);
  });

  if (!silent && isNewSelection) {
    speakNumber(lastSpokenCount);
  }
}

buttons.forEach(btn => {
  btn.addEventListener("click", () => {
    selectLanguage(btn.dataset.lang, false);
  });
});

dualButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    selectLanguage(btn.dataset.dual, true);
  });
});

// Load saved language from localStorage
try {
  const savedLang = localStorage.getItem('selectedLanguage');
  const savedDual = localStorage.getItem('useDualLanguage') === 'true';
  if (savedLang && NUMBER_WORDS[savedLang]) {
    selectLanguage(savedLang, savedDual, true);
  } else {
    selectLanguage("en", false, true);
  }
} catch (e) {
  selectLanguage("en", false, true);
}

// On mobile, ensure speech synthesis works after user interaction
// Some mobile browsers require user interaction before allowing speech
if ("speechSynthesis" in window) {
  // Try to initialize voices immediately on any user interaction
  document.addEventListener('click', function initSpeechOnInteraction() {
    initVoices();
    // Remove listener after first interaction
    document.removeEventListener('click', initSpeechOnInteraction);
  }, { once: true });
  
  document.addEventListener('touchstart', function initSpeechOnTouch() {
    initVoices();
    document.removeEventListener('touchstart', initSpeechOnTouch);
  }, { once: true });
}

// Sound toggle button
const soundToggle = document.querySelector('.controls button[data-mode="sound"]');
if (soundToggle) {
  soundToggle.addEventListener("click", () => {
    if (soundEnabled) {
      // Disable sound and say "no sound"
      soundEnabled = false;
      soundToggle.textContent = "No Sound";
      soundToggle.classList.add("active");
      soundToggle.classList.remove("dual"); // Remove dual class to match font size
      
      // Turn off ALL language buttons
      buttons.forEach(btn => {
        btn.classList.remove("active");
      });
      dualButtons.forEach(btn => {
        btn.classList.remove("active");
      });
      
      // Say "no sound" or "no voice" before disabling
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance("no sound");
        utterance.rate = 1.15;
        utterance.pitch = 1;
        utterance.volume = 0.5;
        if (preferredVoice) utterance.voice = preferredVoice;
        window.speechSynthesis.speak(utterance);
      }
    } else {
      // Enable sound
      soundEnabled = true;
      soundToggle.textContent = "Sound";
      soundToggle.classList.remove("active");
      soundToggle.classList.add("dual"); // Restore dual class
      
      // Turn on English button (default)
      const englishButton = document.querySelector('.controls button[data-lang="en"]');
      if (englishButton) {
        englishButton.classList.add("active");
      }
    }
  });
}

// Square 4 (2²): One click fills all 4 dots green
const fourGrid = document.getElementById("four");
const fourCircles = Array.from(document.querySelectorAll("#four .circle"));
const section4 = fourCircles[0].closest('.set');
const answerDisplay4 = section4.querySelector('.answer-display');
let fourClickCount = 0;
fourGrid.addEventListener("click", () => {
  if (fourClickCount === 0) {
    // First click: fill all 4 dots green
    fourCircles.forEach(c => {
      c.classList.remove(...COLOR_CLASSES);
      c.classList.add("green");
    });
    fourClickCount = 1;
    speakNumber(4);
    if (answerDisplay4) {
      answerDisplay4.textContent = '4';
      answerDisplay4.classList.add('show');
    }
  } else {
    // Reset
    fourCircles.forEach(c => {
      c.classList.remove("green", ...COLOR_CLASSES);
    });
    fourClickCount = 0;
    if (answerDisplay4) {
      answerDisplay4.textContent = '';
      answerDisplay4.classList.remove('show');
    }
    speakNumber(0);
  }
});

// Square 9 (3²): One click fills all 9 dots sky blue
const nineGrid = document.getElementById("nine");
const nineCircles = Array.from(document.querySelectorAll("#nine .circle"));
const section9 = nineCircles[0].closest('.set');
const answerDisplay9 = section9.querySelector('.answer-display');
let nineClickCount = 0;
nineGrid.addEventListener("click", () => {
  if (nineClickCount === 0) {
    // First click: fill all 9 dots sky blue
    nineCircles.forEach(c => {
      c.classList.remove(...COLOR_CLASSES);
      c.classList.add("sky");
    });
    nineClickCount = 1;
    speakNumber(9);
    if (answerDisplay9) {
      answerDisplay9.textContent = '9';
      answerDisplay9.classList.add('show');
    }
  } else {
    // Reset
    nineCircles.forEach(c => {
      c.classList.remove("sky", ...COLOR_CLASSES);
    });
    nineClickCount = 0;
    if (answerDisplay9) {
      answerDisplay9.textContent = '';
      answerDisplay9.classList.remove('show');
    }
    speakNumber(0);
  }
});

// Helper function to get top right corner indices for a grid
function getTopRightCornerIndices(gridSize, count) {
  // Top right corner: top row, rightmost positions
  // For a grid of size n, top row indices are: 0, 1, 2, ..., n-1
  // We want the rightmost 'count' positions: n-1, n-2, ..., n-count
  const indices = [];
  for (let i = 0; i < count && i < gridSize; i++) {
    indices.push(gridSize - 1 - i); // Top row, from right to left
  }
  return indices.sort((a, b) => a - b); // Sort ascending for easier use
}

// Helper to get triangle pattern (3, 2, 1) in top right corner for 6 dots
function getTrianglePatternIndices(gridSize) {
  // Triangle pattern in top-right corner:
  // 3 dots in first row, 2 dots in second row, 1 dot in third row
  // All touching the right side
  // For 4x4: row 0 has cols 1,2,3; row 1 has cols 2,3; row 2 has col 3
  // Indices: [1, 2, 3, 6, 7, 11]
  const indices = [];
  
  // Row 0 (first row): 3 dots - cols gridSize-3, gridSize-2, gridSize-1
  if (gridSize >= 3) {
    indices.push(0 * gridSize + (gridSize - 3));
    indices.push(0 * gridSize + (gridSize - 2));
    indices.push(0 * gridSize + (gridSize - 1));
  }
  
  // Row 1 (second row): 2 dots - cols gridSize-2, gridSize-1
  if (gridSize >= 2) {
    indices.push(1 * gridSize + (gridSize - 2));
    indices.push(1 * gridSize + (gridSize - 1));
  }
  
  // Row 2 (third row): 1 dot - col gridSize-1
  indices.push(2 * gridSize + (gridSize - 1));
  
  return indices;
}

// Helper to get 2x2 square in top right corner
function get2x2TopRightIndices(gridSize) {
  // 2x2 square in top right: rows 0-1, cols gridSize-2 to gridSize-1
  const indices = [];
  for (let row = 0; row < 2 && row < gridSize; row++) {
    for (let col = gridSize - 2; col < gridSize; col++) {
      indices.push(row * gridSize + col);
    }
  }
  return indices;
}

// Helper to get 3x3 square in top right corner
function get3x3TopRightIndices(gridSize) {
  // 3x3 square in top right: rows 0-2, cols gridSize-3 to gridSize-1
  const indices = [];
  for (let row = 0; row < 3 && row < gridSize; row++) {
    for (let col = gridSize - 3; col < gridSize; col++) {
      indices.push(row * gridSize + col);
    }
  }
  return indices;
}

// Helper to get 5 dots pattern (2 in top row, 3 in row below)
function get5DiagonalPatternIndices(gridSize) {
  // 5 dots: 2 dots in top row, 3 dots in row below, all in top-right corner
  // For 5x5: row 0 has cols 3,4; row 1 has cols 2,3,4
  // Indices: [3, 4, 7, 8, 9]
  const indices = [];
  
  // Row 0 (top row): 2 dots - cols gridSize-2, gridSize-1
  if (gridSize >= 2) {
    indices.push(0 * gridSize + (gridSize - 2));
    indices.push(0 * gridSize + (gridSize - 1));
  }
  
  // Row 1 (row below): 3 dots - cols gridSize-3, gridSize-2, gridSize-1
  if (gridSize >= 3) {
    indices.push(1 * gridSize + (gridSize - 3));
    indices.push(1 * gridSize + (gridSize - 2));
    indices.push(1 * gridSize + (gridSize - 1));
  }
  
  return indices;
}

// Helper function to get dot number from index for square 1225
// Pattern: Row 0 goes right to left, Row 1+ goes left to right
function getDotNumberFromIndex1225(idx, gridSize) {
  const row = Math.floor(idx / gridSize);
  const col = idx % gridSize;
  if (row === 0) {
    // First row: number from right to left
    return gridSize - col;
  } else {
    // Subsequent rows: number left to right
    return gridSize + (row - 1) * gridSize + col + 1;
  }
}

// Generic helper function for squares 36×36 through 50×50
// Pattern: Every row goes right to left (zigzag pattern)
function getDotNumberFromIndex36to50(idx, gridSize) {
  const row = Math.floor(idx / gridSize);
  const col = idx % gridSize;
  // Every row goes right to left
  return row * gridSize + (gridSize - col);
}

// Helper function to break down a number into components
function breakDownNumber(num) {
  const str = num.toString();
  const components = [];
  
  if (str.length === 2) {
    // Two-digit: tens and ones
    const tens = parseInt(str[0]) * 10;
    const ones = parseInt(str[1]);
    components.push(tens, ones);
  } else if (str.length === 3) {
    // Three-digit: hundreds, tens, ones
    const hundreds = parseInt(str[0]) * 100;
    const tens = parseInt(str[1]) * 10;
    const ones = parseInt(str[2]);
    components.push(hundreds, tens, ones);
  } else if (str.length === 4) {
    // Four-digit: thousands, hundreds, tens, ones
    // But for squares 31×31 to 50×50, we want to break down based on the pattern
    // Example: 1024 = 1000 + 20 + 4, not 1000 + 0 + 24
    const thousands = parseInt(str[0]) * 1000;
    const remainder = parseInt(str.substring(1));
    if (remainder < 100) {
      // If remainder is 2-digit, treat as tens and ones
      const tens = Math.floor(remainder / 10) * 10;
      const ones = remainder % 10;
      components.push(thousands, tens, ones);
    } else {
      // If remainder is 3-digit, treat as hundreds, tens, ones
      const hundreds = Math.floor(remainder / 100) * 100;
      const tens = Math.floor((remainder % 100) / 10) * 10;
      const ones = remainder % 10;
      components.push(thousands, hundreds, tens, ones);
    }
  }
  
  return components;
}

// Color mapping for different numbers
const COLOR_MAP = {
  1: "red", 2: "orange", 3: "yellow", 4: "green", 5: "blue",
  6: "purple", 7: "brown", 8: "pink", 9: "sky", 10: "red-final"
};

// NUMBER 16 – two clicks: first 10 red, then 6 purple (triangle in top-right)
let sixteenClickCount = 0;
const sixteenCircles = Array.from(document.querySelectorAll("#sixteen .circle"));
const section16 = sixteenCircles[0].closest('.set');
const answerDisplay16 = section16.querySelector('.answer-display');
let clickCount16 = 0;
const gridSize16 = 4;
const topRightIndices16 = getTrianglePatternIndices(gridSize16); // 6 dots as triangle

sixteenCircles.forEach(circle => {
  circle.addEventListener("click", () => {
    if (sixteenClickCount === 0) {
      // Fill 10 red dots, excluding the top-right triangle area
      const alreadyFilled = new Set();
      sixteenCircles.forEach((c, i) => {
        if (c.classList.contains("red") || c.classList.contains("purple") || 
            c.classList.contains("orange") || c.classList.contains("yellow") ||
            c.classList.contains("green") || c.classList.contains("blue") ||
            c.classList.contains("brown") || c.classList.contains("pink") ||
            c.classList.contains("sky") || c.classList.contains("red-final")) {
          alreadyFilled.add(i);
        }
      });
      
      // Fill from bottom-left, excluding top-right triangle
      // Collect all available indices first, then take 10
      const allIndices = [];
      for (let row = gridSize16 - 1; row >= 0; row--) {
        for (let col = 0; col < gridSize16; col++) {
          const idx = row * gridSize16 + col;
          if (!topRightIndices16.includes(idx) && !alreadyFilled.has(idx)) {
            allIndices.push(idx);
          }
        }
      }
      const indicesToFill = allIndices.slice(0, 10);
      
      indicesToFill.forEach(i => {
        const c = sixteenCircles[i];
        c.classList.remove(...COLOR_CLASSES);
        c.classList.add("red");
      });
      sixteenClickCount = 1;
      speakNumber(10);
    } else if (sixteenClickCount === 1) {
      // Fill 6 purple dots in triangle pattern in top-right
      topRightIndices16.forEach(i => {
        const c = sixteenCircles[i];
        c.classList.remove(...COLOR_CLASSES);
        c.classList.add("purple");
      });
      sixteenClickCount = 2;
      speakNumber(16);
      // All dots are now filled (10 red + 6 purple = 16), show the answer
      answerDisplay16.textContent = '16';
      answerDisplay16.classList.add('show');
    } else {
      sixteenCircles.forEach(c => {
        c.classList.remove("red", "purple", ...COLOR_CLASSES);
      });
      sixteenClickCount = 0;
      answerDisplay16.textContent = '';
      answerDisplay16.classList.remove('show');
      speakNumber(0);
    }
  });
});

// Generate all squares from 5^2 to 25^2
function generateSquare(n, label = null) {
  const square = n * n;
  const gridSize = n;
  
  // Create section
  const section = document.createElement('section');
  section.className = 'set';
  section.dataset.square = square;
  section.dataset.base = n;
  
  // For 39×39 (1521), add 39 rows of 39 dots above the heading (1521 dots total, fill 1000 on first click)
  if (square === 1521) {
    const dotsContainer = document.createElement('div');
    dotsContainer.style.marginBottom = '10px';
    
    const allDotsRowCircles = [];
    const dotsPerRow = 39;
    const totalRows = 39; // 38 original + 1 new row
    
    // Create all 39 rows
    for (let rowNum = 0; rowNum < totalRows; rowNum++) {
      const dotsRow = document.createElement('div');
      dotsRow.style.display = 'flex';
      dotsRow.style.gap = '0';
      dotsRow.style.marginBottom = '0';
      dotsRow.style.justifyContent = 'flex-start';
      dotsRow.dataset.rowIndex = rowNum; // Store row index for later reference
      
      for (let i = 0; i < dotsPerRow; i++) {
        const circle = document.createElement('div');
        circle.className = 'circle';
        dotsRow.appendChild(circle);
        allDotsRowCircles.push(circle);
      }
      dotsContainer.appendChild(dotsRow);
    }
    
    // Add click handler to fill 1000 dots red on first click, then 500 blue dots on second click
    let dotsRowClickCount = 0;
    dotsContainer.addEventListener('click', () => {
      if (dotsRowClickCount === 0) {
        // First click: Fill 1000 dots red from bottom-left, going left to right, row by row upward
        // Exclude the last 3 columns on the right-hand side top right to be filled in black for 7 dot
        // Group circles by row (39 dots per row), reverse row order but keep left-to-right within each row
        const dotsPerRow = 39;
        const rows = [];
        for (let i = 0; i < allDotsRowCircles.length; i += dotsPerRow) {
          rows.push(allDotsRowCircles.slice(i, i + dotsPerRow));
        }
        // Reverse rows to start from bottom, but keep left-to-right order within each row
        const reversedRows = rows.reverse();
        
        let filledCount = 0;
        // Fill dots row by row, but skip the last 3 columns (cols 36, 37, 38) in rows 0 and 1
        reversedRows.forEach((rowCircles, rowIndex) => {
          // Calculate actual row number (0 = top row, 38 = bottom row after reverse)
          const actualRow = (reversedRows.length - 1) - rowIndex;
          // Skip last 3 columns in top row (row 0) and second row (row 1)
          const isTopTwoRows = actualRow === 0 || actualRow === 1;
          const lastThreeCols = [36, 37, 38];
          
          rowCircles.forEach((circle, colIndex) => {
          if (filledCount < 1000) {
              // Skip last 3 columns in top row and second row
              if (isTopTwoRows && lastThreeCols.includes(colIndex)) {
                return; // Skip this dot, keep it black
              }
            circle.classList.remove(...COLOR_CLASSES);
            circle.classList.add('red');
            filledCount++;
          }
          });
        });
        speakNumber(1000);
        dotsRowClickCount = 1;
      } else if (dotsRowClickCount === 1) {
        // Second click: Turn blue exactly:
        // - All dots in top row (row 0) except last 3 columns
        // - All dots in rows 1-12 (12 rows × 39 = 468 dots)
        // - 14 black dots in row 13
        const dotsPerRow = 39;
        const lastThreeCols = [36, 37, 38];
        
        // Turn all dots in top row (row 0) blue except the last 3 columns
        const topRowStart = 0 * dotsPerRow;
        for (let i = 0; i < dotsPerRow; i++) {
          const circle = allDotsRowCircles[topRowStart + i];
          const colIndex = i % dotsPerRow;
          // Skip last 3 columns in top row
          if (lastThreeCols.includes(colIndex)) {
            continue; // Skip this dot, keep it black
          }
          if (!circle.classList.contains('red')) { // Only turn black dots blue
            circle.classList.remove(...COLOR_CLASSES);
            circle.classList.add('blue');
          }
        }
        
        // Turn all dots in rows 1-12 blue (these should all be black, not red)
        // But exclude the last 3 columns in rows 1, 2, 3, 4, 5, 6 (2nd, 3rd, 4th, 5th, 6th, 7th rows) to keep them black
        for (let rowIdx = 1; rowIdx <= 12; rowIdx++) {
          const rowStart = rowIdx * dotsPerRow;
          const rowEnd = rowStart + dotsPerRow;
          // Rows 1, 2, 3, 4, 5, 6 (2nd, 3rd, 4th, 5th, 6th, 7th rows) should have last 3 columns stay black
          const shouldExcludeLastThree = rowIdx >= 1 && rowIdx <= 6;
          for (let i = rowStart; i < rowEnd; i++) {
            const circle = allDotsRowCircles[i];
            const colIndex = i % dotsPerRow;
            // Skip last 3 columns in rows 1, 2, 3, 4, 5, 6
            if (shouldExcludeLastThree && lastThreeCols.includes(colIndex)) {
              continue; // Skip this dot, keep it black
            }
            if (!circle.classList.contains('red')) { // Only turn black dots blue
              circle.classList.remove(...COLOR_CLASSES);
              circle.classList.add('blue');
            }
          }
        }
        
        // Turn the 14 black dots in row 13 blue (row 13 has 25 red + 14 black)
        const row13Start = 13 * dotsPerRow;
        let blackCountInRow13 = 0;
        for (let i = row13Start; i < row13Start + dotsPerRow && blackCountInRow13 < 14; i++) {
          const circle = allDotsRowCircles[i];
          if (!circle.classList.contains('red') && !circle.classList.contains('blue')) {
            circle.classList.remove(...COLOR_CLASSES);
            circle.classList.add('blue');
            blackCountInRow13++;
          }
        }
        
        // Count actual blue dots (cumulative: 1000 red + 500 blue = 1500)
        const blueCount = allDotsRowCircles.filter(circle => circle.classList.contains('blue')).length;
        speakNumber(1500); // Cumulative: 1000 red + 500 blue
        dotsRowClickCount = 2;
      } else if (dotsRowClickCount === 2) {
        // Third click: Turn all remaining black dots orange, except the top right corner dot
        const dotsPerRow = 39;
        const topRightCornerIndex = 0 * dotsPerRow + 38; // Row 0, col 38 (top right corner)
        
        allDotsRowCircles.forEach((circle, index) => {
          // Skip the top right corner dot - keep it black
          if (index === topRightCornerIndex) {
            return;
          }
          // Turn all other black dots orange
          if (!circle.classList.contains('red') && !circle.classList.contains('blue') && !circle.classList.contains('orange')) {
            circle.classList.remove(...COLOR_CLASSES);
            circle.classList.add('orange');
          }
        });
        
        const orangeCount = allDotsRowCircles.filter(circle => circle.classList.contains('orange')).length;
        speakNumber(1520); // Cumulative: 1000 red + 500 blue + 20 orange
        dotsRowClickCount = 3;
      } else if (dotsRowClickCount === 3) {
        // Fourth click: Turn the top right corner dot red
        const dotsPerRow = 39;
        const topRightCornerIndex = 0 * dotsPerRow + 38; // Row 0, col 38 (top right corner)
        const topRightCornerCircle = allDotsRowCircles[topRightCornerIndex];
        
        if (topRightCornerCircle) {
          topRightCornerCircle.classList.remove(...COLOR_CLASSES);
          topRightCornerCircle.classList.add('red');
          speakNumber(1521); // Cumulative: 1000 red + 500 blue + 20 orange + 1 red
        }
        dotsRowClickCount = 4;
      } else {
        // Fifth click: Reset
        allDotsRowCircles.forEach(circle => {
          circle.classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange');
        });
        speakNumber(0);
        dotsRowClickCount = 0;
      }
    });
    
    section.appendChild(dotsContainer);
  }
  
  const h2 = document.createElement('h2');
  h2.textContent = label || `${n}²`;
  section.appendChild(h2);
  
  const grid = document.createElement('div');
  grid.className = `grid-dynamic`;
  grid.id = `square-${square}`;
  
  // Special handling for 13×13 (169) through 37×37 (1369) grids - CSS handles sizing
  // Add grid class for squares 6² through 12² and all larger squares
  if (square === 36 || square === 49 || square === 64 || square === 81 || square === 100 || square === 121 || square === 144 || square === 169 || square === 196 || square === 225 || square === 256 || square === 289 || square === 324 || square === 361 || square === 400 || square === 441 || square === 484 || square === 529 || square === 576 || square === 625 || square === 676 || square === 729 || square === 784 || square === 841 || square === 900 || square === 961 || square === 1024 || square === 1089 || square === 1156 || square === 1225 || square === 1296 || square === 1369) {
    grid.classList.add(`grid-${square}`);
  } else {
    // Use the standard size for all other grids (including 37×37)
  grid.style.gridTemplateColumns = `repeat(${gridSize}, var(--circle-total))`;
  grid.style.gridTemplateRows = `repeat(${gridSize}, var(--circle-total))`;
  grid.style.width = `calc(var(--circle-total) * ${gridSize})`;
  grid.style.height = `calc(var(--circle-total) * ${gridSize})`;
  }
  
  // For 256, 225, 441, 1156, and 1225, make grid position relative so we can absolutely position separated dots relative to it
  // 841 doesn't need relative positioning since dots don't move
  // 1444 (38×38) does NOT move dots - removed from this check
  // For squares that may have separated/moving dots, make grid position relative
  if (square === 256 || square === 225 || square === 441 || square === 1156 || square === 1225 || (square > 1225 && square <= 2704)) {
    grid.style.position = 'relative';
  }
  
  // For 26×26 through 29×29, make grid bigger to accommodate numbers
  // But exclude 676, 729, 784, 841 and 900 - keep them smaller
  
  // For 35×35 through 50×50, make grid bigger to accommodate numbers
  // 1156 (34×34) and 1225 (35×35) use regular size like square 33
  if (square > 1156 && square <= 2704) {
    grid.classList.add(`grid-${square}`);
  }
  
  // Create circles
  for (let i = 0; i < square; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle';
    // For grids 14×14 through 33×33, use smaller circles to fit same size as grid-169
    if (square === 196) {
      circle.classList.add('circle-196');
    } else if (square === 256) {
      circle.classList.add('circle-256');
    } else if (square === 289) {
      circle.classList.add('circle-289');
    } else if (square === 324) {
      circle.classList.add('circle-324');
    } else if (square === 361) {
      circle.classList.add('circle-361');
    } else if (square === 400) {
      circle.classList.add('circle-400');
    } else if (square === 441) {
      circle.classList.add('circle-441');
    } else if (square === 484) {
      circle.classList.add('circle-484');
    } else if (square === 529) {
      circle.classList.add('circle-529');
    } else if (square === 576) {
      circle.classList.add('circle-576');
    } else if (square === 625) {
      circle.classList.add('circle-625');
    } else if (square === 676) {
      circle.classList.add('circle-676');
    } else if (square === 729) {
      circle.classList.add('circle-729');
    } else if (square === 784) {
      circle.classList.add('circle-784');
    } else if (square === 841) {
      circle.classList.add('circle-841');
    } else if (square === 900) {
      circle.classList.add('circle-900');
    } else if (square === 961) {
      circle.classList.add('circle-961');
    } else if (square === 1024) {
      circle.classList.add('circle-1024');
    } else if (square === 1089) {
      circle.classList.add('circle-1089');
    } else if (square === 1156) {
      circle.classList.add('circle-1156');
    } else if (square === 1225) {
      circle.classList.add('circle-1225');
    } else if (square === 1296) {
      circle.classList.add('circle-1296');
    } else if (square === 1369) {
      circle.classList.add('circle-1369');
    }
    // For 26×26 through 29×29, add numbers inside each circle and make circles bigger
    // But exclude 676, 729, 784, 841 and 900 - keep them smaller
    // For 34×34 through 50×50, add numbers with special numbering:
    // Top-right 10×10 = 1-100, Top-left 10×10 = 101-200
    // For 1156, use sequential numbering 1-1156
    if (square === 1156) {
      // Add circle class for sizing (same size as square 33)
      circle.classList.add(`circle-${square}`);
      
      // Calculate row and column for this circle
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      
      let dotNumber;
      if (row === 0) {
        // First row: number from right to left (col 33 = 1, col 32 = 2, ..., col 0 = 34)
        dotNumber = gridSize - col; // col 33 → 1, col 32 → 2, ..., col 0 → 34
      } else {
        // Subsequent rows: number left to right
        // Row 1 starts at 35 (after row 0's 34 dots)
        // Row r starts at: 34 + (r - 1) * 34 + 1 + col = 34 + (r - 1) * 34 + col + 1
        dotNumber = gridSize + (row - 1) * gridSize + col + 1;
      }
      
      // Store dot number in data attribute (no visible number displayed)
      circle.dataset.dotNumber = dotNumber.toString();
    } else if (square === 1225) {
      // For 1225 (35×35), number from top-right corner going left, then down left-to-right
      // Row 0: top-right (col 34) = 1, going left to top-left (col 0) = 35
      // Row 1+: continue left-to-right (col 0 = 36, col 1 = 37, etc.)
      // Add circle class for sizing (same size as square 33)
      circle.classList.add(`circle-${square}`);
      
      // Calculate row and column for this circle
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      
      let dotNumber;
      if (row === 0) {
        // First row: number from right to left (col 34 = 1, col 33 = 2, ..., col 0 = 35)
        dotNumber = gridSize - col; // col 34 → 1, col 33 → 2, ..., col 0 → 35
      } else {
        // Subsequent rows: number left to right
        // Row 1 starts at 36 (after row 0's 35 dots)
        // Row r starts at: 35 + (r - 1) * 35 + 1 + col = 35 + (r - 1) * 35 + col + 1
        dotNumber = gridSize + (row - 1) * gridSize + col + 1;
      }
      
      // Store dot number in data attribute (no visible number displayed)
      circle.dataset.dotNumber = dotNumber.toString();
    } else if (square > 1225 && square <= 2704) {
      // For squares 36×36 (1296) through 52×52 (2704), number from top-right corner going left
      // Row 0: right to left (col gridSize-1 = 1, col gridSize-2 = 2, ..., col 0 = gridSize)
      // Row 1+: also right to left (zigzag pattern - every row goes right to left)
      // Add circle class for sizing
      circle.classList.add(`circle-${square}`);
      
      // Calculate row and column for this circle
      // Calculate row and column for this circle
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      
      let dotNumber;
      // Every row goes right to left
      // Row 0: col gridSize-1 = 1, col gridSize-2 = 2, ..., col 0 = gridSize
      // Row 1: col gridSize-1 = gridSize+1, col gridSize-2 = gridSize+2, ..., col 0 = gridSize*2
      // Row r: starts at r * gridSize + 1, goes right to left
      dotNumber = row * gridSize + (gridSize - col);
      
      // Store dot number in data attribute (used by some special patterns)
      circle.dataset.dotNumber = dotNumber.toString();
      
      // Create and add visible number span (but not for 36×36 / 1296, or 40×40 through 55×55 / 1600-3025)
      if (square !== 1296 && (square < 1600 || square > 3025)) {
        const numberSpan = document.createElement('span');
        numberSpan.className = 'circle-number';
        numberSpan.textContent = dotNumber.toString();
        circle.appendChild(numberSpan);
      }
    }
    grid.appendChild(circle);
  }
  
  // For the original 39×39 grid (1521), delete all rows (rows 0-38)
  // But skip if this is the second 39×39 grid
  if (square === 1521 && grid.id === 'square-1521' && !window._isSecond39Grid) {
    const circles = Array.from(grid.querySelectorAll('.circle'));
    // Delete all rows - remove all circles
    circles.forEach((circle) => {
      circle.remove();
    });
    // Hide the grid completely since it's empty
    grid.style.display = 'none';
  }
  
  section.appendChild(grid);
  
  // Check if answer display already exists - remove it first to prevent duplicates
  // Use try-catch to prevent errors from breaking script execution
  try {
    const existingAnswerDisplay = section.querySelector('.answer-display');
    if (existingAnswerDisplay) {
      existingAnswerDisplay.remove();
    }
  } catch (e) {
    console.error('Error checking for existing answer display:', e);
  }
  
  // Add answer display
  const answerDisplay = document.createElement('div');
  answerDisplay.className = 'answer-display';
  answerDisplay.dataset.answer = square;
  answerDisplay.textContent = ''; // Ensure it starts empty
  answerDisplay.innerHTML = ''; // Also clear innerHTML
  // Explicitly ensure it's hidden - no show class and force hidden state
  answerDisplay.classList.remove('show');
  // Use setAttribute to force hide with inline styles
  answerDisplay.setAttribute('style', 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: absolute !important; left: -9999px !important; top: -9999px !important; height: 0 !important; width: 0 !important; overflow: hidden !important; margin: 0 !important; padding: 0 !important; font-size: 0 !important; line-height: 0 !important; pointer-events: none !important; color: transparent !important; z-index: -9999 !important;');
  // Don't append to DOM at all - store reference only
  // Answer display will be created and appended only when needed (when show class is added)
  section._answerDisplay = answerDisplay;
  // Don't append anywhere - keep it completely out of the DOM
  
  // Setup click handlers
  const circles = Array.from(grid.querySelectorAll('.circle'));
  let clickCount = 0;
  // Track separated circles for 256 and 225
  const separatedCircles = [];
  let components = breakDownNumber(square);
  // Special: 900 - just one click, all 900 dots sky blue
  if (square === 900) {
    components = [900];
  }
  // Special: 1225 - 1000 red, then 200 orange, then 20 orange, then 5 blue
  if (square === 1225) {
    components = [1000, 200, 20, 5];
  }
  // Special: 1600 (40×40) - 1000 red on first click, fill from bottom-left
  if (square === 1600) {
    components = [1000, 600];
  }
  // Special: 1681 (41×41) - 1000 red on first click, 600 purple on second click, 80 pink on third click, 1 red on fourth click
  else if (square === 1681) {
    components = [1000, 600, 80, 1];
  }
  // Special: 1764 (42×42) - 1000 red on first click, 700 brown on second click, 60 purple on third click, 4 green on fourth click
  else if (square === 1764) {
    components = [1000, 700, 60, 4];
  }
  // Special: 1849 (43×43) - 1000 red on first click, 800 pink on second click, 40 green on third click, 9 sky blue on fourth click
  else if (square === 1849) {
    components = [1000, 800, 40, 9];
  }
  // Special: 1936 (44×44) - 1000 red on first click, 900 sky blue on second click, 30 yellow on third click, 6 purple on fourth click
  else if (square === 1936) {
    components = [1000, 900, 30, 6];
  }
  // Special: 2025 (45×45) - 2000 orange on first click, 20 orange on second click, 5 blue on third click
  else if (square === 2025) {
    components = [2000, 20, 5];
  }
  // Special: 2116 (46×46) - 2000 orange on first click, 100 red on second click, 10 red on third click, 6 purple on fourth click
  else if (square === 2116) {
    components = [2000, 100, 10, 6];
  }
  // Special: 2209 (47×47) - 2000 orange on first click, leaving 20×10 rectangle (200 black) and 3×3 square (9 black)
  // Then 200 orange on second click in the 20×10 rectangle (which separates and moves up)
  // Then 9 sky blue on third click to fill the 3×3 square (matching 3×3 pattern)
  else if (square === 2209) {
    components = [2000, 200, 9];
  }
  // Special: 2304 (48×48) - 2000 orange on first click, 300 yellow on second click, 4 green on third click (skip the 0 component)
  else if (square === 2304) {
    components = [2000, 300, 4];
  }
  // Special: 2401 (49×49) - 2000 orange on first click, 400 on second click, 1 red on third click (skip the 0 component)
  else if (square === 2401) {
    components = [2000, 400, 1];
  }
  // Special: 2601 (51×51) - 2000 orange on first click, 600 purple on second click, 1 red on third click
  else if (square === 2601) {
    components = [2000, 600, 1];
  }
  // Special: 2704 (52×52) - 2000 orange on first click, 700 brown on second click, 4 green on third click (skip the 0 component)
  else if (square === 2704) {
    components = [2000, 700, 4];
  }
  // REPLICA: Handle completely independently first
  const isReplica = grid.id === 'square-1296-replica';
  if (isReplica) {
    // Replica: 1000 red (first click), nothing (second click), nothing (third click), 9 sky blue (fourth click)
    components = [1000, 0, 0, 9];
  }
  // Special: 1296 - 1000 red (first click), nothing (second click), 90 sky blue (third click), 6 purple (fourth click)
  else if (square === 1296) {
    // Original: 1000 red (first click), nothing (second click), 90 sky blue (third click), 6 purple (fourth click)
    components = [1000, 0, 90, 6];
  }
  // For squares 31×31 to 50×50, map to corresponding smaller square patterns
  // Pattern: n×n maps to (60-n)×(60-n) for the last 2 digits
  // Example: 31×31 (961) maps to 19×19 (361) for the 61 pattern
  const sourceSquare = n > 30 ? (60 - n) * (60 - n) : null;
  const totalClicks = components.length;
  
  // Get top right corner indices for ones place
  const onesValue = components[components.length - 1];
  let topRightIndices = [];
  
  // Special patterns for ones place - ALL ones place numbers go in top right corner
  // 6 dots: purple triangle pattern in top-right corner (for 16, 36, 196, 256, 576)
  // 9 dots: sky blue 3x3 square in top-right corner (for 49, 169, 289, 529)
  if (onesValue === 6) {
    // Triangle pattern for 6 (1, 2, 3 diagonal) - PURPLE
    topRightIndices = getTrianglePatternIndices(gridSize);
  } else if (onesValue === 4) {
    // 2x2 square for 4 (including 324)
    topRightIndices = get2x2TopRightIndices(gridSize);
  } else if (onesValue === 9) {
    // 3x3 square for 9 - SKY BLUE
    topRightIndices = get3x3TopRightIndices(gridSize);
  } else if (onesValue === 5) {
    // For 225: 5 blue dots in a vertical line in the rightmost column of the 5×5 rectangle (col 14, rows 0-4)
    // For 25: 5 blue dots in a vertical line in the rightmost column (col 4, rows 0-4)
    // For 625: 5 blue dots are dots 21-25 (row 0, cols 20-24)
    // For other squares: 2x2 square + 1 diagonal for 5
    if (square === 225 || square === 2025) {
      // Vertical line: 5 dots in rightmost column of the 5×5, rows 0-4
      topRightIndices = [];
      const rightmostCol = square === 225 ? 14 : (gridSize - 1);
      for (let row = 0; row < 5 && row < gridSize; row++) {
        topRightIndices.push(row * gridSize + rightmostCol);
      }
    } else if (square === 25) {
      // Vertical line: 5 dots in column 4 (rightmost column), rows 0-4
      topRightIndices = [];
      for (let row = 0; row < 5 && row < gridSize; row++) {
        topRightIndices.push(row * gridSize + 4);
      }
    } else if (square === 625) {
      // Dots 25, 50, 75, 100, 125 are blue on 3rd click
      topRightIndices = [];
      for (let dot of [25, 50, 75, 100, 125]) {
        topRightIndices.push(dot - 1); // Convert to index
      }
    } else {
      topRightIndices = get5DiagonalPatternIndices(gridSize);
    }
  } else if (onesValue === 1 && square === 441) {
    // For 441: 1 red dot at top right corner (row 0, col 20), will be offset
    topRightIndices = [0 * gridSize + 20];
  } else if (onesValue === 1 && square === 841) {
    // For 841: 1 red dot at top right corner (row 0, col 28), will be offset
    topRightIndices = [0 * gridSize + 28];
  } else if (onesValue === 1 && square === 1681) {
    // For 1681: 1 red dot at top right corner (row 0, col 40)
    topRightIndices = [0 * gridSize + (gridSize - 1)]; // Top right corner
  } else {
    // Default: top row rightmost positions
    topRightIndices = getTopRightCornerIndices(gridSize, onesValue);
  }
  
  // === FIX FOR 1369, 169, 289, 529 etc.: protect the final ones-place area ===
  // This ensures the ones-place dots (especially the 9 sky-blue dots) are NEVER filled early
  const protectedOnesArea = new Set(topRightIndices);
  
  // Helper to get bottom left indices (for hundreds place)
  function getBottomLeftIndices(gridSize, count) {
    const indices = [];
    // Start from bottom row, left side
    for (let row = gridSize - 1; row >= 0 && indices.length < count; row--) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!topRightIndices.includes(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get upper left indices (for tens place when needed)
  function getUpperLeftIndices(gridSize, count) {
    const indices = [];
    // Start from top row, left side
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!topRightIndices.includes(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get indices around ones place (for tens place separation in 3-digit numbers)
  function getIndicesAroundOnes(gridSize, count, topRightIndices, alreadyFilled) {
    const indices = [];
    const topRightSet = new Set(topRightIndices);
    const filledSet = new Set(alreadyFilled);
    
    // Get positions around the top right corner, working inward
    // Start from top rows, near the right side but not in ones place
    // NEVER touch the protected ones-place area (especially the 9 sky-blue dots for 1369)
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = gridSize - 1; col >= 0 && indices.length < count; col--) {
        const idx = row * gridSize + col;
        // Exclude protected ones area AND topRightIndices AND already filled
        if (!protectedOnesArea.has(idx) && !topRightSet.has(idx) && !filledSet.has(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get upper left indices (for tens place in 2-digit numbers, or second component in 3-digit)
  function getUpperLeftIndices(gridSize, count, excludeIndices, alreadyFilled) {
    const indices = [];
    const excludeSet = new Set(excludeIndices || []);
    const filledSet = new Set(alreadyFilled || []);
    
    // Start from top row, left side
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!excludeSet.has(idx) && !filledSet.has(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Make the entire grid clickable, not just individual circles
  grid.addEventListener("click", (e) => {
    // Ignore clicks on separated circles (they have data-originalRow attribute)
    if (e.target.dataset.originalRow !== undefined) {
      return;
    }
    
    // Check if we should reset (clicking after all components are filled)
    // For 441: clickCount will be 3 after 3 clicks (0, 1, 2), so 4th click should reset
    // Also check if answer is already showing (for numbers like 100 where we show answer early)
    const answerIsShowing = answerDisplay && answerDisplay.classList.contains('show');
    const nonZeroComponentsReset = components.filter(c => c > 0);
    const processedNonZeroReset = components.slice(0, clickCount).filter(c => c > 0).length;

    // Normally, reset when clickCount reaches totalClicks.
    // For 1369, reset on the 5th click (when clickCount >= totalClicks after 4 clicks)
    const reachedMaxClicks = (clickCount >= totalClicks);

    if (reachedMaxClicks || (answerIsShowing && processedNonZeroReset >= nonZeroComponentsReset.length)) {
      // Complete reset - go back to initial state (all black dots, nothing colored, nothing hidden)
      // For 441, be extra aggressive about removing the red dot
      if (square === 441) {
        // Remove ALL red circles first (most aggressive)
        const allRed = grid.querySelectorAll('.circle.red');
        allRed.forEach(rc => {
          // Remove if it's not in the original circles array (it's a separated circle)
          if (rc && rc.parentNode && !circles.includes(rc)) {
            rc.parentNode.removeChild(rc);
          }
        });
        
        // Remove all absolutely positioned circles (separated circles)
        const allAbsolute = Array.from(grid.children).filter(child => 
          child.style && child.style.position === 'absolute' && !circles.includes(child)
        );
        allAbsolute.forEach(ac => {
          if (ac && ac.parentNode) {
            ac.parentNode.removeChild(ac);
          }
        });
      }
      
      // Remove from the array
      separatedCircles.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      separatedCircles.length = 0;
      
      // Remove ALL separated circles by data attributes (these are the ones we created)
      const allSeparated = grid.querySelectorAll('[data-original-row][data-original-col]');
      allSeparated.forEach(sc => {
        // Only remove if it's NOT in the original circles array (it's a separated circle we created)
        if (sc && sc.parentNode && !circles.includes(sc)) {
          sc.parentNode.removeChild(sc);
        }
      });
      
      // Now completely reset ALL ORIGINAL circles to initial state
      circles.forEach(c => {
        // Remove all color classes INCLUDING "red" (red is not in COLOR_CLASSES array)
        c.classList.remove('red', ...COLOR_CLASSES);
        // Reset all styles to initial state
        c.style.visibility = '';
        c.style.display = '';
        c.style.position = '';
        c.style.zIndex = '';
        c.style.left = '';
        c.style.top = '';
        c.style.opacity = '';
      });
      
      // Aggressive check for ALL squares: remove ANY remaining red circles that are children of grid
      // This ensures no red dots are left behind (like for 81, 100, 441, etc.)
      const allGridChildren = Array.from(grid.children);
      allGridChildren.forEach(child => {
        if (child.classList && child.classList.contains('red') && !circles.includes(child)) {
          if (child && child.parentNode) {
            child.parentNode.removeChild(child);
          }
        }
        // Also remove red class from any circles that might still have it
        if (child.classList && child.classList.contains('red') && circles.includes(child)) {
          child.classList.remove('red');
        }
      });
      
      // Extra check for 441: explicitly ensure row 0, col 20 is black and visible
      // Note: On second click, this dot moves with the other 41 dots, so don't reset its position here
      if (square === 441 && clickCount === 0) {
        const idx = 0 * gridSize + 20;
        if (circles[idx]) {
          // Force remove red class (only on first click/reset)
          circles[idx].classList.remove('red', ...COLOR_CLASSES);
          circles[idx].style.visibility = '';
          circles[idx].style.display = '';
          circles[idx].style.position = '';
          circles[idx].style.zIndex = '';
          circles[idx].style.left = '';
          circles[idx].style.top = '';
          circles[idx].style.opacity = '';
        }
      }
      
      // Extra check for 81 (9×9): ensure all red dots are removed
      if (square === 81) {
        circles.forEach(c => {
          c.classList.remove('red', ...COLOR_CLASSES);
        });
      }
      
      // Extra check for 100 (10×10): ensure all red dots are removed
      if (square === 100) {
        circles.forEach(c => {
          c.classList.remove('red', ...COLOR_CLASSES);
        });
      }
      
      // Reset click count and display
      clickCount = 0;
      answerDisplay.textContent = '';
      answerDisplay.classList.remove('show');
      speakNumber(0);
      return;
    }
    
    // Process clicks on the grid itself or on regular circles
    if (clickCount < totalClicks) {
        const componentValue = components[clickCount];
        const isOnesPlace = (clickCount === totalClicks - 1);
        // For place detection: first component is "hundreds" place (even if it's thousands),
        // second is "tens" place, last is "ones" place
        // This works for both 3-digit (e.g., 289 = [200, 80, 9]) and 4-digit numbers that break down to 3 components (e.g., 1089 = [1000, 80, 9])
        const isHundredsPlace = (clickCount === 0 && components.length >= 3) || (square === 1600 && clickCount === 1);
        const isTensPlace = (clickCount === 1 && components.length >= 3) || (clickCount === 0 && components.length === 2);
        
        // Initialize indicesToFill early so it can be set by special handlers
        let indicesToFill = [];
        let is1296SpecialClick = false;
        let is1369SpecialClick = false;
        
        // Track already filled indices (check for any color class) - needed by handlers
        const alreadyFilled = new Set();
        
        // Special: 1600 first click - fill 1000 dots from bottom-left
        if (square === 1600 && clickCount === 0) {
          const allIndices = [];
          for (let row = gridSize - 1; row >= 0; row--) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
                allIndices.push(idx);
            }
          }
          indicesToFill = allIndices
            .filter(i => !alreadyFilled.has(i))
            .slice(0, componentValue);
        }
        // Special: 1600 second click - fill remaining 600 dots purple from top
        // 600 is hundreds place, so handle it specially
        else if (square === 1600 && clickCount === 1) {
          // Wait for alreadyFilled to be populated first (it's populated below)
          // We'll set indicesToFill after alreadyFilled is ready
        }
        circles.forEach((c, i) => {
          if (c.classList.contains("red") || c.classList.contains("orange") || 
              c.classList.contains("yellow") || c.classList.contains("green") ||
              c.classList.contains("blue") || c.classList.contains("purple") ||
              c.classList.contains("brown") || c.classList.contains("pink") ||
              c.classList.contains("sky") || c.classList.contains("red-final")) {
            alreadyFilled.add(i);
        }
        });
        
        // Special: 1600 second click - fill remaining 600 dots purple from top
        // Do this AFTER alreadyFilled is populated, and FORCE it to override any previous setting
        if (square === 1600 && clickCount === 1) {
          console.log('1600 second click - gridSize:', gridSize, 'alreadyFilled size:', alreadyFilled.size, 'componentValue:', componentValue);
          const allIndices = [];
          // Fill from top row downward, left to right, only black dots (not red)
          // Collect ALL black dots first, then take first 600
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Check if circle is red by checking alreadyFilled (which includes red dots)
              if (!alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            if (row === 0) {
              console.log('1600 second click - after row 0, allIndices length:', allIndices.length);
            }
          }
          console.log('1600 second click - collected', allIndices.length, 'black dots, taking first', componentValue);
          // Take exactly componentValue (600) dots - FORCE override
          indicesToFill = allIndices.slice(0, componentValue);
          console.log('1600 second click - indicesToFill FORCED to', indicesToFill.length, 'indices');
          // Mark that we've handled 1600 second click to prevent any other handlers from overwriting
          window._1600SecondClickHandled = true;
          }
        // Special: 1681 second click - fill remaining 600 dots purple from top (same as 1600)
        else if (square === 1681 && clickCount === 1) {
          const allIndices = [];
          // Fill from top row downward, left to right, only black dots (not red)
          // Collect ALL black dots first, then take first 600
          // BUT: Skip the 9x9 top-right corner area (rows 0-8, cols 32-40) - that's for clicks 3 and 4
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the 9x9 top-right corner area (rows 0-8, cols 32-40)
              const isIn9x9Area = row < 9 && col >= gridSize - 9;
              if (!alreadyFilled.has(idx) && !isIn9x9Area) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (600) dots - FORCE override
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1681 third click - fill 80 pink dots in 9x9 top-right corner (like 9x9 grid's first click)
        else if (square === 1681 && clickCount === 2) {
          const allIndices = [];
          // Fill 9x9 area in top-right corner (rows 0-8, cols 32-40), but leave top-right corner (row 0, col 40) for 4th click
          for (let row = 0; row < 9; row++) {
            for (let col = gridSize - 9; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the top-right corner dot (row 0, col 40) - that's for the 4th click
              if (!(row === 0 && col === gridSize - 1) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (80) dots
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1681 fourth click - fill 1 red dot in top-right corner of 9x9 area
        else if (square === 1681 && clickCount === 3) {
          // Top-right corner of the 9x9 area: row 0, col 40 (for 41x41 grid)
          const topRightIdx = 0 * gridSize + (gridSize - 1);
          if (!alreadyFilled.has(topRightIdx)) {
            indicesToFill = [topRightIdx];
          } else {
            indicesToFill = [];
          }
        }
        // Special: 1764 second click - fill 700 brown dots, skipping 8x8 top-right corner
        else if (square === 1764 && clickCount === 1) {
          const allIndices = [];
          // Fill from top row downward, left to right, only black dots (not red)
          // Skip the 8x8 top-right corner area (rows 0-7, cols 34-41)
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the 8x8 top-right corner area
              const isIn8x8Area = row < 8 && col >= gridSize - 8;
              if (!alreadyFilled.has(idx) && !isIn8x8Area) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (700) dots
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1764 third click - fill 60 purple dots in 8x8 top-right corner (like 8x8 grid's first click)
        else if (square === 1764 && clickCount === 2) {
          const allIndices = [];
          // Fill 8x8 area in top-right corner (rows 0-7, cols 34-41), but leave 2x2 top-right (rows 0-1, cols 40-41) for 4th click
          for (let row = 0; row < 8; row++) {
            for (let col = gridSize - 8; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the 2x2 top-right corner (rows 0-1, cols 40-41) - that's for the 4th click
              const isIn2x2Corner = row < 2 && col >= gridSize - 2;
              if (!isIn2x2Corner && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (60) dots
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1764 fourth click - fill 4 green dots in 2x2 top-right corner of 8x8 area
        else if (square === 1764 && clickCount === 3) {
          // 2x2 top-right corner of the 8x8 area: rows 0-1, cols 40-41 (for 42x42 grid)
          const allIndices = [];
          for (let row = 0; row < 2; row++) {
            for (let col = gridSize - 2; col < gridSize; col++) {
              const idx = row * gridSize + col;
              if (!alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1849 second click - fill 800 pink dots, skipping 7x7 top-right corner
        else if (square === 1849 && clickCount === 1) {
          const allIndices = [];
          // Fill from top row downward, left to right, only black dots (not red)
          // Skip the 7x7 top-right corner area (rows 0-6, cols 36-42)
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the 7x7 top-right corner area
              const isIn7x7Area = row < 7 && col >= gridSize - 7;
              if (!alreadyFilled.has(idx) && !isIn7x7Area) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (800) dots
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1849 third click - fill 40 green dots in 7x7 top-right corner (like 7x7 grid's first click)
        else if (square === 1849 && clickCount === 2) {
          const allIndices = [];
          // Fill 7x7 area in top-right corner (rows 0-6, cols 36-42), but leave 3x3 top-right (rows 0-2, cols 40-42) for 4th click
          for (let row = 0; row < 7; row++) {
            for (let col = gridSize - 7; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the 3x3 top-right corner (rows 0-2, cols 40-42) - that's for the 4th click
              const isIn3x3Corner = row < 3 && col >= gridSize - 3;
              if (!isIn3x3Corner && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (40) dots
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 2025 second click - fill 20 orange dots in first 4 columns of 5×5 top-right corner (like 15×15 grid's second click)
        else if (square === 2025 && isTensPlace) {
          const allIndices = [];
          // Fill only the first 4 columns (cols 40-43) × 5 rows (rows 0-4) = 20 orange dots
          // Leave the rightmost column (col 44) black for now (will turn blue on 3rd click)
          // Position: rows 0-4, cols 40-43 (4 columns × 5 rows = 20 dots)
          for (let row = 0; row < 5 && row < gridSize && allIndices.length < componentValue; row++) {
            for (let col = gridSize - 5; col < gridSize - 1 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = row * gridSize + col;
              // Don't include topRightIndices (the 5 blue dots in col 44) or already filled
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 2025 third click - fill 5 blue dots in rightmost column of 5×5 top-right corner (like 15×15 grid's third click)
        else if (square === 2025 && isOnesPlace) {
          // Fill the rightmost column (col 44) of the 5×5 area (rows 0-4)
          const allIndices = [];
          for (let row = 0; row < 5 && row < gridSize; row++) {
            const idx = row * gridSize + (gridSize - 1); // Rightmost column
            if (!alreadyFilled.has(idx)) {
              allIndices.push(idx);
            }
          }
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 2116 second click - fill 100 red dots in 10×10 square (cols 32-41, rows 0-9), leaving 4×4 black (rows 0-3, cols 42-45)
        else if (square === 2116 && clickCount === 1) {
          const allIndices = [];
          // Fill 10×10 square: cols 32-41 (10 columns), rows 0-9 (10 rows) = 100 red dots
          // This leaves 4×4 black: rows 0-3, cols 42-45
          for (let row = 0; row < 10 && row < gridSize; row++) {
            for (let col = gridSize - 14; col < gridSize - 4 && col < gridSize; col++) {
              const idx = row * gridSize + col;
              if (!alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 2116 third click - fill 10 red dots in 4×4 area, excluding triangle pattern (like 4×4 grid's first click)
        else if (square === 2116 && clickCount === 2) {
          const allIndices = [];
          // Fill 4×4 area (rows 0-3, cols 42-45), excluding triangle pattern (6 purple dots)
          const triangleIndices = getTrianglePatternIndices(gridSize);
          for (let row = 0; row < 4 && row < gridSize; row++) {
            for (let col = gridSize - 4; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Exclude triangle pattern (6 purple dots) - that's for the 4th click
              if (!triangleIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 2116 fourth click - fill 6 purple dots in triangle pattern in separated 4×4 square
        // The 4×4 square has already moved away on the 3rd click, so we need to find the separated black circles
        else if (square === 2116 && clickCount === 3) {
          // Don't fill in the original grid - the dots are already separated
          // We'll handle this in the separation logic below
          indicesToFill = [];
        }
        // Special: 1849 fourth click - fill 9 sky blue dots in 3x3 top-right corner of 7x7 area
        else if (square === 1849 && clickCount === 3) {
          // 3x3 top-right corner of the 7x7 area: rows 0-2, cols 40-42 (for 43x43 grid)
          const topRightIndices1849 = get3x3TopRightIndices(gridSize);
          indicesToFill = topRightIndices1849.filter(i => !alreadyFilled.has(i)).slice(0, componentValue);
        }
        // Special: 2209 second click - fill orange dots in scaled rectangle
        // Original 47×47: 20×10 rectangle (rows 0-19, cols 34-43) = 200 dots
        // Scaled to 13×13: 6×3 rectangle (rows 0-5, cols 10-12) = 18 dots (proportionally scaled)
        else if (square === 2209 && clickCount === 1) {
          const allIndices = [];
          // Scaled rectangle: rows 0-5, cols 10-12 (18 orange dots for 13×13 display)
          // When gridSize is 47, use original: rows 0-19, cols 34-43
          // When gridSize is 13 (scaled display), use: rows 0-5, cols 10-12
          const rectStartRow = gridSize === 47 ? 0 : 0;
          const rectEndRow = gridSize === 47 ? 19 : 5;
          const rectStartCol = gridSize === 47 ? 34 : 10;
          const rectEndCol = gridSize === 47 ? 43 : 12;
          for (let row = rectStartRow; row <= rectEndRow && row < gridSize; row++) {
            for (let col = rectStartCol; col <= rectEndCol && col < gridSize; col++) {
              const idx = row * gridSize + col;
              if (!alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 2209 third click - fill 9 sky blue dots in 3x3 top-right corner (matching 3×3 pattern)
        else if (square === 2209 && clickCount === 2) {
          // 3x3 top-right corner: rows 0-2, cols 44-46 (for 47x47 grid)
          const topRightIndices2209 = get3x3TopRightIndices(gridSize);
          indicesToFill = topRightIndices2209.filter(i => !alreadyFilled.has(i)).slice(0, componentValue);
        }
        // Special: 1936 second click - fill 900 sky blue dots, skipping 6x6 top-right corner
        else if (square === 1936 && clickCount === 1) {
          const allIndices = [];
          // Fill from top row downward, left to right, only black dots (not red)
          // Skip the 6x6 top-right corner area (rows 0-5, cols 38-43)
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the 6x6 top-right corner area
              const isIn6x6Area = row < 6 && col >= gridSize - 6;
              if (!alreadyFilled.has(idx) && !isIn6x6Area) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (900) dots
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1936 third click - fill 30 yellow dots in 6x6 top-right corner (like 6x6 grid's first click)
        else if (square === 1936 && clickCount === 2) {
          const allIndices = [];
          // Fill 6x6 area in top-right corner (rows 0-5, cols 38-43), but leave triangle pattern (6 dots) for 4th click
          const triangleIndices = getTrianglePatternIndices(gridSize);
          for (let row = 0; row < 6; row++) {
            for (let col = gridSize - 6; col < gridSize; col++) {
              const idx = row * gridSize + col;
              // Skip the triangle pattern (6 purple dots) - that's for the 4th click
              if (!triangleIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (30) dots
          indicesToFill = allIndices.slice(0, componentValue);
        }
        // Special: 1936 fourth click - fill 6 purple dots in triangle pattern top-right corner of 6x6 area
        else if (square === 1936 && clickCount === 3) {
          // Triangle pattern in top-right corner of the 6x6 area (same as 6x6 grid)
          const triangleIndices1936 = getTrianglePatternIndices(gridSize);
          indicesToFill = triangleIndices1936.filter(i => !alreadyFilled.has(i)).slice(0, componentValue);
        }
        
        // If component value is 0, skip filling but still increment clickCount
        // Exception: square 1225 second click has 200 dots, not 0
        // Exception: replica and square 1296 second click should fill remaining black dots orange
        if (componentValue === 0 && !(square === 1225 && clickCount === 1) && !(isReplica && clickCount === 1) && !(square === 1296 && clickCount === 1)) {
          clickCount++;
          if (square === 1296) {
            // For 1296, speak cumulative totals: "1000", "1200", "1290", "1296"
            // Components are [1000, 0, 90, 6], but we treat the second as 200 for cumulative
            let cumulativeTotal;
            if (clickCount === 1) {
              cumulativeTotal = 1000;
            } else if (clickCount === 2) {
              cumulativeTotal = 1200; // 1000 + 200
            } else if (clickCount === 3) {
              cumulativeTotal = 1290; // 1000 + 200 + 90
            } else if (clickCount === 4) {
              cumulativeTotal = 1296; // 1000 + 200 + 90 + 6
            } else {
              cumulativeTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
            }
            speakNumber(cumulativeTotal);
          } else {
          const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
          speakNumber(currentTotal);
          }
          
          // Show answer when all components are processed
          // For numbers like 100 where components are [100, 0, 0], show answer after processing non-zero components
          // CRITICAL: Only show if clickCount is actually > 0 (user has clicked) AND all components processed
          if (clickCount > 0 && answerDisplay && clickCount >= totalClicks) {
            // Append to section only when showing
            if (!answerDisplay.parentNode) {
              section.appendChild(answerDisplay);
            }
            answerDisplay.dataset.allowShow = 'true';
            answerDisplay.classList.add('show');
            answerDisplay.textContent = square;
          }
          return; // Exit early, don't try to fill 0 dots
        }
        
        // Special: 1369 first click – fill exactly 1000 red dots from the bottom
        if (square === 1369 && clickCount === 0) {
          const allIndices = [];
          // Fill from bottom row upwards, left to right within each row
          for (let row = gridSize - 1; row >= 0 && allIndices.length < componentValue; row--) {
            for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
              const idx = row * gridSize + col;
              if (!alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          // Take exactly componentValue (for 1369, 1000) indices
          indicesToFill = allIndices.slice(0, componentValue);
        }
        
        // REPLICA: Handle second click independently - do nothing (MUST BE FIRST CHECK)
        if (isReplica && clickCount === 1) {
          // Second click: Do nothing (no visual changes, no orange dots)
          is1296SpecialClick = true;
          indicesToFill = []; // Empty array - nothing to fill
          color = null; // No color - prevent any filling
        }
        // For 1296 second click, fill remaining black dots orange
        else if (square === 1296 && clickCount === 1 && componentValue === 0) {
          // Second click: Fill all remaining black dots (that will still be black after 4th click) with orange
          // Red dots (first click): 281-288, 297-324, 333-360, 361-1296
          const redDotNumbers = new Set();
          for (let dot = 281; dot <= 288; dot++) redDotNumbers.add(dot);
          for (let dot = 297; dot <= 324; dot++) redDotNumbers.add(dot);
          for (let dot = 333; dot <= 360; dot++) redDotNumbers.add(dot);
          for (let dot = 361; dot <= 1296; dot++) redDotNumbers.add(dot);
          
          // Sky blue dots (third click): 4-10, 39-46, 74-82, 109-118, 145-154, 181-190, 217-226, 253-262, 289-297, 325-332, 360-367
          const skyBlueDotNumbers = new Set();
          for (let dot = 4; dot <= 10; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 39; dot <= 46; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 74; dot <= 82; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 109; dot <= 118; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 145; dot <= 154; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 181; dot <= 190; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 217; dot <= 226; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 253; dot <= 262; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 289; dot <= 297; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 325; dot <= 332; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 360; dot <= 367; dot++) skyBlueDotNumbers.add(dot);
          
          // Purple dots (fourth click): triangle pattern (6 dots at top-right)
          const topRightIndices1296 = getTrianglePatternIndices(gridSize);
          const purpleDotNumbers = new Set();
          topRightIndices1296.forEach(idx => {
            const circle = circles[idx];
            let dotNumber;
            if (circle && circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else if (circle) {
              const row = Math.floor(idx / gridSize);
              const col = idx % gridSize;
              dotNumber = row * gridSize + (gridSize - col);
            }
            if (dotNumber) purpleDotNumbers.add(dotNumber);
          });
          
          // Find all dots that are NOT red, sky blue, or purple (these will be black after 4th click)
          const orangeDotNumbers = [];
          for (let dot = 1; dot <= 1296; dot++) {
            if (!redDotNumbers.has(dot) && !skyBlueDotNumbers.has(dot) && !purpleDotNumbers.has(dot)) {
              orangeDotNumbers.push(dot);
            }
          }
          
          // Find circles by their dot numbers and fill with orange
          const allIndices = [];
          circles.forEach((circle, idx) => {
            let dotNumber;
            if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              const row = Math.floor(idx / gridSize);
              const col = idx % gridSize;
              dotNumber = row * gridSize + (gridSize - col);
            }
            
            if (dotNumber && orangeDotNumbers.includes(dotNumber) && !alreadyFilled.has(idx)) {
              allIndices.push(idx);
            }
          });
          
          indicesToFill = allIndices;
          is1296SpecialClick = true;
          // Note: clickCount will be incremented after filling, and voice feedback will happen then
        }
        // REPLICA: Handle third click independently - do nothing (MUST BE FIRST CHECK)
        else if (isReplica && clickCount === 2) {
          // Third click: Do nothing (no visual changes, no sky blue dots)
          is1296SpecialClick = true;
          indicesToFill = []; // Empty array - nothing to fill
          color = null; // No color - prevent any filling
        } else if (square === 1296 && clickCount === 2) {
          // Original: Third click handler
            // Original: Fill specific dot numbers with sky blue
            // Dot numbers: 4-10, 39-46, 74-82, 109-118, 145-154, 181-190, 217-226, 253-262, 289-297, 325-332, 360-367
            is1296SpecialClick = true;
            const skyBlueDotNumbers = new Set();
            for (let dot = 4; dot <= 10; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 39; dot <= 46; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 74; dot <= 82; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 109; dot <= 118; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 145; dot <= 154; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 181; dot <= 190; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 217; dot <= 226; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 253; dot <= 262; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 289; dot <= 297; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 325; dot <= 332; dot++) skyBlueDotNumbers.add(dot);
            for (let dot = 360; dot <= 367; dot++) skyBlueDotNumbers.add(dot);
            
            // Find circles by their dot numbers
            const allIndices = [];
            circles.forEach((circle, idx) => {
              let dotNumber;
              if (circle.dataset.dotNumber) {
                dotNumber = parseInt(circle.dataset.dotNumber, 10);
              } else {
                const row = Math.floor(idx / gridSize);
                const col = idx % gridSize;
                dotNumber = row * gridSize + (gridSize - col);
              }
              if (dotNumber && skyBlueDotNumbers.has(dotNumber)) {
                allIndices.push(idx);
              }
            });
            indicesToFill = allIndices;
          }
        // REPLICA: Handle fourth click independently
        else if (isReplica && clickCount === 3) {
          // Replica: Fill 9 sky blue dots (3×3 square in top-right corner)
          is1296SpecialClick = true;
          const topRightIndicesReplica = get3x3TopRightIndices(gridSize);
          indicesToFill = topRightIndicesReplica.filter(i => !alreadyFilled.has(i));
        } else if (square === 1296 && clickCount === 3) {
          // Original: Fill 6 purple dots (triangle pattern in top-right corner)
          is1296SpecialClick = true;
          const topRightIndices1296 = getTrianglePatternIndices(gridSize);
          indicesToFill = topRightIndices1296.filter(i => !alreadyFilled.has(i));
        }
        
        // For 1156: second click fills remaining black dots red and moves them up
        // Third click fills specific dots blue
        // Note: Second click (clickCount === 1) will proceed to fill red dots
        
        // Get color based on first digit of component
        const componentStr = componentValue.toString();
        const firstDigit = parseInt(componentStr[0]);
        const colorKey = firstDigit || 10;
        let color = COLOR_MAP[colorKey] || "red";
        
        // All colors are now based on first digit:
        // 1 = red, 2 = orange, 3 = yellow, 4 = green, 5 = blue, 6 = purple, 7 = brown, 8 = pink, 9 = sky blue
        
        // REPLICA: Handle color assignment independently (before other checks)
        if (isReplica) {
          // Replica: 1000 red (first click), nothing (second click), nothing (third click), 9 sky blue (fourth click)
          if (clickCount === 0) {
            color = "red"; // 1000 red dots
          } else if (clickCount === 1) {
            color = null; // Second click: do nothing
          } else if (clickCount === 2) {
            color = null; // Third click: do nothing
          } else if (clickCount === 3) {
            color = "sky"; // 9 sky blue dots (3×3 square)
          }
        }
        // For squares 31×31 to 50×50, determine colors based on source square pattern
        else if (square >= 961 && square <= 2500 && n > 30) {
          // Find the source square with the same last 2 digits
          const lastTwoDigits = square % 100;
          let sourceN = 0;
          let sourceSquare = 0;
          // Find the smaller square with the same last 2 digits
          for (let i = 1; i < n; i++) {
            const testSquare = i * i;
            if (testSquare % 100 === lastTwoDigits) {
              sourceN = i;
              sourceSquare = testSquare;
              break;
            }
          }
          // Map colors from source square patterns
          if (sourceSquare === 361) {
            // 31×31 (961) maps to 19×19 (361): 900 (hundreds), 60 purple (tens), 1 red (ones)
            if (isHundredsPlace) {
              // Determine color based on first digit of hundreds (9 = sky blue, but 900 is special)
              // Actually, 900 should be sky blue, but we're breaking it down as 900 + 60 + 1
              // So hundreds is 900, which starts with 9, so sky blue
              color = "sky";
            } else if (isTensPlace) {
              color = "purple"; // 60 purple
            } else if (isOnesPlace) {
              color = "red"; // 1 red
            }
          } else if (sourceSquare === 324) {
            // 32×32 (1024) maps to 18×18 (324): 1000 (hundreds), 20 orange (tens), 4 green (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 starts with 1
            } else if (isTensPlace) {
              color = "orange"; // 20 orange
            } else if (isOnesPlace) {
              color = "green"; // 4 green
            }
          } else if (sourceSquare === 289) {
            // 33×33 (1089) maps to 17×17 (289): 1000 (hundreds), 80 pink (tens), 9 sky blue (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 starts with 1
            } else if (isTensPlace) {
              color = "pink"; // 80 pink
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue
            }
          } else if (sourceSquare === 256) {
            // 34×34 (1156) maps to 16×16 (256): 1000 (hundreds), 100 red (tens), 50 blue (third click), 6 purple (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 starts with 1
            } else if (square === 1156 && clickCount === 1) {
              color = "red"; // Second click: red dots
            } else if (square === 1156 && clickCount === 2) {
              color = "blue"; // Third click: blue dots
            } else if (isOnesPlace) {
              color = "purple"; // 6 purple
            }
          } else if (sourceSquare === 225 || square === 1225) {
            if (square === 1225) {
              // 35×35 (1225): 1000 red (first click), 200 orange (second click), 20 orange (third click), 5 blue (fourth click)
              if (clickCount === 0) {
                color = "red"; // 1000 red dots
              } else if (clickCount === 1) {
                color = "orange"; // 200 orange dots
              } else if (clickCount === 2) {
                color = "orange"; // 20 orange dots
              } else if (clickCount === 3) {
                color = "blue"; // 5 blue dots
              }
            } else {
              // Original 225 mapping for other squares
              // 35×35 (1225) maps to 15×15 (225): 1200 (hundreds), 20 orange (tens), 5 blue (ones)
              if (isHundredsPlace) {
                color = COLOR_MAP[1] || "red"; // 1200 starts with 1
              } else if (isTensPlace) {
                color = "orange"; // 20 orange
              } else if (isOnesPlace) {
                color = "blue"; // 5 blue
              }
            }
          } else if (sourceSquare === 196) {
            // 36×36 (1296): Original behavior only
            if (square === 1296) {
              // Original: 1000 red (first click), orange (second click), 90 sky blue (third click), 6 purple (fourth click)
              if (clickCount === 0) {
                color = "red"; // 1000 red dots
              } else if (clickCount === 1) {
                color = "orange"; // Remaining black dots turn orange
              } else if (clickCount === 2) {
                color = "sky"; // 90 sky blue dots
              } else if (clickCount === 3) {
                color = "purple"; // 6 purple dots (triangle pattern)
              }
            } else {
              // Other squares mapping to 196: 1200 (hundreds), 90 sky blue (tens), 6 purple (ones)
            if (isHundredsPlace) {
                color = COLOR_MAP[1] || "red"; // 1200 starts with 1
            } else if (isTensPlace) {
                color = COLOR_MAP[9] || "sky"; // 90 starts with 9 = sky blue
            } else if (isOnesPlace) {
                color = COLOR_MAP[6] || "purple"; // 6 starts with 6 = purple
              }
            }
          } else if (sourceSquare === 169) {
            // 37×37 (1369) maps to 13×13 (169): 1300 (hundreds), 60 purple (tens), 9 sky blue (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1300 starts with 1 (for other squares mapping to 169)
            } else if (isTensPlace) {
              color = "purple"; // 60 purple
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue
            }
          } else if (sourceSquare === 144) {
            // 12×12 (144): 1400 (hundreds), 40 green (tens), 4 green (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1400 starts with 1
            } else if (isTensPlace || isOnesPlace) {
              color = "green"; // 40 green and 4 green
            }
          } else if (sourceSquare === 121) {
            // 39×39 (1521) maps to 11×11 (121): 1500 (hundreds), 20 blue (tens), 1 red (ones)
            if (square === 1521) {
              if (isHundredsPlace) {
                color = COLOR_MAP[1] || "red"; // 1500 starts with 1
              } else if (isTensPlace) {
                color = "blue"; // 20 blue (changed from orange)
              } else if (isOnesPlace) {
                color = "red"; // 1 red
              }
            } else {
              // Other squares mapping to 121: 1500 (hundreds), 20 orange (tens), 1 red (ones)
              if (isHundredsPlace) {
                color = COLOR_MAP[1] || "red"; // 1500 starts with 1
              } else if (isTensPlace) {
                color = "orange"; // 20 orange
              } else if (isOnesPlace) {
                color = "red"; // 1 red
              }
            }
          } else if (sourceSquare === 100) {
            // 40×40 (1600) maps to 10×10 (100): 1600 (all filled on first click)
            // BUT: second click (600) should be purple, not red
            if (square === 1600 && clickCount === 1) {
              color = "purple"; // 600 purple dots on second click
            } else if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1600 starts with 1
            }
          } else if (sourceSquare === 81) {
            // 41×41 (1681) maps to 9×9 (81): 1000 red (first), 600 purple (second), 80 pink (third), 1 red (fourth)
            if (square === 1681 && clickCount === 1) {
              color = "purple"; // 600 purple on second click
            } else if (square === 1681 && clickCount === 2) {
              color = "pink"; // 80 pink on third click
            } else if (square === 1681 && clickCount === 3) {
              color = "red"; // 1 red on fourth click (top right corner)
            } else if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 red on first click
            } else if (isTensPlace) {
              color = "pink"; // 80 pink (for other squares mapping to 81)
            } else if (isOnesPlace) {
              color = "red"; // 1 red (for other squares mapping to 81)
            }
          } else if (sourceSquare === 64) {
            // 42×42 (1764) maps to 8×8 (64): 1000 red (first), 700 brown (second), 60 purple (third), 4 green (fourth)
            if (square === 1764 && clickCount === 1) {
              color = "brown"; // 700 brown on second click
            } else if (square === 1764 && clickCount === 2) {
              color = "purple"; // 60 purple on third click
            } else if (square === 1764 && clickCount === 3) {
              color = "green"; // 4 green on fourth click
            } else if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 red on first click
            } else if (isTensPlace) {
              color = "purple"; // 60 purple (for other squares mapping to 64)
            } else if (isOnesPlace) {
              color = "green"; // 4 green (for other squares mapping to 64)
            }
          } else if (sourceSquare === 49) {
            // 43×43 (1849) maps to 7×7 (49): 1000 red (first), 800 pink (second), 40 green (third), 9 sky blue (fourth)
            if (square === 1849 && clickCount === 1) {
              color = "pink"; // 800 pink on second click (8 = pink)
            } else if (square === 1849 && clickCount === 2) {
              color = "green"; // 40 green on third click
            } else if (square === 1849 && clickCount === 3) {
              color = "sky"; // 9 sky blue on fourth click
            } else if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 red on first click
            } else if (isTensPlace) {
              color = "green"; // 40 green (for other squares mapping to 49)
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue (for other squares mapping to 49)
            }
          } else if (sourceSquare === 36) {
            // 44×44 (1936) maps to 6×6 (36): 1000 red (first), 900 sky blue (second), 30 yellow (third), 6 purple (fourth)
            if (square === 1936 && clickCount === 1) {
              color = "sky"; // 900 sky blue on second click (9 = sky blue)
            } else if (square === 1936 && clickCount === 2) {
              color = "yellow"; // 30 yellow on third click
            } else if (square === 1936 && clickCount === 3) {
              color = "purple"; // 6 purple on fourth click
            } else if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 red on first click
            } else if (isTensPlace) {
              color = "yellow"; // 30 yellow (for other squares mapping to 36)
            } else if (isOnesPlace) {
              color = "purple"; // 6 purple (for other squares mapping to 36)
            }
          } else if (sourceSquare === 25) {
            // 45×45 (2025) maps to 5×5 (25): 2000 orange (first), 20 orange (second), 5 blue (third)
            if (square === 2025 && clickCount === 0) {
              color = "orange"; // 2000 orange on first click (2 = orange)
            } else if (square === 2025 && clickCount === 1) {
              color = "orange"; // 20 orange on second click
            } else if (square === 2025 && clickCount === 2) {
              color = "blue"; // 5 blue on third click
            } else if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2000 starts with 2
            } else if (isTensPlace) {
              color = "orange"; // 20 orange (for other squares mapping to 25)
            } else if (isOnesPlace) {
              color = "blue"; // 5 blue (for other squares mapping to 25)
            }
          } else if (sourceSquare === 16) {
            // 46×46 (2116) maps to 4×4 (16): 2000 orange (first), 100 red (second), 10 red (third), 6 purple (fourth)
            if (square === 2116 && clickCount === 0) {
              color = "orange"; // 2000 orange on first click (2 = orange)
            } else if (square === 2116 && clickCount === 1) {
              color = "red"; // 100 red on second click (1 = red)
            } else if (square === 2116 && clickCount === 2) {
              color = "red"; // 10 red on third click
            } else if (square === 2116 && clickCount === 3) {
              color = "purple"; // 6 purple on fourth click
            } else if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2100 starts with 2
            } else if (isTensPlace) {
              color = "red"; // 10 red (for other squares mapping to 16)
            } else if (isOnesPlace) {
              color = "purple"; // 6 purple (for other squares mapping to 16)
            }
          } else if (sourceSquare === 9) {
            // 47×47 (2209) maps to 3×3 (9): 2000 orange (first), 200 orange (second), 9 sky blue (third)
            if (square === 2209 && clickCount === 0) {
              color = "orange"; // 2000 orange on first click (2 = orange)
            } else if (square === 2209 && clickCount === 1) {
              color = "orange"; // 200 orange on second click
            } else if (square === 2209 && clickCount === 2) {
              color = "sky"; // 9 sky blue on third click
            } else if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2200 starts with 2
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue
            }
          } else if (sourceSquare === 4) {
            // 48×48 (2304) maps to 2×2 (4): 2300 (hundreds), 0 (tens), 4 green (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2300 starts with 2
            } else if (isOnesPlace) {
              color = "green"; // 4 green - by Ted Hughes
            }
          } else if (sourceSquare === 1) {
            // 49×49 (2401) maps to 1×1 (1): 2400 (hundreds), 0 (tens), 1 red (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2400 starts with 2
            } else if (isOnesPlace) {
              color = "red"; // 1 red
            }
          } else if (sourceSquare === 0 || sourceN === 0) {
            // 50×50 (2500): Color each circle based on first digit of its number
            // First click: Numbers starting with 2 (2000-2499) = orange
            // Second click: Numbers starting with 5 (500-599) = blue
            if (clickCount === 0) {
              color = COLOR_MAP[2] || "orange"; // 2000 starts with 2 = orange
            } else if (clickCount === 1) {
              color = COLOR_MAP[5] || "blue"; // 500 starts with 5 = blue
            }
          }
        }
        
        // Special: 2601 (51×51) - 2000 orange, 600 purple, 1 red
        if (square === 2601) {
          if (isHundredsPlace) {
            color = COLOR_MAP[2] || "orange"; // 2000 starts with 2
          } else if (isTensPlace) {
            color = COLOR_MAP[6] || "purple"; // 600 starts with 6
          } else if (isOnesPlace) {
            color = "red"; // 1 red
          }
        }
        // Special: 2704 (52×52) - 2000 orange, 700 brown, 4 green (maps to 2×2 like 48×48)
        if (square === 2704) {
          if (isHundredsPlace) {
            color = COLOR_MAP[2] || "orange"; // 2000 starts with 2
          } else if (isTensPlace) {
            color = COLOR_MAP[7] || "brown"; // 700 starts with 7
          } else if (isOnesPlace) {
            color = "green"; // 4 green - same as 48×48
          }
        }
        
        // Special: 676 - override component breakdown to [233, 227, 216] instead of [600, 70, 6]
        // This ensures voice says correct numbers: 233, 460 (233+227), 676 (233+227+216)
        if (square === 676) {
          // We'll handle the voice separately, but need to ensure correct totals
        }
        
        // alreadyFilled already calculated above for 1296 handlers
        // indicesToFill already declared above for 1296 special handling
        
        
        // Special handling for 1156 - third click fills specific dots blue
        if (square === 1156 && clickCount === 2) {
          // Third click: fill specific dots blue
          // Dots to turn blue: 4-8, 66-61, 101-95, 136-129, 170-163, 204-197, 238-231
          const blueDotNumbers = new Set();
          
          // Add all the dot number ranges
          for (let dot = 4; dot <= 8; dot++) blueDotNumbers.add(dot);
          for (let dot = 61; dot <= 66; dot++) blueDotNumbers.add(dot);
          for (let dot = 95; dot <= 101; dot++) blueDotNumbers.add(dot);
          for (let dot = 129; dot <= 136; dot++) blueDotNumbers.add(dot);
          for (let dot = 163; dot <= 170; dot++) blueDotNumbers.add(dot);
          for (let dot = 197; dot <= 204; dot++) blueDotNumbers.add(dot);
          for (let dot = 231; dot <= 238; dot++) blueDotNumbers.add(dot);
          
          // Convert dot numbers to indices by checking each circle's dot number
          const blueDots = [];
          circles.forEach((circle, idx) => {
            // For 1156, get dot number from data attribute or calculate from index
            let dotNumber;
            if (square === 1156) {
              if (circle.dataset.dotNumber) {
                dotNumber = parseInt(circle.dataset.dotNumber, 10);
              } else {
                // Calculate from index if data attribute not set
                const row = Math.floor(idx / gridSize);
                const col = idx % gridSize;
                if (row === 0) {
                  dotNumber = gridSize - col;
                } else {
                  dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                }
              }
            } else {
              const numberSpan = circle.querySelector('.circle-number');
              if (numberSpan) {
                dotNumber = parseInt(numberSpan.textContent, 10);
              }
            }
            if (dotNumber && blueDotNumbers.has(dotNumber)) {
              blueDots.push(idx);
            }
          });
          
          // Include all blue dots, even if they're already filled (red) - we'll change them to blue
          indicesToFill = blueDots;
        } else if (square === 1156 && clickCount === 1) {
          // Second click: fill remaining black dots red (excluding dots that will turn blue or purple)
          // Dots that will turn blue on 3rd click: 4-8, 61-66, 95-101, 129-136, 163-170, 197-204, 231-238
          // Dots that will turn purple on 4th click: 1, 2, 3, 67, 68, 102
          const blueDotNumbers = new Set();
          for (let dot = 4; dot <= 8; dot++) blueDotNumbers.add(dot);
          for (let dot = 61; dot <= 66; dot++) blueDotNumbers.add(dot);
          for (let dot = 95; dot <= 101; dot++) blueDotNumbers.add(dot);
          for (let dot = 129; dot <= 136; dot++) blueDotNumbers.add(dot);
          for (let dot = 163; dot <= 170; dot++) blueDotNumbers.add(dot);
          for (let dot = 197; dot <= 204; dot++) blueDotNumbers.add(dot);
          for (let dot = 231; dot <= 238; dot++) blueDotNumbers.add(dot);
          
          const purpleDotNumbers = new Set([1, 2, 3, 67, 68, 102]);
          
          // Find all black dots (dots that are not filled yet)
          const blackDots = [];
          circles.forEach((circle, idx) => {
            // For 1156, get dot number from data attribute or calculate from index
            let dotNumber;
            if (square === 1156) {
              if (circle.dataset.dotNumber) {
                dotNumber = parseInt(circle.dataset.dotNumber, 10);
              } else {
                // Calculate from index if data attribute not set
                const row = Math.floor(idx / gridSize);
                const col = idx % gridSize;
                if (row === 0) {
                  dotNumber = gridSize - col;
                } else {
                  dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                }
              }
            } else {
              const numberSpan = circle.querySelector('.circle-number');
              if (numberSpan) {
                dotNumber = parseInt(numberSpan.textContent, 10);
              }
            }
            if (dotNumber) {
              // Only include if it's not already filled AND not in blue/purple lists
              if (!alreadyFilled.has(idx) && !blueDotNumbers.has(dotNumber) && !purpleDotNumbers.has(dotNumber)) {
                blackDots.push(idx);
              }
            }
          });
          
          indicesToFill = blackDots;
        } else if (square === 2500) {
          // Special handling for 2500 - color each circle based on first digit of its number
          // First click: Numbers starting with 2 (2000-2499) = orange
          // Second click: Numbers starting with 5 (500-599) = blue
          const indicesToColor = [];
          circles.forEach((circle, idx) => {
            // Get the number from the circle
            let dotNumber;
            const numberSpan = circle.querySelector('.circle-number');
            if (numberSpan) {
              dotNumber = parseInt(numberSpan.textContent, 10);
            } else if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              // Calculate from index (right to left, row by row)
              const row = Math.floor(idx / gridSize);
              const col = idx % gridSize;
              dotNumber = row * gridSize + (gridSize - col);
            }
            
            if (dotNumber) {
              const dotNumberStr = dotNumber.toString();
              const firstDigit = parseInt(dotNumberStr[0]);
              
              // Determine color based on first digit and which click we're on
              // First click (clickCount === 0): componentValue = 2000, color numbers starting with 2
              // Second click (clickCount === 1): componentValue = 500, color numbers starting with 5
              if (clickCount === 0 && firstDigit === 2 && dotNumber >= 2000 && dotNumber <= 2499) {
                // Numbers starting with 2 (2000-2499) should be orange on first click
                indicesToColor.push(idx);
              } else if (clickCount === 1 && firstDigit === 5 && dotNumber >= 500 && dotNumber <= 599) {
                // Numbers starting with 5 (500-599) should be blue on second click
                indicesToColor.push(idx);
              }
            }
          });
          
          indicesToFill = indicesToColor.filter(i => !alreadyFilled.has(i));
        } else if (square === 900) {
          // Special handling for 900 - fill all 900 dots with sky blue on first (and only) click
          const allIndices = [];
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              allIndices.push(idx);
            }
          }
          // Fill all 900 dots
          indicesToFill = allIndices
            .filter(i => !alreadyFilled.has(i))
            .slice(0, componentValue);
        } else if (isOnesPlace) {
          // Ones place: use the pre-calculated top right indices
          if (square === 729) {
            // Special: 729 - explicitly fill the 3×3 square (rows 0-2, cols 24-26)
            const allIndices = [];
            for (let row = 0; row < 3 && row < gridSize; row++) {
              for (let col = 24; col < 27 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices;
          } else if (square === 784) {
            // Special: 784 - explicitly fill the 2×2 square (rows 0-1, cols 26-27)
            const allIndices = [];
            for (let row = 0; row < 2 && row < gridSize; row++) {
              for (let col = 26; col < 28 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices;
          } else if (square === 841) {
            // Special: 841 - explicitly fill the 1 red dot at top-right corner (row 0, col 28)
            const allIndices = [];
            const topRightIdx = 0 * gridSize + 28;
            if (!alreadyFilled.has(topRightIdx)) {
              allIndices.push(topRightIdx);
            }
            indicesToFill = allIndices;
          } else if (square === 2601 && isOnesPlace) {
            // Special: 2601 (51×51) - explicitly fill the 1 red dot at top-right corner
            const allIndices = [];
            const topRightIdx = 0 * gridSize + (gridSize - 1); // Top-right corner
            if (!alreadyFilled.has(topRightIdx)) {
              allIndices.push(topRightIdx);
            }
            indicesToFill = allIndices;
          } else if (square === 2704 && isOnesPlace) {
            // Special: 2704 (52×52) - explicitly fill the 4 green dots in 2×2 square at top-right corner (same as 48×48)
            const allIndices = [];
            // 2×2 square in top-right: rows 0-1, cols gridSize-2 to gridSize-1
            for (let row = 0; row < 2 && row < gridSize; row++) {
              for (let col = gridSize - 2; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices;
          } else if (square >= 961 && square <= 2500 && n > 30 && isOnesPlace) {
            // For squares 31×31 (961) through 50×50 (2500), map ones place pattern from source square
            // Find the source square with the same last 2 digits
            const lastTwoDigits = square % 100;
            let sourceN = 0;
            let sourceSquare = 0;
            // Find the smaller square with the same last 2 digits
            for (let i = 1; i < n; i++) {
              const testSquare = i * i;
              if (testSquare % 100 === lastTwoDigits) {
                sourceN = i;
                sourceSquare = testSquare;
                break;
              }
            }
            const sourceGridSize = sourceN;
            
            if (sourceSquare === 361) {
              // 31×31 (961) maps to 19×19 (361) - 1 red dot at top-right corner
              // Map relative to top-right corner: row 0, col 18 in 19×19 → row 0, col 30 in 31×31
              const allIndices = [];
              const sourceGridSize = 19;
              const targetGridSize = gridSize;
              // Red dot is at top-right corner: row 0, col 18 in 19×19
              // Map to top-right corner in 31×31: row 0, col 30
              const sourceCol = 18; // Top-right corner in 19×19
              const distanceFromRight = sourceGridSize - 1 - sourceCol; // Should be 0
              const targetCol = targetGridSize - 1 - distanceFromRight; // Top-right corner in 31×31
              const targetRow = 0; // Top row
              const topRightIdx = targetRow * gridSize + targetCol;
              if (!alreadyFilled.has(topRightIdx)) {
                allIndices.push(topRightIdx);
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - 4 green dots in 2x2 square at top-right corner
              // Map relative to top-right corner: rows 0-1, cols 16-17 in 18×18 → rows 0-1, cols 30-31 in 32×32
              const allIndices = [];
              const sourceGridSize = 18;
              const targetGridSize = gridSize; // Should be 32
              // Map the 2x2 square: rows 0-1, cols 16-17 (top-right corner in 18×18)
              for (let sourceRow = 0; sourceRow < 2; sourceRow++) {
                for (let sourceCol = 16; sourceCol <= 17; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    if (!alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 289) {
              // 33×33 (1089) maps to 17×17 (289) - 9 sky blue dots in 3x3 square at top-right corner
              // Map relative to top-right corner: rows 0-2, cols 14-16 in 17×17 → rows 0-2, cols 30-32 in 33×33
              const allIndices = [];
              const sourceGridSize = 17;
              const targetGridSize = gridSize; // Should be 33
              // Map the 3x3 square: rows 0-2, cols 14-16 (top-right corner in 17×17)
              for (let sourceRow = 0; sourceRow < 3; sourceRow++) {
                for (let sourceCol = 14; sourceCol <= 16; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    if (!alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 225 || square === 1225) {
              if (square === 1225 && clickCount === 3) {
                // 35×35 (1225) - Fourth click: 5 blue dots in column 1 (rightmost), rows 0-4
                // These dots were moved up on the 3rd click, so we need to find the separated circles
                // Column 1 from right = column 34 (index)
                const allIndices = [];
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  const idx = row * gridSize + (gridSize - 1); // Column 34 (rightmost)
                  // Check if this dot was already moved (exists as separated circle)
                  const existingSeparated = separatedCircles.find(sc => {
                    const scRow = parseInt(sc.dataset.originalRow);
                    const scCol = parseInt(sc.dataset.originalCol);
                    return scRow === row && scCol === gridSize - 1;
                  });
                  if (existingSeparated) {
                    // This dot is already separated, we'll color it blue in the processing loop
                    // Add a special marker so we know to process it
                    allIndices.push(idx);
                  } else if (!alreadyFilled.has(idx)) {
                    // Dot is still in original position
                    allIndices.push(idx);
                  }
                }
                indicesToFill = allIndices;
              } else if (square === 1225) {
                // For other clicks, use default behavior
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices.slice(0, componentValue);
              } else {
                // Original 225 mapping logic for other squares
                const allIndices = [];
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  const idx = row * gridSize + (gridSize - 1);
                  if (!alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
                indicesToFill = allIndices;
              }
            } else if (sourceSquare === 169) {
              // 37×37 (1369) maps to 13×13 (169) - 9 sky blue dots in 3x3 square
              const allIndices = [];
              // Map the 3x3 square: rows 0-2, cols 10-12 → rows 0-2, cols (10+columnShift)-(12+columnShift)
              for (let row = 0; row < 3 && row < gridSize; row++) {
                for (let col = 10 + columnShift; col <= 12 + columnShift && col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 144) {
              // 38×38 (1444) maps to 12×12 (144) - 4 green dots in 2x2 square
              const allIndices = [];
              // Map the 2x2 square: rows 0-1, cols 10-11 → rows 0-1, cols (10+columnShift)-(11+columnShift)
              for (let row = 0; row < 2 && row < gridSize; row++) {
                for (let col = 10 + columnShift; col <= 11 + columnShift && col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 256) {
              // 34×34 (1156) - 6 purple dots on 4th click (ones place)
              // Use specific dot numbers: 1, 2, 3, 67, 68, 102
              const purpleDotNumbers = new Set();
              purpleDotNumbers.add(1);
              purpleDotNumbers.add(2);
              purpleDotNumbers.add(3);
              purpleDotNumbers.add(67);
              purpleDotNumbers.add(68);
              purpleDotNumbers.add(102);
              
              // Convert dot numbers to indices by checking each circle's dot number
              const allIndices = [];
              circles.forEach((circle, idx) => {
                // For 1156, get dot number from data attribute or calculate from index
                let dotNumber;
                if (square === 1156) {
                  if (circle.dataset.dotNumber) {
                    dotNumber = parseInt(circle.dataset.dotNumber, 10);
                  } else {
                    // Calculate from index if data attribute not set
                    const row = Math.floor(idx / gridSize);
                    const col = idx % gridSize;
                    if (row === 0) {
                      dotNumber = gridSize - col;
                    } else {
                      dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                    }
                  }
                } else {
                  const numberSpan = circle.querySelector('.circle-number');
                  if (numberSpan) {
                    dotNumber = parseInt(numberSpan.textContent, 10);
                  }
                }
                if (dotNumber && purpleDotNumbers.has(dotNumber)) {
                  allIndices.push(idx);
                }
              });
              
              indicesToFill = allIndices;
            } else {
              indicesToFill = topRightIndices.filter(i => !alreadyFilled.has(i));
            }
          } else {
            indicesToFill = topRightIndices.filter(i => !alreadyFilled.has(i));
          }
        } else if (square === 1225 && clickCount === 1) {
          // 35×35 (1225) - Second click: 200 orange dots (the ones that remain black after 4th click)
          // Exclude: 1000 red dots (first click), 20 orange dots (third click), 5 blue dots (fourth click)
          // Third click dots: 2-5, 66-69, 101-104, 136-139, 171-174
          // Fourth click dots: column 34 (rightmost), rows 0-4 = dots 1, 70, 105, 140, 175
          const excludedDotNumbers = new Set();
          // Third click orange dots
          for (let dot = 2; dot <= 5; dot++) excludedDotNumbers.add(dot);
          for (let dot = 66; dot <= 69; dot++) excludedDotNumbers.add(dot);
          for (let dot = 101; dot <= 104; dot++) excludedDotNumbers.add(dot);
          for (let dot = 136; dot <= 139; dot++) excludedDotNumbers.add(dot);
          for (let dot = 171; dot <= 174; dot++) excludedDotNumbers.add(dot);
          // Fourth click blue dots
          excludedDotNumbers.add(1); // Row 0, col 34
          excludedDotNumbers.add(70); // Row 1, col 34
          excludedDotNumbers.add(105); // Row 2, col 34
          excludedDotNumbers.add(140); // Row 3, col 34
          excludedDotNumbers.add(175); // Row 4, col 34
          
          // Find all black dots (not filled yet) that are not in the excluded list
          const allIndices = [];
          circles.forEach((circle, idx) => {
            let dotNumber;
            if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              // Calculate from index if data attribute not set
              dotNumber = getDotNumberFromIndex1225(idx, gridSize);
            }
            if (!excludedDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
              allIndices.push(idx);
            }
          });
          indicesToFill = allIndices.slice(0, 200); // Exactly 200 orange dots
        } else if (square === 1225 && clickCount === 2) {
          // 35×35 (1225) - Third click: 20 orange dots at specific dot numbers
          // Dot numbers: 2-5, 66-69, 101-104, 136-139, 171-174
          const orangeDotNumbers = new Set();
          // 2 through 5
          for (let dot = 2; dot <= 5; dot++) orangeDotNumbers.add(dot);
          // 69 through 66 (backwards, so 66-69)
          for (let dot = 66; dot <= 69; dot++) orangeDotNumbers.add(dot);
          // 104 through 101 (backwards, so 101-104)
          for (let dot = 101; dot <= 104; dot++) orangeDotNumbers.add(dot);
          // 139 through 136 (backwards, so 136-139)
          for (let dot = 136; dot <= 139; dot++) orangeDotNumbers.add(dot);
          // 174 through 171 (backwards, so 171-174)
          for (let dot = 171; dot <= 174; dot++) orangeDotNumbers.add(dot);
          
          // Find circles by their dot numbers
          const allIndices = [];
          circles.forEach((circle, idx) => {
            let dotNumber;
            if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              // Calculate from index if data attribute not set
              dotNumber = getDotNumberFromIndex1225(idx, gridSize);
            }
            if (orangeDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
              allIndices.push(idx);
            }
          });
          indicesToFill = allIndices;
        } else if (is1296SpecialClick) {
          // 1296 third/fourth clicks already handled above - skip other handlers
        } else if (square === 1600 && clickCount === 0 && indicesToFill.length > 0) {
          // 1600 first click already handled above - skip other handlers
        } else if (square === 1600 && clickCount === 1 && indicesToFill.length > 0) {
          // 1600 second click already handled above - skip other handlers
        } else if (square === 2209 && clickCount === 0) {
          // Special: 2209 - 2000 orange on first click, leave exactly 209 black dots
          // Original 47×47: 20×10 rectangle (rows 0-19, cols 34-43) + 3×3 square (rows 0-2, cols 44-46)
          // Scaled to 13×13: 6×3 rectangle (rows 0-5, cols 10-12) + 3×3 square (rows 0-2, cols 10-12, but 3×3 is always top-right)
          // Must be BEFORE isHundredsPlace check because components.length === 1, so isHundredsPlace is false
          const allIndices = [];
          // Fill from bottom, leaving:
          // - Scaled rectangle: rows 0-5, cols 10-12 (for 13×13) OR rows 0-19, cols 34-43 (for 47×47)
          // - 3×3 square: rows 0-2, cols (gridSize-3) to (gridSize-1) (always top-right)
          // Total: 209 black dots (or proportionally scaled)
          const rectStartRow = gridSize === 47 ? 0 : 0;
          const rectEndRow = gridSize === 47 ? 19 : 5;
          const rectStartCol = gridSize === 47 ? 34 : 10;
          const rectEndCol = gridSize === 47 ? 43 : 12;
          for (let row = gridSize - 1; row >= 0; row--) {
            for (let col = 0; col < gridSize; col++) {
              // Skip the scaled rectangle area
              const isInRectangleArea = row >= rectStartRow && row <= rectEndRow && col >= rectStartCol && col <= rectEndCol;
              // Skip the 3×3 rectangle area (rows 0-2, cols gridSize-3 to gridSize-1, always top-right)
              const isIn3x3Area = row < 3 && col >= gridSize - 3;
              if (isInRectangleArea || isIn3x3Area) {
                continue; // Skip this position - it's in the black area
              }
              const idx = row * gridSize + col;
              allIndices.push(idx);
            }
          }
          indicesToFill = allIndices
            .filter(i => !alreadyFilled.has(i))
            .slice(0, componentValue);
        } else if (isHundredsPlace) {
          // Hundreds place: start from bottom left, fill all the way to top
          // Skip if indicesToFill already set by special case (e.g., 1369 first click, 1600 first click, 1600 second click, 2500)
          if (indicesToFill.length > 0 || square === 2500) {
            // Already handled by special case, skip
          } else if (square === 1600 && clickCount === 0) {
            // Special: 1600 first click - fill 1000 dots from bottom-left corner
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 1600 && clickCount === 1) {
            // Special: 1600 second click (600) - SKIP THIS, handled AFTER alreadyFilled is populated (line 1920)
            // Don't override indicesToFill here - it's set correctly after alreadyFilled is ready
          } else if (square === 144) {
            // Special: 144 - fill 100 red, but leave space for 40 green (rows 2-5, left 10 cols) and 4 (top right 2x2)
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip top right 2x2 (for 4) and rows 2-5, left 10 cols (for 40 green)
                if (!topRightIndices.includes(idx) && 
                    !(row >= 2 && row < 6 && col < 10)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 169) {
            // Special: 169 - 100 red at bottom, leave space for 60 purple and 9 sky
            const allIndices = [];
            // Fill from bottom, leave top 3 rows for 60 purple and 9 sky
            // Fill bottom rows first
            for (let row = gridSize - 1; row >= 3 && allIndices.length < componentValue; row--) {
              for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill remaining from row 3, avoiding the top right 3x3 area
            for (let col = 0; col < gridSize - 3 && allIndices.length < componentValue; col++) {
              const idx = 3 * gridSize + col;
              if (!topRightIndices.includes(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 361) {
            // Special: 361 - 300 yellow, leave space for 60 purple + 1 red
            // Pattern exactly as specified:
            // Row 0: 1 yellow + 7 purple + 1 red
            // Row 1: 1 yellow + 8 purple
            // Rows 2-5: 8 purple each
            // Row 6: 7 purple
            // Row 7: 6 purple
            // Total: 60 purple + 1 red = 61 positions
            // Pattern: Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            const allIndices = [];
            // Fill from bottom, leaving the specified areas empty
            // Note: col 10 in rows 0-1 should be filled with yellow (not skipped)
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip row 0: cols 11-18 (7 purple + 1 red), but fill col 10 (yellow)
                if (row === 0 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip row 1: cols 11-18 (8 purple), but fill col 10 (yellow)
                if (row === 1 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip rows 2-5: cols 11-18 (8 purple each)
                if (row >= 2 && row <= 5 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip row 6: cols 12-18 (7 purple)
                if (row === 6 && col >= 12 && col <= 18) {
                  continue;
                }
                // Skip row 7: cols 13-18 (6 purple)
                if (row === 7 && col >= 13 && col <= 18) {
                  continue;
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 441) {
            // Special: 441 - 400 green, need to leave space for 41 (8×5 rectangle + 1 diagonal dot)
            // Row 0, col 12 (13th dot in top row) should be green on first click
            // Row 0, col 20 (top-right corner) should remain BLACK until third click (when it becomes red)
            // Row 5, col 12 (diagonal dot from bottom-left of rectangle) should remain black until second click
            const allIndices = [];
            // Fill from bottom, but skip:
            // - The entire 8×5 rectangle on the right (rows 0-4, cols 13-20)
            // - Row 4, col 12 (diagonal dot that will be part of the 41)
            // BUT: Include row 0, col 12 (13th dot in top row) - it should be green
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the entire 8×5 rectangle area (rows 0-4, cols 13-20)
                if (row >= 0 && row < 5 && col >= 13 && col < 21) {
                  continue;
                }
                // Skip row 5, col 12 (diagonal dot that will be part of the 41 on second click)
                if (row === 5 && col === 12) {
                  continue;
                }
                // Include row 0, col 12 (13th dot in top row) - it should be green
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 256 && isHundredsPlace) {
            // Special: 256 (16×16) - 200 red dots on first click
            // Leave top-right corner: 7 rows × 8 columns (rows 0-6, cols 8-15) = 56 black dots
            // Rotated: 7 deep (rows) × 8 across (columns), top row has 8 dots
            const allIndices = [];
            // Fill from bottom, leaving the top-right 7×8 area empty
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip the top-right 7×8 area (rows 0-6, cols 8-15)
                if (row < 7 && col >= 8 && col <= 15) {
                  continue; // Skip this position - it's in the top-right 7×8 area
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 225) {
            // Special: 225 - 200 orange, leave exactly 25 black dots in a 5×5 rectangle (rows 0-4, cols 10-14)
            const allIndices = [];
            // Fill from bottom, leaving exactly the 5×5 rectangle (rows 0-4, cols 10-14) empty
            // Fill all rows from bottom up, skipping only the 5×5 area
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip the 5×5 rectangle area (rows 0-4, cols 10-14)
                if (row < 5 && col >= 10 && col <= 14) {
                  continue; // Skip this position - it's in the 5×5 area
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 2025 && clickCount === 0) {
            // Special: 2025 - 2000 orange on first click, leave exactly 25 black dots in a 5×5 rectangle (rows 0-4, cols 40-44)
            const allIndices = [];
            // Fill from bottom, leaving exactly the 5×5 rectangle (rows 0-4, cols 40-44) empty
            // Fill all rows from bottom up, skipping only the 5×5 area
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip the 5×5 rectangle area (rows 0-4, cols 40-44)
                if (row < 5 && col >= gridSize - 5) {
                  continue; // Skip this position - it's in the 5×5 area
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 2116 && clickCount === 0) {
            // Special: 2116 - 2000 orange on first click, leave exactly 116 black dots: 10×10 square (rows 0-9, cols 32-41) + 4×4 square (rows 0-3, cols 42-45)
            const allIndices = [];
            // Fill from bottom, leaving:
            // - 10×10 square: rows 0-9, cols 32-41 (100 black dots)
            // - 4×4 square: rows 0-3, cols 42-45 (16 black dots)
            // Total: 116 black dots
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip the 10×10 rectangle area (rows 0-9, cols 32-41)
                const isIn10x10Area = row < 10 && col >= 32 && col <= 41;
                // Skip the 4×4 rectangle area (rows 0-3, cols 42-45)
                const isIn4x4Area = row < 4 && col >= gridSize - 4;
                if (isIn10x10Area || isIn4x4Area) {
                  continue; // Skip this position - it's in the black area
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 289) {
            // Special: 289 - 200 orange, leave clean top-right area for 80 pink + 9 sky blue (89 total)
            // We need exactly 89 positions empty (289 - 200 = 89)
            // Leave: rows 0-8, cols 8-16 (9 rows × 9 cols = 81) + row 9, cols 9-16 (1 row × 8 cols = 8) = 89 positions
            // This ensures a clean top-right corner with no orange dots
            const allIndices = [];
            // Fill from bottom, leaving the top-right area empty
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip rows 0-8, cols 8-16 (9 rows × 9 cols = 81 positions)
                if (row >= 0 && row <= 8 && col >= 8 && col <= 16) {
                  continue;
                }
                // Skip row 9, cols 9-16 (1 row × 8 cols = 8 positions)
                if (row === 9 && col >= 9 && col <= 16) {
                  continue;
                }
                // Total skipped: 81 + 8 = 89 positions, leaving exactly 200 available for orange
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 324) {
            // Special: 324 - 300 yellow, leave space for 20 orange + 4 green
            // Pattern: 4 rows (rows 0-3) × 5 columns (cols 13-17) + 1 row (row 4) × 4 columns (cols 14-17)
            // The 4 green are in a 2x2 square at rows 0-1, cols 16-17
            // Top part: 4 rows × 5 cols = 20 positions, minus 4 green = 16 orange
            // Bottom row: 1 row × 4 cols (cols 14-17) = 4 orange (moved 2 positions to the right)
            // Total = 20 orange
            const allIndices = [];
            // Fill from bottom, leaving:
            // - rows 0-3, cols 13-17 (for 16 orange + 4 green in top part)
            // - row 4, cols 14-17 (for 4 orange in bottom row, moved 2 positions right)
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip rows 0-3, cols 13-17 (the top part for orange + green)
                if (row >= 0 && row <= 3 && col >= 13 && col <= 17) {
                  continue;
                }
                // Skip row 4, cols 14-17 (the bottom row for orange, moved 2 positions right)
                if (row === 4 && col >= 14 && col <= 17) {
                  continue;
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 484) {
            // Special: 484 - Simple pattern: everything green except the 9×9 square
            // The 9×9 rectangle: rows 0-8, cols 13-21 (top-right corner area)
            // Fill all dots except the 9×9 square = 484 - 81 = 403 green dots
            // PLUS: dots 482, 483, 484 should be green (these are in the 9×9 area but user wants them green)
            // MINUS: dots 189, 211, 212 should be black (user wants them excluded from green)
            const nineByNineIndices = [];
            for (let row = 0; row < 9; row++) {
              for (let col = 13; col < 22; col++) {
                nineByNineIndices.push(row * gridSize + col);
              }
            }
            // Dots to exclude (make black): 189, 211, 212
            // Dot number N is at index N-1
            // Dot 189: index 188, row 8, col 12
            // Dot 211: index 210, row 9, col 12
            // Dot 212: index 211, row 9, col 13
            const blackDots = [188, 210, 211]; // indices for dots 189, 211, 212
            
            // Dots 482, 483, 484 are already outside the 9×9 (row 21), so they're automatically included
            // Simple: fill everything except the 9×9 square, but exclude black dots
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the entire 9×9 square
                if (nineByNineIndices.includes(idx)) {
                  continue;
                }
                // Skip black dots (189, 211, 212)
                if (blackDots.includes(idx)) {
                  continue;
                }
                // Include all other dots (including 482, 483, 484 which are outside 9×9)
                allIndices.push(idx);
              }
            }
            // Should be 403 - 3 (black dots) = 400 green dots total
            // Dots 482-484 are already included (they're outside the 9×9)
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, 400);
          } else if (square === 529) {
            // Special: 529 - 500 blue, leave space for 20 orange (4×5 rectangle) and 9 (top right 3x3)
            // The 20 orange rectangle: rows 0-3, cols 15-19 (4 rows × 5 cols = 20)
            // The 9 sky blue: rows 0-2, cols 20-22 (3×3 in top-right)
            const orangeRectangleIndices = [];
            for (let row = 0; row < 4; row++) {
              for (let col = 15; col < 20; col++) {
                orangeRectangleIndices.push(row * gridSize + col);
              }
            }
            const allIndices = [];
            // Fill from bottom, leaving space for 20 orange rectangle and 3×3 square
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the 3×3 square (top-right)
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                // Skip the 20 orange rectangle (rows 0-3, cols 15-19)
                if (orangeRectangleIndices.includes(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 576) {
            // Special: 576 - 500 blue, with specific black dots
            // Row 1: dots 17-24 (indices 16-23) are black
            // Row 2: dots 41-48 (indices 40-47) are black
            // Row 3: dots 65-72 (indices 64-71) are black
            // Row 4: dots 89-96 (indices 88-95) are black
            // Row 5: dots 113-120 (indices 112-119) are black
            // Row 6: dots 137-144 (indices 136-143) are black
            // Row 7: dots 161-168 (indices 160-167) are black
            // Row 8: dots 184-192 (indices 183-191) are black
            // Dot 207 (index 206) is black
            const blackDots = new Set();
            // Row 1 (0-indexed row 0): dots 17-24
            for (let dot = 17; dot <= 24; dot++) {
              blackDots.add(dot - 1); // Convert to index
            }
            // Row 2 (0-indexed row 1): dots 41-48
            for (let dot = 41; dot <= 48; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 3 (0-indexed row 2): dots 64-72 (added 64)
            for (let dot = 64; dot <= 72; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 4 (0-indexed row 3): dots 88-96 (added 88)
            for (let dot = 88; dot <= 96; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 5 (0-indexed row 4): dots 112-120 (added 112)
            for (let dot = 112; dot <= 120; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 6 (0-indexed row 5): dots 136-144 (added 136)
            for (let dot = 136; dot <= 144; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 7 (0-indexed row 6): dots 160-168 (added 160)
            for (let dot = 160; dot <= 168; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 8 (0-indexed row 7): dots 184-192 (added 184, 208 is blue not black)
            for (let dot = 184; dot <= 192; dot++) {
              // Skip dot 208 (index 207) - it's blue
              if (dot === 208) continue;
              blackDots.add(dot - 1);
            }
            // Dots 209, 210, 211, 212, 213, 214 are black
            blackDots.add(208); // Dot 209 (index 208)
            blackDots.add(209); // Dot 210 (index 209)
            blackDots.add(210); // Dot 211 (index 210)
            blackDots.add(211); // Dot 212 (index 211)
            blackDots.add(212); // Dot 213 (index 212)
            blackDots.add(213); // Dot 214 (index 213)
            
            // Also include the 6-dot pattern (ones place) as black dots
            // These will turn purple on the 3rd click
            topRightIndices.forEach(idx => {
              blackDots.add(idx);
            });
            
            // Dots 571-576 should be blue (not black)
            // Remove them from black list if they were added
            for (let dot = 571; dot <= 576; dot++) {
              blackDots.delete(dot - 1); // Convert to index and remove
            }
            
            // Count: 74 specified black + 6 ones pattern = 80 black dots total
            // But user says 76 black dots... let me verify the count:
            // Row 1: 17-24 = 8 dots
            // Row 2: 41-48 = 8 dots
            // Row 3: 65-72 = 8 dots
            // Row 4: 89-96 = 8 dots
            // Row 5: 113-120 = 8 dots
            // Row 6: 137-144 = 8 dots
            // Row 7: 161-168 = 8 dots
            // Row 8: 184-192 = 9 dots
            // Dot 207 = 1 dot
            // Total specified: 8+8+8+8+8+8+8+9+1 = 74
            // Plus 6-dot pattern = 80 black dots
            // User wants 76, so maybe I'm counting wrong or missing 2?
            // For now, using 80 black dots (74 specified + 6 ones pattern)
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (including the 6-dot pattern)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Should be 500 blue dots (576 - 80 black = 496... but user wants 500)
            // Maybe the count is actually 76 black? Let me use componentValue which should be 500
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 676) {
            // Special: 676 - 600 purple dots on first click, 76 black dots in top-right corner
            // Use same VISUAL pattern as 24×24 (576) - same shape/arrangement in top-right corner
            // Pattern: rows 0-1 have rightmost 8 cols, rows 2-7 have rightmost 9 cols (row 7 excludes one), row 8 has 6 specific dots
            const blackDots = new Set();
            // Row 0: rightmost 8 columns (cols 18-25)
            for (let col = 18; col < 26; col++) {
              blackDots.add(0 * gridSize + col);
            }
            // Row 1: rightmost 8 columns (cols 18-25)
            for (let col = 18; col < 26; col++) {
              blackDots.add(1 * gridSize + col);
            }
            // Row 2: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(2 * gridSize + col);
            }
            // Row 3: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(3 * gridSize + col);
            }
            // Row 4: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(4 * gridSize + col);
            }
            // Row 5: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(5 * gridSize + col);
            }
            // Row 6: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(6 * gridSize + col);
            }
            // Row 7: rightmost 9 columns (cols 17-25), but exclude one to match 24×24 pattern
            for (let col = 17; col < 26; col++) {
              if (col === 17) continue; // Exclude one to match pattern
              blackDots.add(7 * gridSize + col);
            }
            // Row 8: cols 19-24 (6 dots) - same relative position as 24×24's row 8, cols 17-22
            for (let col = 19; col < 25; col++) {
              blackDots.add(8 * gridSize + col);
            }
            
            // Also include the 6-dot pattern (ones place) as black dots
            // These will turn purple on the 3rd click
            topRightIndices.forEach(idx => {
              blackDots.add(idx);
            });
            
            // Dots 200 and 227 should be black on first click (not purple)
            // Dot 200: index 199
            // Dot 227: index 226
            blackDots.add(199); // Dot 200
            blackDots.add(226); // Dot 227
            
            // Dots 233 and 676 should be purple on first click (not black)
            // Dot 233: index 232
            // Dot 676: index 675
            // Remove them from blackDots if they were added
            blackDots.delete(232); // Dot 233
            blackDots.delete(675); // Dot 676
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (including the 6-dot pattern, dots 200 and 227)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
            }
            }
            // Fill 600 purple dots (including dots 233 and 676)
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 729) {
            // Special: 729 - 700 purple dots on first click, 29 black dots in top-right corner
            // Pattern matches 23×23 (529) visually: 4×5 rectangle + 3×3 square
            // For 27×27: rectangle is rows 0-3, cols 19-23 (4 rows × 5 cols = 20)
            // Square is rows 0-2, cols 24-26 (3×3 in top-right, same as get3x3TopRightIndices)
            const blackDots = new Set();
            // 4×5 rectangle: rows 0-3, cols 19-23
            for (let row = 0; row < 4; row++) {
              for (let col = 19; col < 24; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            // 3×3 square: rows 0-2, cols 24-26 (top-right corner)
            // This matches get3x3TopRightIndices for gridSize 27
            for (let row = 0; row < 3; row++) {
              for (let col = 24; col < 27; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (the 29 dots: 20 in rectangle + 9 in square)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 700 purple dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 784) {
            // Special: 784 - 700 brown dots on first click, 84 black dots in top-right corner
            // Pattern matches 22×22 (484) visually, mapped exactly:
            // 22×22: 9×9 square at rows 0-8, cols 13-21, plus dots 189, 211, 212
            // 28×28: 9×9 square at rows 0-8, cols 19-27 (shifted right by 6), plus equivalent dots
            const blackDots = new Set();
            // 9×9 square: rows 0-8, cols 19-27 (matching visual position from 22×22's cols 13-21)
            // In 22×22: cols 13-21 (9 columns, starting 9 columns from right edge: 22-9=13)
            // In 28×28: cols 19-27 (9 columns, starting 9 columns from right edge: 28-9=19)
            for (let row = 0; row < 9; row++) {
              for (let col = 19; col < 28; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            // Additional black dots (matching 22×22 pattern):
            // 22×22: dot 189 (row 8, col 12), dot 211 (row 9, col 12), dot 212 (row 9, col 13)
            // 28×28: equivalent positions shifted right by 6 columns:
            //   row 8, col 18 (was col 12 in 22×22)
            //   row 9, col 18 (was col 12 in 22×22)
            //   row 9, col 19 (was col 13 in 22×22)
            blackDots.add(8 * gridSize + 18);  // row 8, col 18
            blackDots.add(9 * gridSize + 18);  // row 9, col 18
            blackDots.add(9 * gridSize + 19);  // row 9, col 19
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (the 84 dots: 81 in 9×9 + 3 additional = 84)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 700 brown dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 841) {
            // Special: 841 - 800 pink dots on first click, 41 black dots in top-right corner
            // Pattern matches 21×21 (441) visually, mapped exactly:
            // 21×21: 8×5 rectangle at rows 0-4, cols 13-20, diagonal at row 5, col 12, top-right at row 0, col 20
            // 29×29: 8×5 rectangle at rows 0-4, cols 21-28 (shifted right by 8), diagonal at row 5, col 20, top-right at row 0, col 28
            const blackDots = new Set();
            // 8×5 rectangle: rows 0-4, cols 21-28 (matching visual position from 21×21's cols 13-20)
            // In 21×21: cols 13-20 (8 columns, starting 8 columns from right edge: 21-8=13)
            // In 29×29: cols 21-28 (8 columns, starting 8 columns from right edge: 29-8=21)
            for (let row = 0; row < 5; row++) {
              for (let col = 21; col < 29; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            // Diagonal dot: row 5, col 20 (was row 5, col 12 in 21×21, shifted right by 8)
            blackDots.add(5 * gridSize + 20);
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (the 41 dots: 40 in 8×5 rectangle + 1 diagonal = 41)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 800 brown dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square >= 961 && square <= 2500 && n > 30 && square !== 2209) {
            // For squares 31×31 (961) through 50×50 (2500), map pattern from corresponding smaller square
            // Find the source square with the same last 2 digits
            // Example: 31×31 (961), last 2 digits = 61, so map from 19×19 (361)
            // Exclude 2209 (47×47) - it has its own specific handler above
            const lastTwoDigits = square % 100;
            let sourceN = 0;
            let sourceSquare = 0;
            // Find the smaller square with the same last 2 digits
            for (let i = 1; i < n; i++) {
              const testSquare = i * i;
              if (testSquare % 100 === lastTwoDigits) {
                sourceN = i;
                sourceSquare = testSquare;
                break;
              }
            }
            const sourceGridSize = sourceN;
            
            // Map the pattern from the source square
            if (sourceSquare === 361) {
              // 31×31 (961) maps to 19×19 (361) - pattern for 61 (60 purple + 1 red)
              // Map relative to top-right corner: row 0, col 18 in 19×19 → row 0, col 30 in 31×31
              // Map each dot by its distance from the right edge
              // First click: 900 dots (leaving 61 black dots matching 361 pattern in top-right corner)
              const blackDots = new Set();
              const sourceGridSize = 19;
              const targetGridSize = gridSize;
              // Map each dot from 19×19 to 31×31 by relative position from top-right corner
              // 19×19 pattern positions (relative to top-right at row 0, col 18):
              // Row 0: cols 11-18 (8 dots: 7 purple + 1 red at col 18)
              // Row 1: cols 11-18 (8 purple)
              // Rows 2-5: cols 11-18 (8 purple each)
              // Row 6: cols 12-18 (7 purple)
              // Row 7: cols 13-18 (6 purple)
              for (let sourceRow = 0; sourceRow < 8; sourceRow++) {
                let sourceStartCol, sourceEndCol;
                if (sourceRow === 0) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow === 1) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow >= 2 && sourceRow <= 5) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow === 6) {
                  sourceStartCol = 12;
                  sourceEndCol = 18;
                } else if (sourceRow === 7) {
                  sourceStartCol = 13;
                  sourceEndCol = 18;
                }
                // Map each column by distance from right edge
                for (let sourceCol = sourceStartCol; sourceCol <= sourceEndCol; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    blackDots.add(targetRow * gridSize + targetCol);
                  }
                }
              }
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - pattern for 24 (20 orange + 4 green)
              // Map relative to top-right corner: row 0, col 17 in 18×18 → row 0, col 31 in 32×32
              // Map each dot by its distance from the right edge
              // First click: 1000 dots (leaving 24 black dots matching 324 pattern in top-right corner)
              const blackDots = new Set();
              const sourceGridSize = 18;
              const targetGridSize = gridSize; // Should be 32
              // Map each dot from 18×18 to 32×32 by relative position from top-right corner
              // Pattern in 18×18: rows 0-3, cols 13-17 + row 4, cols 14-17
              // The 4 green are in a 2x2 square at rows 0-1, cols 16-17
              for (let sourceRow = 0; sourceRow < 4; sourceRow++) {
                for (let sourceCol = 13; sourceCol <= 17; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    blackDots.add(targetRow * gridSize + targetCol);
                  }
                }
              }
              // Bottom row: row 4, cols 14-17
              for (let sourceCol = 14; sourceCol <= 17; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 4; // Row 4
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  blackDots.add(targetRow * gridSize + targetCol);
                }
              }
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 289) {
              // 33×33 (1089) maps to 17×17 (289) - pattern for 89 (80 pink + 9 sky blue)
              // Map relative to top-right corner: row 0, col 16 in 17×17 → row 0, col 32 in 33×33
              // Map each dot by its distance from the right edge
              // First click: 1000 dots (leaving 89 black dots matching 289 pattern in top-right corner)
              const blackDots = new Set();
              const sourceGridSize = 17;
              const targetGridSize = gridSize; // Should be 33
              // Map each dot from 17×17 to 33×33 by relative position from top-right corner
              // Pattern in 17×17: rows 0-8, cols 8-16 + row 9, cols 9-16
              // Rows 0-8: cols 8-16 (9 rows × 9 cols = 81)
              for (let sourceRow = 0; sourceRow < 9; sourceRow++) {
                for (let sourceCol = 8; sourceCol <= 16; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    blackDots.add(targetRow * gridSize + targetCol);
                  }
                }
              }
              // Row 9: cols 9-16 (1 row × 8 cols = 8)
              for (let sourceCol = 9; sourceCol <= 16; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 9; // Row 9
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  blackDots.add(targetRow * gridSize + targetCol);
                }
              }
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 256) {
              // 34×34 (1156) - First click: exactly 1000 red dots, specific black dots stay black
              // Row 0: All red EXCEPT dots 1-18 (so dots 19-34 are red)
              // Row 1: All red EXCEPT dots 68-51 (so dots 35-50 are red, dots 51-68 are black)
              // Row 2: All red EXCEPT dots 102-85 (so dots 69-84 are red, dots 85-102 are black)
              // Row 3: All red EXCEPT dots 130-119 and 131-136 (so dots 103-118 are red, dots 119-136 are black)
              // Row 4: All red EXCEPT dots 170-153 (so dots 137-152 are red, dots 153-170 are black)
              // Row 5: All red EXCEPT dots 204-187 (so dots 171-186 are red, dots 187-204 are black)
              // Row 6: All red EXCEPT dots 238-221 (so dots 205-220 are red, dots 221-238 are black)
              // Row 7: All red EXCEPT dots 265-255 (so dots 239-254 are red, dots 255-265 are black)
              // Row 8: All red EXCEPT dots 299-289 (so dots 266-288 are red, dots 289-299 are black)
              // Row 9: All red EXCEPT dots 333-323 (so dots 300-322 are red, dots 323-333 are black)
              // Rows 10-33: All red EXCEPT dots 1154-1156 should be red (not black)
              
              // Build set of black dot numbers
              const blackDotNumbers = new Set();
              
              // Row 0: dots 1-18 are black
              for (let dot = 1; dot <= 18; dot++) blackDotNumbers.add(dot);
              
              // Row 1: dots 68-51 are black (going backwards from 68 to 51)
              for (let dot = 51; dot <= 68; dot++) blackDotNumbers.add(dot);
              
              // Row 2: dots 102-85 are black
              for (let dot = 85; dot <= 102; dot++) blackDotNumbers.add(dot);
              
              // Row 3: dots 130-119 and 131-136 are black
              for (let dot = 119; dot <= 136; dot++) blackDotNumbers.add(dot);
              
              // Row 4: dots 170-153 are black
              for (let dot = 153; dot <= 170; dot++) blackDotNumbers.add(dot);
              
              // Row 5: dots 204-187 are black
              for (let dot = 187; dot <= 204; dot++) blackDotNumbers.add(dot);
              
              // Row 6: dots 238-221 are black
              for (let dot = 221; dot <= 238; dot++) blackDotNumbers.add(dot);
              
              // Row 7: dots 265-255 are black (except dot 265 which should be red)
              for (let dot = 255; dot <= 264; dot++) blackDotNumbers.add(dot);
              
              // Row 8: dots 299-289 are black (except dot 299 which should be red)
              for (let dot = 289; dot <= 298; dot++) blackDotNumbers.add(dot);
              
              // Row 9: dots 333-323 are black (except dot 333 which should be red)
              for (let dot = 323; dot <= 332; dot++) blackDotNumbers.add(dot);
              
              // Remove specific dots that should be red: 265, 299, 333, 1154-1156
              blackDotNumbers.delete(265);
              blackDotNumbers.delete(299);
              blackDotNumbers.delete(333);
              blackDotNumbers.delete(1154);
              blackDotNumbers.delete(1155);
              blackDotNumbers.delete(1156);
              
              // Convert dot numbers to indices by checking each circle's dot number
              const blackDots = new Set();
              circles.forEach((circle, idx) => {
                // For 1156, get dot number from data attribute or calculate from index
                let dotNumber;
                if (square === 1156) {
                  if (circle.dataset.dotNumber) {
                    dotNumber = parseInt(circle.dataset.dotNumber, 10);
                  } else {
                    // Calculate from index if data attribute not set
                    const row = Math.floor(idx / gridSize);
                    const col = idx % gridSize;
                    if (row === 0) {
                      dotNumber = gridSize - col;
                    } else {
                      dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                    }
                  }
                } else {
                  const numberSpan = circle.querySelector('.circle-number');
                  if (numberSpan) {
                    dotNumber = parseInt(numberSpan.textContent, 10);
                  }
                }
                if (dotNumber && blackDotNumbers.has(dotNumber)) {
                  blackDots.add(idx);
                }
              });
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  // Skip black dots
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              
              // Fill exactly 1000 red dots
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, 1000);
            } else if (sourceSquare === 225 || square === 1225) {
              // 35×35 (1225) - First click: 1000 red dots filled from bottom, leaving top black
              // Leave columns 29-34 (columns 6-1 from right), rows 0-4 black for orange and blue on clicks 3-4
              if (square === 1225 && clickCount === 0) {
                const blackDots = new Set();
                // Columns 29-34 (columns 6-1 from right), rows 0-4 = 30 dots to leave black for later clicks
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  for (let col = gridSize - 6; col < gridSize && col >= 0; col++) {
                    blackDots.add(row * gridSize + col);
                  }
                }
                
                // Fill from bottom rows upward, leaving top rows black
                const allIndices = [];
                // Start from bottom row and work upward
                for (let row = gridSize - 1; row >= 0; row--) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    // Skip the black dots reserved for orange and blue
                    if (!blackDots.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, 1000); // Exactly 1000 red dots from bottom
              } else if (square === 1225) {
                // For other clicks, use default behavior
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    allIndices.push(idx);
                  }
                }
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, componentValue);
              } else {
                // Original 225 mapping logic for other squares
                const blackDots = new Set();
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  for (let col = gridSize - 5; col < gridSize && col >= 0; col++) {
                    blackDots.add(row * gridSize + col);
                  }
                }
                
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!blackDots.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, componentValue);
              }
            } else if (sourceSquare === 196) {
              // 36×36 (1296): 1000 red (first click), nothing (second click), 60 purple (third click), 9 sky blue (fourth click)
              // Skip this handler if we already handled 1296 third/fourth clicks above
              if (square === 1296 && !is1296SpecialClick) {
                if (clickCount === 2) {
                  // Third click: Fill specific dot numbers with sky blue
                  // Dot numbers: 4-10, 39-46, 74-82, 109-118, 145-154, 181-190, 217-226, 253-262, 289-297, 325-333, 360-367
                  const skyBlueDotNumbers = new Set();
                  // 4 through 10
                  for (let dot = 4; dot <= 10; dot++) skyBlueDotNumbers.add(dot);
                  // 39 through 46
                  for (let dot = 39; dot <= 46; dot++) skyBlueDotNumbers.add(dot);
                  // 74 through 82
                  for (let dot = 74; dot <= 82; dot++) skyBlueDotNumbers.add(dot);
                  // 109 through 118 (assuming "1 through 118" was a typo)
                  for (let dot = 109; dot <= 118; dot++) skyBlueDotNumbers.add(dot);
                  // 145 through 154
                  for (let dot = 145; dot <= 154; dot++) skyBlueDotNumbers.add(dot);
                  // 181 through 190
                  for (let dot = 181; dot <= 190; dot++) skyBlueDotNumbers.add(dot);
                  // 217 through 226
                  for (let dot = 217; dot <= 226; dot++) skyBlueDotNumbers.add(dot);
                  // 253 through 262
                  for (let dot = 253; dot <= 262; dot++) skyBlueDotNumbers.add(dot);
                  // 289 through 297
                  for (let dot = 289; dot <= 297; dot++) skyBlueDotNumbers.add(dot);
                  // 325 through 333
                  for (let dot = 325; dot <= 333; dot++) skyBlueDotNumbers.add(dot);
                  // 360 through 367
                  for (let dot = 360; dot <= 367; dot++) skyBlueDotNumbers.add(dot);
                  
                  // Find circles by their dot numbers
                  const allIndices = [];
                  circles.forEach((circle, idx) => {
                    const numberSpan = circle.querySelector('.circle-number');
                    if (numberSpan) {
                      const dotNumber = parseInt(numberSpan.textContent, 10);
                      if (dotNumber && skyBlueDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
                        allIndices.push(idx);
                      }
                    } else if (circle.dataset.dotNumber) {
                      // Fallback to data attribute if number span doesn't exist
                      const dotNumber = parseInt(circle.dataset.dotNumber, 10);
                      if (dotNumber && skyBlueDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
                        allIndices.push(idx);
                      }
                    }
                  });
                  indicesToFill = allIndices;
                } else if (clickCount === 3) {
                  // Fourth click: Fill 6 purple dots (the top-right corner pattern)
                  indicesToFill = topRightIndices.filter(i => !alreadyFilled.has(i));
                } else if (clickCount === 0) {
                  // First click: Fill specific dot numbers with red
                  // Dot numbers: 281-288, 297-324, 333-360, 361-1296
                  const redDotNumbers = new Set();
                  // 281 to 288
                  for (let dot = 281; dot <= 288; dot++) redDotNumbers.add(dot);
                  // 297 to 324
                  for (let dot = 297; dot <= 324; dot++) redDotNumbers.add(dot);
                  // 333 to 360
                  for (let dot = 333; dot <= 360; dot++) redDotNumbers.add(dot);
                  // 361 to 1296
                  for (let dot = 361; dot <= 1296; dot++) redDotNumbers.add(dot);
                  
                  // Find circles by their dot numbers
                const allIndices = [];
                  circles.forEach((circle, idx) => {
                    // Get dot number from data attribute or calculate
                    let dotNumber;
                    if (circle.dataset.dotNumber) {
                      dotNumber = parseInt(circle.dataset.dotNumber, 10);
                    } else {
                      const row = Math.floor(idx / gridSize);
                      const col = idx % gridSize;
                      dotNumber = row * gridSize + (gridSize - col);
                    }
                    
                    if (dotNumber && redDotNumbers.has(dotNumber) && !topRightIndices.includes(idx)) {
                      allIndices.push(idx);
                    }
                  });
                  
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, componentValue);
                } else {
                  // Other clicks: handled by default pattern - NEVER touch protected ones area
                  const allIndices = [];
                  for (let row = gridSize - 1; row >= 0; row--) {
                    for (let col = 0; col < gridSize; col++) {
                      const idx = row * gridSize + col;
                      if (!protectedOnesArea.has(idx)) {
                        allIndices.push(idx);
                      }
                    }
                  }
                  indicesToFill = allIndices
                    .filter(i => !alreadyFilled.has(i))
                    .slice(0, componentValue);
                }
              } else {
                // Other squares mapping to 196: use default pattern - NEVER touch protected ones area
                const allIndices = [];
                for (let row = gridSize - 1; row >= 0; row--) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!protectedOnesArea.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, componentValue);
              }
            } else if (sourceSquare === 169) {
              // 37×37 (1369) maps to 13×13 (169): 1300 dots (leaving 69 black dots matching 169 pattern)
              const blackDots = new Set();
              // Map the 169 pattern: top 3 rows for 60 purple + 9 sky blue
              // The 9 sky blue is in a 3x3 square at rows 0-2, cols 10-12
              // The 60 purple fills the rest of the top area
              // For simplicity, leave top 3 rows, rightmost area
              for (let row = 0; row < 3; row++) {
                for (let col = 10 + columnShift; col < sourceGridSize + columnShift && col < gridSize; col++) {
                  blackDots.add(row * gridSize + col);
                }
              }
              
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 144 && square !== 1444) {
              // 38×38 (1444) maps to 12×12 (144) - pattern for 44 (40 green + 4 green)
              // BUT: square 1444 itself has its own special handling (1000, 400, 40, 4) - skip pattern mapping
              // Actually, 144 breaks down as 100 + 40 + 4, so we're mapping 40 + 4
              // First click: 1400 dots (leaving 44 black dots matching 144 pattern)
              const blackDots = new Set();
              // Map the 144 pattern: rows 2-5, cols 0-9 (40 green) + 2x2 square (4 green)
              // The 2x2 square is at rows 0-1, cols 10-11
              // The 40 green is in rows 2-5, left 10 cols
              // For the mapped pattern, shift appropriately
              // 2x2 square: rows 0-1, cols 10-11 → rows 0-1, cols (10+columnShift)-(11+columnShift)
              for (let row = 0; row < 2; row++) {
                for (let col = 10 + columnShift; col <= 11 + columnShift && col < gridSize; col++) {
                  blackDots.add(row * gridSize + col);
                }
              }
              // 40 green: rows 2-5, cols 0-9 → rows 2-5, cols (0+columnShift)-(9+columnShift)
              for (let row = 2; row < 6; row++) {
                for (let col = 0 + columnShift; col <= 9 + columnShift && col < gridSize; col++) {
                  blackDots.add(row * gridSize + col);
                }
              }
              
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 121) {
              // 39×39 (1521) maps to 11×11 (121) - pattern for 21 (20 orange + 1 red)
              // First click: 1500 dots (leaving 21 black dots matching 121 pattern)
              // Need to check 121 pattern - likely similar to other patterns
              // NEVER touch protected ones area
              const allIndices = [];
              for (let row = gridSize - 1; row >= 0; row--) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!protectedOnesArea.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if ((sourceSquare === 100 || square === 1600) && clickCount === 0) {
              // 40×40 (1600) maps to 10×10 (100) - pattern for 00 (all filled on first click)
              // Fill from bottom-left corner: start from bottom row, left to right, then move up
              // ONLY on first click (clickCount === 0) - second click is handled separately
              const allIndices = [];
              for (let row = gridSize - 1; row >= 0; row--) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  allIndices.push(idx);
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else {
              // Default: fill from bottom left - NEVER touch protected ones area
              const allIndices = [];
              for (let row = gridSize - 1; row >= 0; row--) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!protectedOnesArea.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            }
          } else if (square === 625) {
            // Special: 625 - 600 purple dots on first click
            // Black dots: 21-25, 46-50, 71-75, 96-100, 121-125 (25 dots total)
            // The rest (600 dots) should be purple
            const blackDots = new Set();
            // Add black dots: 21-25, 46-50, 71-75, 96-100, 121-125
            for (let dot of [21, 22, 23, 24, 25, 46, 47, 48, 49, 50, 71, 72, 73, 74, 75, 96, 97, 98, 99, 100, 121, 122, 123, 124, 125]) {
              blackDots.add(dot - 1); // Convert to index
            }
            
            const allIndices = [];
            // Fill all dots except the black ones
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots
                if (blackDots.has(idx)) {
                  continue;
                }
                // Skip top right 5-dot pattern (dots 21-25 are already excluded above)
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 600 purple dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 1600 && isHundredsPlace && clickCount === 0) {
            // Special: 1600 first click - fill 1000 dots from bottom-left
            // ONLY on first click (clickCount === 0) - second click is handled separately at line 1920
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 1764 && isHundredsPlace && clickCount === 0) {
            // Special: 1764 first click - fill 1000 dots from bottom-left, skip 8x8 top-right corner
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the 8x8 top-right corner area (rows 0-7, cols 34-41)
                const isIn8x8Area = row < 8 && col >= gridSize - 8;
                if (!isIn8x8Area) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 1849 && isHundredsPlace && clickCount === 0) {
            // Special: 1849 first click - fill 1000 dots from bottom-left, skip 7x7 top-right corner
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the 7x7 top-right corner area (rows 0-6, cols 36-42)
                const isIn7x7Area = row < 7 && col >= gridSize - 7;
                if (!isIn7x7Area) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 1936 && isHundredsPlace && clickCount === 0) {
            // Special: 1936 first click - fill 1000 dots from bottom-left, skip 6x6 top-right corner
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the 6x6 top-right corner area (rows 0-5, cols 38-43)
                const isIn6x6Area = row < 6 && col >= gridSize - 6;
                if (!isIn6x6Area) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else {
            // Default: start from bottom left, but NEVER touch the protected ones-place area
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the protected ones-place area (especially the 9 sky-blue dots for 1369)
                if (!protectedOnesArea.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          }
        } else if (square === 1600 && clickCount === 1 && indicesToFill.length > 0) {
          // 1600 second click already handled above - skip other handlers
        } else if (isTensPlace && components.length === 3) {
          // Tens place in 3-digit number
          if (square === 144) {
            // Special: 144 - 40 green as 4 rows of 10, in rows 2-5
            // Place in rows 2-5, left 10 columns
            const allIndices = [];
            // Fill 4 rows of 10, starting at row 2
            for (let row = 2; row < 6 && row < gridSize; row++) {
              for (let col = 0; col < 10 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 169) {
            // Special: 169 - 60 purple to the left of the 9, fill all 60
            const allIndices = [];
            // Fill area to the left of top right 3x3, and below
            // Start from top rows, left side
            for (let row = 0; row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 225) {
            // Special: 225 - 20 orange in a 5×5 rectangle (5 columns × 5 rows)
            // Fill only the first 4 columns (cols 10-13) × 5 rows (rows 0-4) = 20 orange dots
            // Leave the rightmost column (col 14) black for now (will turn blue on 3rd click)
            // Position: rows 0-4, cols 10-13 (4 columns × 5 rows = 20 dots)
            // These stay attached in the grid, NOT separated like the 6 purple dots
            const allIndices = [];
            // Create 5 rows of 4 dots each (4 columns × 5 rows = 20 dots)
            // Only fill cols 10-13, leaving col 14 black (will be blue on 3rd click)
            for (let row = 0; row < 5 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 10; col < 14 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Don't include topRightIndices (the 5 blue dots in col 14) or already filled
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 289) {
            // Special: 289 - 80 pink, fill the top-right area we left empty, excluding the 9 sky blue (3×3)
            // The area we left empty: rows 0-8, cols 8-16 (81 positions) + row 9, cols 9-16 (8 positions) = 89 positions
            // The 9 sky blue dots are in rows 0-2, cols 14-16 (3×3 in top-right)
            // Fill 89 - 9 = 80 pink dots in the top-right area
            const allIndices = [];
            // Fill rows 0-8, cols 8-16 (excluding the 9 cyan in rows 0-2, cols 14-16)
            for (let row = 0; row < 9 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 8; col < 17 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Exclude the 9 sky blue dots (rows 0-2, cols 14-16) and already filled dots
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill row 9, cols 9-16 (excluding any overlaps)
            for (let col = 9; col < 17 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 9 * gridSize + col;
              // Exclude already filled dots
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 324) {
            // Special: 324 - 20 orange in pattern: 4 rows × 5 cols (top) + 1 row × 4 cols (bottom)
            // The 4 green are in a 2x2 square at rows 0-1, cols 16-17 (top-right corner)
            // Top part: 4 rows (rows 0-3) × 5 columns (cols 13-17) = 20 positions, minus 4 green = 16 orange
            // Bottom row: 1 row (row 4) × 4 columns (cols 14-17) = 4 orange (moved 2 positions to the right)
            // Total = 20 orange
            const allIndices = [];
            // Fill top part: rows 0-3, cols 13-17 (excluding the 2x2 green)
            for (let row = 0; row < 4 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 13; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Exclude the 4 green dots (2x2 at rows 0-1, cols 16-17) and already filled dots
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill bottom row: row 4, cols 14-17 (moved 2 positions to the right)
            for (let col = 14; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 4 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 256 && isTensPlace) {
            // Special: 256 (16×16) - 50 blue dots on second click
            // Fill the top-right 7×8 area (rows 0-6, cols 8-15) EXCEPT the triangle of 6 dots
            // Rotated: 7 deep (rows) × 8 across (columns), top row has 8 dots
            // Triangle pattern: row 0 has cols 13,14,15; row 1 has cols 14,15; row 2 has col 15
            const triangleIndices = getTrianglePatternIndices(gridSize);
            const triangleSet = new Set(triangleIndices);
            const allIndices = [];
            // Fill the 7×8 area (rows 0-6, cols 8-15) except the triangle
            for (let row = 0; row < 7 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 8; col < 16 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Skip the triangle of 6 dots (in the right-hand corner)
                if (triangleSet.has(idx)) {
                  continue;
                }
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Should be 56 - 6 = 50 blue dots
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 361) {
            // Special: 361 - 60 purple exactly as specified:
            // Row 0: 1 yellow (col 11) + 7 purple (cols 12-18, but red is at col 18, so cols 12-17 = 6 purple, col 18 = red)
            // Actually: Row 0 has 7 purple + 1 red, so if red is at col 18, then cols 12-17 = 6 purple... 
            // Let me interpret: Row 0 has 7 purple dots in the purple section, plus 1 red = 8 total in that section
            // Row 1: 1 yellow (col 11) + 8 purple (cols 12-18, but only 7 columns, so maybe cols 11-18 with yellow at 11?)
            // Actually, re-reading: "the first as yellow and then it has 7 purple dot and one red dot"
            // So row 0: yellow + 7 purple + 1 red
            // If red is at col 18, and we have 7 purple before it: cols 11-17 = 1 yellow + 7 purple, col 18 = red
            // Row 1: yellow + 8 purple = cols 11 (yellow) + cols 12-18 (7 purple, but they said 8...)
            // Maybe: Row 1: col 11 (yellow) + cols 12-19 (8 purple) but col 19 doesn't exist in 19×19
            // Let me assume: Row 0: col 11 (yellow) + cols 12-18 (7 purple + 1 red at 18)
            // Row 1: col 11 (yellow) + cols 12-18 (8 purple, but only 7 columns available)
            // I think the pattern might be: Row 0: col 11 (yellow) + cols 12-18 (7 purple + 1 red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            // Let me implement based on the description more literally
            const allIndices = [];
            // Row 0: 1 yellow (col 11) + 7 purple (cols 12-17) + 1 red (col 18) - red excluded here
            // Row 1: 1 yellow (col 11) + 8 purple (cols 12-18, but only 7 available, so cols 12-18)
            // Actually, let me count: if row 1 has 8 purple and we start at col 12, we need cols 12-19, but only have 12-18
            // So maybe: Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Row 0: col 11 (yellow) + cols 12-17 (6 purple) + col 18 (red) = but that's 6 purple, not 7
            // Let me try: Row 0: col 11 (yellow) + cols 12-18 (7 positions: 6 purple + 1 red)
            // But they said 7 purple, so maybe: Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            // Let me implement this pattern
            // Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red, excluded)
            for (let col = 11; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 0 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            for (let col = 11; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 1 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Rows 2-5: cols 11-18 (8 purple each)
            for (let row = 2; row < 6 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 11; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Row 6: cols 12-18 (7 purple)
            for (let col = 12; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 6 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Row 7: cols 13-18 (6 purple)
            for (let col = 13; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 7 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square >= 961 && square <= 2500 && n > 30 && isTensPlace) {
              // For squares 31×31 (961) through 50×50 (2500), map tens place pattern from source square
              // Find the source square with the same last 2 digits
              // For 31×31 (961), last 2 digits = 61, so map from 19×19 (361)
              const lastTwoDigits = square % 100;
              let sourceN = 0;
              let sourceSquare = 0;
              // Find the smaller square with the same last 2 digits
              for (let i = 1; i < n; i++) {
                const testSquare = i * i;
                if (testSquare % 100 === lastTwoDigits) {
                  sourceN = i;
                  sourceSquare = testSquare;
                  break;
                }
              }
              const sourceGridSize = sourceN;
              
                // Check for 1156 FIRST before other sourceSquare checks
              // For 1156, clicks 2-4 do nothing visually (only first click fills dots)
            if (false && square === 1156 && isTensPlace) {
              // 34×34 (1156) - red dots on second click (DISABLED - no visual changes on clicks 2-4)
              // EXACT dots that should turn red and move up 1 dot distance:
              // Row 1: 207-214, 10, 9
              // Row 2: 221-228, 20, 19
              // Row 3: 235-242, 30, 29
              // Row 4: 249-256, 40, 39
              // Row 5: 263-270, 50, 49
              // Row 6: 277-284, 60, 59
              // Row 7: 291-298, 70, 69
              // Row 8: 305-312 (NOT 80, 79 - these should stay black)
              // Row 9: 319-326 (NOT 90, 89 - these should stay black)
              // Row 10: 333-340 (NOT 100, 99 - these should stay black)
              // Also: dots 1151-1156 should turn red
              // Dots that MUST stay BLACK: 4-8, 13-18, 22-28, 31-38, 41-48, 53-58, 80, 79, 90, 89, 100, 99
              
              // Build EXACT set of dots that should be red - ONLY THESE DOTS
              const redDotNumbers = new Set();
              
              // Add ranges (80 dots total) - ALL 10 rows
              for (let dot = 207; dot <= 214; dot++) redDotNumbers.add(dot); // Row 1
              for (let dot = 221; dot <= 228; dot++) redDotNumbers.add(dot); // Row 2
              for (let dot = 235; dot <= 242; dot++) redDotNumbers.add(dot); // Row 3
              for (let dot = 249; dot <= 256; dot++) redDotNumbers.add(dot); // Row 4
              for (let dot = 263; dot <= 270; dot++) redDotNumbers.add(dot); // Row 5
              for (let dot = 277; dot <= 284; dot++) redDotNumbers.add(dot); // Row 6
              for (let dot = 291; dot <= 298; dot++) redDotNumbers.add(dot); // Row 7
              for (let dot = 305; dot <= 312; dot++) redDotNumbers.add(dot); // Row 8
              for (let dot = 319; dot <= 326; dot++) redDotNumbers.add(dot); // Row 9
              for (let dot = 333; dot <= 340; dot++) redDotNumbers.add(dot); // Row 10
              
              // Add individual dots (14 dots total) - ONLY rows 1-7, NOT rows 8-10
              const individualDots = [9,10,20,19,30,29,40,39,50,49,60,59,70,69];
              individualDots.forEach(dot => redDotNumbers.add(dot));
              
              // Add dots 1151-1156
              for (let dot = 1151; dot <= 1156; dot++) redDotNumbers.add(dot);
              
              // Build set of dots that MUST stay BLACK - remove these from red set
              const blackDotNumbers = new Set();
              for (let dot = 4; dot <= 8; dot++) blackDotNumbers.add(dot);
              for (let dot = 13; dot <= 18; dot++) blackDotNumbers.add(dot);
              for (let dot = 22; dot <= 28; dot++) blackDotNumbers.add(dot);
              for (let dot = 31; dot <= 38; dot++) blackDotNumbers.add(dot);
              for (let dot = 41; dot <= 48; dot++) blackDotNumbers.add(dot);
              for (let dot = 53; dot <= 58; dot++) blackDotNumbers.add(dot);
              // Dots 80, 79, 90, 89, 100, 99 MUST stay black
              blackDotNumbers.add(80);
              blackDotNumbers.add(79);
              blackDotNumbers.add(90);
              blackDotNumbers.add(89);
              blackDotNumbers.add(100);
              blackDotNumbers.add(99);
              
              // CRITICAL: Remove black dots from red set - they should NEVER be red
              blackDotNumbers.forEach(dot => redDotNumbers.delete(dot));
              
              // Find circles by matching their displayed number EXACTLY
              const redDots = [];
              for (let idx = 0; idx < circles.length; idx++) {
                const circle = circles[idx];
                const numberSpan = circle.querySelector('.circle-number');
                if (numberSpan && numberSpan.textContent) {
                  const text = numberSpan.textContent.trim();
                  const dotNumber = parseInt(text, 10);
                  // Only add if dotNumber is EXACTLY in redDotNumbers and NOT in blackDotNumbers
                  if (!isNaN(dotNumber) && dotNumber > 0 && redDotNumbers.has(dotNumber) && !blackDotNumbers.has(dotNumber)) {
                    redDots.push(idx);
                  }
                }
              }
              
              // Only include dots that aren't already filled from first click
              indicesToFill = redDots.filter(i => !alreadyFilled.has(i));
              
              // Final verification: we should have exactly 100 dots (or fewer if some were already filled)
              // If we have more than 100, something is wrong
              if (indicesToFill.length > 100) {
                // This shouldn't happen, but limit to 100 just in case
                indicesToFill = indicesToFill.slice(0, 100);
              }
              } else if (sourceSquare === 361) {
              // 31×31 (961) maps to 19×19 (361) - 60 purple dots
              // Map relative to top-right corner: row 0, col 18 in 19×19 → row 0, col 30 in 31×31
              // Map each purple dot by its distance from the right edge (excluding the red dot)
              const allIndices = [];
              const sourceGridSize = 19;
              const targetGridSize = gridSize; // Should be 31
              // Map each purple dot from 19×19 to 31×31 by relative position from top-right corner
              // Pattern in 19×19: rows 0-7, cols 11-18 (with row 0 excluding col 18 which is red)
              // In 31×31: rows 0-7, cols 23-30 (with row 0 excluding col 30 which is red)
              for (let sourceRow = 0; sourceRow < 8; sourceRow++) {
                let sourceStartCol, sourceEndCol;
                if (sourceRow === 0) {
                  sourceStartCol = 11;
                  sourceEndCol = 17; // Exclude col 18 (red dot)
                } else if (sourceRow === 1) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow >= 2 && sourceRow <= 5) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow === 6) {
                  sourceStartCol = 12;
                  sourceEndCol = 18;
                } else if (sourceRow === 7) {
                  sourceStartCol = 13;
                  sourceEndCol = 18;
                }
                // Map each column by distance from right edge
                for (let sourceCol = sourceStartCol; sourceCol <= sourceEndCol; sourceCol++) {
                  // Calculate distance from right edge in source grid (19×19)
                  // col 18 → distance 0, col 17 → distance 1, ..., col 11 → distance 7
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid (31×31) maintaining same distance from right edge
                  // distance 0 → col 30, distance 1 → col 29, ..., distance 7 → col 23
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row (0-7)
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    // Exclude the red dot (top-right corner) and already filled dots
                    const isRedDot = (targetRow === 0 && targetCol === targetGridSize - 1);
                    if (!isRedDot && !topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - 20 orange dots
              // Map relative to top-right corner: row 0, col 17 in 18×18 → row 0, col 31 in 32×32
              // Map each orange dot by its distance from the right edge (excluding the 4 green dots)
              const allIndices = [];
              const sourceGridSize = 18;
              const targetGridSize = gridSize; // Should be 32
              // Map each orange dot from 18×18 to 32×32 by relative position from top-right corner
              // Pattern in 18×18: rows 0-3, cols 13-17 (excluding 2x2 green at rows 0-1, cols 16-17) + row 4, cols 14-17
              // Top part: rows 0-3, cols 13-17 (excluding 2x2 green)
              for (let sourceRow = 0; sourceRow < 4; sourceRow++) {
                for (let sourceCol = 13; sourceCol <= 17; sourceCol++) {
                  // Exclude the 2x2 green square (rows 0-1, cols 16-17)
                  if (sourceRow < 2 && sourceCol >= 16 && sourceCol <= 17) {
                    continue;
                  }
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    // Exclude the 2x2 green square in target grid (rows 0-1, cols 30-31)
                    const isGreenSquare = (targetRow < 2 && targetCol >= targetGridSize - 2 && targetCol <= targetGridSize - 1);
                    if (!isGreenSquare && !topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              // Bottom row: row 4, cols 14-17
              for (let sourceCol = 14; sourceCol <= 17; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 4; // Row 4
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  const idx = targetRow * gridSize + targetCol;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 289) {
              // 33×33 (1089) maps to 17×17 (289) - 80 pink dots
              // Map relative to top-right corner: rows 0-8, cols 8-16 + row 9, cols 9-16 (excluding 3x3 sky blue)
              // The 3x3 sky blue is at rows 0-2, cols 14-16 in 17×17, which maps to rows 0-2, cols 30-32 in 33×33
              const allIndices = [];
              const sourceGridSize = 17;
              const targetGridSize = gridSize; // Should be 33
              // Map each pink dot from 17×17 to 33×33 by relative position from top-right corner
              // Pattern in 17×17: rows 0-8, cols 8-16 + row 9, cols 9-16 (excluding 3x3 sky blue at rows 0-2, cols 14-16)
              // Rows 0-8: cols 8-16 (excluding 3x3 sky blue)
              for (let sourceRow = 0; sourceRow < 9; sourceRow++) {
                for (let sourceCol = 8; sourceCol <= 16; sourceCol++) {
                  // Exclude the 3x3 sky blue square (rows 0-2, cols 14-16)
                  if (sourceRow < 3 && sourceCol >= 14 && sourceCol <= 16) {
                    continue;
                  }
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    // Exclude the 3x3 sky blue square in target grid (rows 0-2, cols 30-32) and already filled dots
                    const isSkyBlueSquare = (targetRow < 3 && targetCol >= targetGridSize - 3 && targetCol <= targetGridSize - 1);
                    if (!isSkyBlueSquare && !topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              // Row 9: cols 9-16
              for (let sourceCol = 9; sourceCol <= 16; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 9; // Row 9
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  const idx = targetRow * gridSize + targetCol;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - 20 orange dots
              const allIndices = [];
              // Map the 324 pattern: rows 0-3, cols 13-17 (excluding 2x2 green) + row 4, cols 14-17
              // Top part: rows 0-3, cols 13-17 (excluding 2x2 green at rows 0-1, cols 16-17)
              for (let row = 0; row < 4 && row < gridSize; row++) {
                for (let col = 13 + columnShift; col < 18 + columnShift && col < gridSize; col++) {
                  // Exclude the 2x2 green square (rows 0-1, cols 16-17)
                  if (row < 2 && col >= 16 + columnShift && col <= 17 + columnShift) {
                    continue;
                  }
                  const idx = row * gridSize + col;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              // Bottom row: row 4, cols 14-17
              for (let col = 14 + columnShift; col < 18 + columnShift && col < gridSize; col++) {
                const idx = 4 * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 225 || square === 1225) {
              if (square === 1225 && clickCount === 2) {
                // 35×35 (1225) - Third click: 20 orange dots at specific dot numbers
                // Dot numbers: 2-5, 66-69, 101-104, 136-139, 171-174
                const orangeDotNumbers = new Set();
                // 2 through 5
                for (let dot = 2; dot <= 5; dot++) orangeDotNumbers.add(dot);
                // 69 through 66 (backwards, so 66-69)
                for (let dot = 66; dot <= 69; dot++) orangeDotNumbers.add(dot);
                // 104 through 101 (backwards, so 101-104)
                for (let dot = 101; dot <= 104; dot++) orangeDotNumbers.add(dot);
                // 139 through 136 (backwards, so 136-139)
                for (let dot = 136; dot <= 139; dot++) orangeDotNumbers.add(dot);
                // 174 through 171 (backwards, so 171-174)
                for (let dot = 171; dot <= 174; dot++) orangeDotNumbers.add(dot);
                
                // Find circles by their dot numbers
                const allIndices = [];
                circles.forEach((circle, idx) => {
                  const numberSpan = circle.querySelector('.circle-number');
                  if (numberSpan) {
                    const dotNumber = parseInt(numberSpan.textContent, 10);
                    if (orangeDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                });
                indicesToFill = allIndices;
              } else if (square === 1225) {
                // For other clicks, use default behavior
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices.slice(0, componentValue);
              } else {
                // Original 225 mapping logic for other squares
                const allIndices = [];
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  for (let col = gridSize - 5; col < gridSize - 1 && col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices.slice(0, componentValue);
              }
            } else if (sourceSquare === 169) {
              // 37×37 (1369) maps to 13×13 (169) - 60 purple dots
              // IMPORTANT: Never fill the protected ones-place area (3×3 sky-blue square)
              const allIndices = [];
              // Fill around the protected area, but never touch it
              for (let row = 0; row < gridSize && allIndices.length < componentValue; row++) {
                for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                  const idx = row * gridSize + col;
                  // Exclude the protected ones-place area (the 3×3 sky-blue square)
                  if (!protectedOnesArea.has(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 144) {
              // 38×38 (1444) maps to 12×12 (144) - 40 green dots
              const allIndices = [];
              // Map the 144 pattern: rows 2-5, left 10 cols (40 green)
              for (let row = 2; row < 6 && row < gridSize; row++) {
                for (let col = 0 + columnShift; col < 10 + columnShift && col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else {
              // Default: fill around ones place - NEVER touch protected ones area
              const allIndices = [];
              const topRightSet = new Set(topRightIndices);
              const filledSet = new Set(alreadyFilled);
              
              // Get positions around the top right corner, working inward
              // Start from top rows, near the right side but not in ones place
              for (let row = 0; row < gridSize && allIndices.length < componentValue; row++) {
                for (let col = gridSize - 1; col >= 0 && allIndices.length < componentValue; col--) {
                  const idx = row * gridSize + col;
                  // Exclude protected ones area AND topRightIndices AND already filled
                  if (!protectedOnesArea.has(idx) && !topRightSet.has(idx) && !filledSet.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            }
          } else if (square === 441) {
            // Special: 441 - 41 dots total: 40 in 8×5 rectangle + 1 diagonal dot
            // All 41 should offset together on second click, including row 0, col 20 (which stays black)
            const allIndices = [];
            // 8×5 rectangle: rows 0-4, cols 13-20 (40 positions total, including row 0, col 20)
            // Include ALL 40 positions in the rectangle (including row 0, col 20 which stays black but moves)
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 13; col < 21 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Include ALL positions in the rectangle (including row 0, col 20)
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Add the diagonal dot (row 5, col 12) - diagonal from bottom-left of rectangle (row 4, col 13)
            // This makes 41 dots total (40 in rectangle + 1 diagonal)
            const diagonalIdx = 5 * gridSize + 12;
            // Ensure diagonal dot is included - add it at the end to guarantee it's in the 41
            if (!alreadyFilled.has(diagonalIdx) && !allIndices.includes(diagonalIdx)) {
              allIndices.push(diagonalIdx);
            }
            // All 41 dots move together, but row 0, col 20 stays black (handled in movement code)
            // We need all 41 dots (40 in rectangle + 1 diagonal) to move together
            // Don't slice to componentValue - include all 41 dots
            indicesToFill = allIndices;
          } else if (square === 484) {
            // Special: 484 - 80 pink total
            // Keep all green dots from first click, fill remaining black dots with pink
            // Except: dots 21, 22, 43, 44 stay black (these are the 2×2 square in top-right)
            // Dots 21, 22, 43, 44: indices 20, 21, 42, 43
            // Dot 21: row 0, col 20
            // Dot 22: row 0, col 21
            // Dot 43: row 1, col 20
            // Dot 44: row 1, col 21
            const blackDotsToKeep = [20, 21, 42, 43]; // indices for dots 21, 22, 43, 44
            
            // Fill all black dots (not already filled) with pink, except the 4 black dots to keep
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip dots that are already filled (green from first click)
                if (alreadyFilled.has(idx)) {
                  continue;
                }
                // Skip the 4 black dots that should stay black (21, 22, 43, 44)
                if (blackDotsToKeep.includes(idx)) {
                  continue;
                }
                // Fill all other black dots with pink
                allIndices.push(idx);
              }
            }
            // Should be 80 pink dots (484 - 400 green - 4 black = 80)
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 841) {
            // Special: 841 - 40 green dots on second click
            // Pattern matches 21×21 (441): 8×5 rectangle + 1 diagonal dot, but top-right stays black
            // 8×5 rectangle: rows 0-4, cols 21-28 (40 positions total)
            // Fill 39 positions in the rectangle (excluding row 0, col 28 which stays black)
            // Plus 1 diagonal dot (row 5, col 20)
            const allIndices = [];
            // 8×5 rectangle: rows 0-4, cols 21-28 (40 positions total)
            // Fill 39 positions in the rectangle (excluding row 0, col 28 which stays black)
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 21; col < 29 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Exclude row 0, col 28 - it stays black until third click
                if (row === 0 && col === 28) {
                  continue;
                }
                // Include the other 39 positions in the rectangle
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Add the diagonal dot (row 5, col 20) - diagonal from bottom-left of rectangle (row 4, col 21)
            // This makes 40 dots total (39 in rectangle + 1 diagonal)
            const diagonalIdx = 5 * gridSize + 20;
            // Ensure diagonal dot is included - add it at the end to guarantee it's in the 40
            if (!alreadyFilled.has(diagonalIdx) && !allIndices.includes(diagonalIdx)) {
              allIndices.push(diagonalIdx);
            }
            // We need 41 dots total, but row 0, col 28 stays black
            // So we fill 40 dots here (39 in rectangle + 1 diagonal)
            // The 41st dot (row 0, col 28) will be filled on the third click as red
            // Make sure we get exactly 40 dots (componentValue is 40)
            // Ensure diagonal dot is always included in the final list
            indicesToFill = allIndices.slice(0, componentValue);
            if (!indicesToFill.includes(diagonalIdx) && allIndices.includes(diagonalIdx)) {
              // Replace the last item with diagonal dot to ensure it's included
              indicesToFill[indicesToFill.length - 1] = diagonalIdx;
            }
          } else if (square === 529) {
            // Special: 529 - 20 orange in a 4×5 rectangle (rows 0-3, cols 15-19)
            const allIndices = [];
            // Fill exactly the 4×5 rectangle: rows 0-3, cols 15-19
            for (let row = 0; row < 4 && row < gridSize; row++) {
              for (let col = 15; col < 20 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 676) {
            // Special: 676 - 70 brown dots on second click, same pattern as 576
            // Fill remaining black dots with brown, except the 6-dot pattern (ones place)
            // The 6-dot pattern stays black and will turn purple on 3rd click
            const allIndices = [];
            // Fill all black dots except the 6-dot pattern (ones place)
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip dots that are already filled (purple from first click)
                if (alreadyFilled.has(idx)) {
                  continue;
                }
                // Skip the 6-dot pattern (ones place) - these stay black until 3rd click
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                // Fill all other black dots with brown
                allIndices.push(idx);
              }
            }
            // Fill exactly 70 brown dots
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 729) {
            // Special: 729 - 20 brown dots on second click in 4×5 rectangle (rows 0-3, cols 19-23)
            const allIndices = [];
            // Fill exactly the 4×5 rectangle: rows 0-3, cols 19-23
            for (let row = 0; row < 4 && row < gridSize; row++) {
              for (let col = 19; col < 24 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 784) {
            // Special: 784 - 80 pink dots on second click
            // Fill remaining black dots with pink, except the 2×2 square (rows 0-1, cols 26-27)
            // The 2×2 square stays black and will turn green on 3rd click
            const allIndices = [];
            // Fill all black dots except the 2×2 square
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip dots that are already filled (brown from first click)
                if (alreadyFilled.has(idx)) {
                  continue;
                }
                // Skip the 2×2 square (rows 0-1, cols 26-27) - these stay black until 3rd click
                if (row >= 0 && row <= 1 && col >= 26 && col <= 27) {
                  continue;
                }
                // Fill all other black dots with pink
                allIndices.push(idx);
              }
            }
            // Fill exactly 80 pink dots
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 625) {
            // Special: 625 - 20 orange dots on second click
            // Turn remaining black dots orange, except 25, 50, 75, 100, 125
            // Black dots to turn orange: 21-24, 46-49, 71-74, 96-99, 121-124 (20 dots)
            const orangeDots = [];
            // Dots 21-24 (exclude 25)
            for (let dot = 21; dot <= 24; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 46-49 (exclude 50)
            for (let dot = 46; dot <= 49; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 71-74 (exclude 75)
            for (let dot = 71; dot <= 74; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 96-99 (exclude 100)
            for (let dot = 96; dot <= 99; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 121-124 (exclude 125)
            for (let dot = 121; dot <= 124; dot++) {
              orangeDots.push(dot - 1);
            }
            
            const allIndices = orangeDots.filter(idx => !alreadyFilled.has(idx));
            // Fill exactly 20 orange dots
            indicesToFill = allIndices.slice(0, componentValue);
          } else {
            // Other 3-digit: around/separating the ones place
            indicesToFill = getIndicesAroundOnes(gridSize, componentValue, topRightIndices, alreadyFilled);
          }
        } else if (square === 1600 && clickCount === 1 && indicesToFill.length > 0) {
          // 1600 second click already handled above - skip other handlers
        } else if (isTensPlace && components.length === 2) {
          // Tens place in 2-digit number: upper left area (for 49, this is the 40)
          if (square === 25) {
            // Special: 25 - 20 orange in first 4 columns (cols 0-3, rows 0-4), leaving 5 black (col 4, rows 0-4)
            const allIndices = [];
            // Fill 4 columns × 5 rows = 20 orange dots (cols 0-3, rows 0-4)
            // Leave col 4 (rightmost column) for 5 blue dots
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 0; col < 4 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 36) {
            // Special: 36 - 30 yellow, fill all 30 dots, leaving space for 6 (top right triangle)
            const allIndices = [];
            // Fill all available spaces except top right triangle pattern
            // Collect all indices first, then slice
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 49) {
            // Special: 49 - 40 orange, fill all 40 dots, leaving space for 9 (top right 3x3)
            const allIndices = [];
            // Fill all available spaces except top right 3x3
            // Collect all indices first, then slice
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else {
            indicesToFill = getUpperLeftIndices(gridSize, componentValue, topRightIndices, alreadyFilled);
          }
        } else {
          // Fallback: fill remaining empty spaces
          // Skip this for replica (all clicks), 1296 third and fourth clicks - we already set indicesToFill
          if (!is1296SpecialClick && !isReplica) {
          for (let i = 0; i < circles.length && indicesToFill.length < componentValue; i++) {
            if (!alreadyFilled.has(i) && !topRightIndices.includes(i)) {
              indicesToFill.push(i);
              }
            }
          }
        }
        
        // Fill the indices (only fill as many as needed)
        const filledCount = { count: 0 };
        // For 441, we need to fill 40 dots on second click (39 in rectangle + 1 diagonal)
        // For 1156, we need to fill 100 dots on second click and move them up
        // Make sure we process all indices, not just up to componentValue
        // For 841, just fill normally (no special processing needed)
        // For 1156, clicks 2-4 should not process any indices (no visual changes)
        // For 1156, allow second click (clickCount === 1) and third click (clickCount === 2) to proceed
        // For 1225, allow third click (clickCount === 2) to proceed and move dots up

        // Special: 1369 fourth click (ones place) – fill exactly 9 dots in the 3×3 top-right square
        if (square === 1369 && isOnesPlace && componentValue === 9) {
          is1369SpecialClick = true;
          const topRightIndices1369 = get3x3TopRightIndices(gridSize);
          indicesToFill = topRightIndices1369.filter(i => !alreadyFilled.has(i)).slice(0, componentValue);
        }

        // Special protection for 1600 and 1681 second click - ensure indicesToFill is 600
        if ((square === 1600 || square === 1681) && clickCount === 1 && indicesToFill.length !== 600) {
          console.log(square + ' second click - WARNING: indicesToFill was', indicesToFill.length, 'but should be 600! Recalculating...');
          const allIndices = [];
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              if (!alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
          }
          indicesToFill = allIndices.slice(0, componentValue);
          console.log(square + ' second click - RECALCULATED indicesToFill to', indicesToFill.length, 'indices');
        }

        const indicesToProcess = (square === 1156 && clickCount === 1) ? indicesToFill : 
                                  (square === 2500 ? indicesToFill :
                                  ((square === 441 && isTensPlace) ? indicesToFill :
                                  ((square === 1225 && clickCount === 2) ? indicesToFill :
                                  ((square === 1600 && clickCount === 1) ? indicesToFill :
                                  ((square === 1681 && clickCount === 1) ? indicesToFill :
                                  ((square === 1764 && clickCount === 1) ? indicesToFill :
                                  ((square === 1764 && clickCount === 2) ? indicesToFill :
                                  ((square === 1764 && clickCount === 3) ? indicesToFill :
                                  ((square === 1849 && clickCount === 1) ? indicesToFill :
                                  ((square === 1849 && clickCount === 2) ? indicesToFill :
                                  ((square === 1849 && clickCount === 3) ? indicesToFill :
                                  ((square === 1936 && clickCount === 1) ? indicesToFill :
                                  ((square === 1936 && clickCount === 2) ? indicesToFill :
                                  ((square === 1936 && clickCount === 3) ? indicesToFill :
                                  ((square === 2025 && isTensPlace) ? indicesToFill :
                                  ((square === 2025 && isOnesPlace) ? indicesToFill :
                                  ((square === 2116 && clickCount === 1) ? indicesToFill :
                                  ((square === 2116 && clickCount === 2) ? indicesToFill :
                                  ((square === 2116 && clickCount === 3) ? indicesToFill :
                                  ((square === 2209 && clickCount === 1) ? indicesToFill :
                                  ((square === 2209 && clickCount === 2) ? indicesToFill :
                                  ((is1296SpecialClick || is1369SpecialClick) ? indicesToFill : (indicesToFill || []).slice(0, componentValue)))))))))))))))))))))));
        
        if (square === 1600 && clickCount === 1) {
          console.log('1600 second click - indicesToFill length:', indicesToFill.length, 'indicesToProcess length:', indicesToProcess.length, 'componentValue:', componentValue);
        }
        
        // Special handling for 441 third click - update existing separated circle to red
        // This needs to happen BEFORE processing indices, to ensure the separated circle is found and updated
        if (square === 441 && isOnesPlace) {
          // Find the existing separated circle for row 0, col 20 (created on second click)
          // Search through all separated circles to find the one with matching originalRow and originalCol
          const existingSeparated = separatedCircles.find(sc => {
            const scRow = parseInt(sc.dataset.originalRow);
            const scCol = parseInt(sc.dataset.originalCol);
            return scRow === 0 && scCol === 20;
          });
          
          if (existingSeparated) {
            // Update the existing black separated circle to red
            // Remove all color classes first, then add red
            existingSeparated.classList.remove(...COLOR_CLASSES);
            existingSeparated.classList.remove('red');
            existingSeparated.classList.add('red'); // Explicitly add red color
            existingSeparated.style.zIndex = '10';
            existingSeparated.style.visibility = 'visible';
            existingSeparated.style.display = 'block';
            existingSeparated.style.opacity = '1';
            // Ensure it has a click listener (in case it was created before we added the listener)
            if (square === 441 && !existingSeparated.hasAttribute('data-click-listener-added')) {
              existingSeparated.style.cursor = 'pointer';
              existingSeparated.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event from bubbling to grid
                // Trigger the grid's click handler
                grid.dispatchEvent(new Event('click', { bubbles: true }));
              });
              existingSeparated.setAttribute('data-click-listener-added', 'true');
            }
            // Also hide the original circle in the grid if it's still visible
            const originalIdx = 0 * gridSize + 20;
            if (circles[originalIdx]) {
              circles[originalIdx].style.visibility = 'hidden';
            }
          }
        }
        
        // For 1225 third click, also process the 5 black dots in col 34 (rows 0-4) to move them with the 5×5 grid
        // These dots are not in indicesToFill, but they need to be moved along with the orange dots
        if (square === 1225 && clickCount === 2) {
          for (let row = 0; row < 5; row++) {
            const col = gridSize - 1; // col 34
            const idx = row * gridSize + col;
            const c = circles[idx];
            
            // Only process if not already processed
            if (c && !separatedCircles.find(sc => {
              const scRow = parseInt(sc.dataset.originalRow);
              const scCol = parseInt(sc.dataset.originalCol);
              return scRow === row && scCol === col;
            })) {
              // Hide the original circle
              c.style.visibility = 'hidden';
              
              // Create a separated circle for the black dot
              const separatedCircle = document.createElement('div');
              separatedCircle.className = 'circle'; // Keep black
              separatedCircle.style.position = 'absolute';
              separatedCircle.style.zIndex = '5';
              separatedCircle.dataset.originalRow = row;
              separatedCircle.dataset.originalCol = col;
              
              // Copy size classes to maintain exact grid spacing
              c.classList.forEach(cls => {
                if (cls.startsWith('circle-')) {
                  separatedCircle.classList.add(cls);
                }
              });
              
              // Position to the right and up (same as orange dots)
              const circleSizeVar = 'var(--circle-total-1225)';
              separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 0.5 * ${circleSizeVar})`;
              separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 0.5 * ${circleSizeVar})`;
              separatedCircle.style.display = 'block';
              separatedCircle.style.visibility = 'visible';
              separatedCircle.style.opacity = '1';
              grid.appendChild(separatedCircle);
              separatedCircles.push(separatedCircle);
            }
          }
        }
        
        indicesToProcess.forEach(i => {
          const c = circles[i];
          
          // Only fill if not already filled and color is set
          if (!alreadyFilled.has(i) && color) {
            c.classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
              c.classList.add(color);
            if (square === 1600 && clickCount === 1 && i === indicesToProcess[0]) {
              console.log('1600 second click - first dot colored:', color, 'circle classes:', c.classList.toString());
            }
            filledCount.count++;
            
            // For 441, offset ALL 41 dots (tens place) - the entire 8×5 rectangle + 1 diagonal dot
            // All 41 dots should offset together on the second click
            // This includes row 0, col 20 which stays black but also offsets
            // For 1156 second click (clickCount === 1), move 100 red dots up 0.5 dot distance (vertically only)
            // For 1225 third click (clickCount === 2), move 20 orange dots right 0.5 and up 0.5 dot (like 225)
            // For 2209 second click (clickCount === 1), move 200 orange dots up 1.5 dot distance (vertically only)
            // For 841, don't offset - just change colors in place
            // NOTE: 1444 (38×38) does NOT move dots - they stay in place and just fill normally
            if ((square === 441 && isTensPlace) || (square === 1156 && clickCount === 1) || (square === 1225 && clickCount === 2) || (square === 2209 && clickCount === 1)) {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Check if this dot should offset:
              // For 441: 8×5 rectangle (rows 0-4, cols 13-20) - including row 0, col 20
              //          Diagonal dot (row 5, col 12)
              // For 1156: all 100 red dots on second click move up 0.5 dot distance (straight up)
              // For 1225: all 20 orange dots + 5 black dots (that will turn blue) on third click move right 0.5 dot and up 0.5 dot (like 225)
              // For 2209: all orange dots in rectangle (200 in 47×47, scaled proportionally in 13×13) on second click move up 1.5 dot distance (straight up)
              // NOTE: 1444 (38×38) does NOT move dots - they stay in place
              const isInRectangle = (square === 441 && row >= 0 && row < 5 && col >= 13 && col < 21);
              const isDiagonalDot = (square === 441 && row === 5 && col === 12);
              const is1156SecondClick = (square === 1156 && clickCount === 1);
              const is1225ThirdClick = (square === 1225 && clickCount === 2);
              const is2209SecondClick = (square === 2209 && clickCount === 1);
              // For 1225 third click: also include the 5 blue dots (column 34, rows 0-4) in movement
              const is1225BlueDot = (square === 1225 && clickCount === 2 && col === gridSize - 1 && row < 5);
              // For 1225: check if dot is in the 5×5 area (rows 0-4, cols 30-34)
              const is1225In5x5 = (square === 1225 && clickCount === 2 && row >= 0 && row < 5 && col >= 30 && col < 35);
              
              if (isInRectangle || isDiagonalDot || is1156SecondClick || is1225In5x5 || is2209SecondClick) {
                // Hide the original circle in the grid
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (!existingSeparated) {
                  // Create a new circle positioned offset (all 41 move together)
                  // For row 0, col 20 (441) or row 0, col 28 (841), keep it black (don't add color class)
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle'; // Start with no color (black)
                  // If this is not the top-right corner dot, add the color
                  const isTopRightCorner = (square === 441 && row === 0 && col === 20) || 
                                          (square === 841 && row === 0 && col === 28);
                  if (!isTopRightCorner) {
                    separatedCircle.className = `circle ${color}`;
                  }
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '5';
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  
                  // Keep the same size as original circle - copy size classes
                  c.classList.forEach(cls => {
                    if (cls.startsWith('circle-')) {
                      separatedCircle.classList.add(cls);
                    }
                  });
                  
                  // Special handling for diagonal dot - needs to touch rectangle's bottom-left tangentially
                  if (isDiagonalDot) {
                    // For 441: rectangle's bottom-left is at row 4, col 13, diagonal dot at row 5, col 12
                    // For 841: rectangle's bottom-left is at row 4, col 21, diagonal dot at row 5, col 20
                    // After standard offset, move it just a bit closer to touch tangentially:
                    // - Move it to the RIGHT: col + 1.5 (positive = right)
                    // - Move it UP: row - 1.5 (negative = up, since top is measured from top)
                    // Use grid-specific circle size for 441 to maintain tangential connection when grid shrinks
                    const circleSizeVar = square === 441 ? 'var(--circle-total-441)' : 'var(--circle-total)';
                    separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 1.5 * ${circleSizeVar})`;
                    separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 1.5 * ${circleSizeVar})`;
                    // Ensure it's visible and has green color, and give it a higher z-index so it's on top
                    separatedCircle.className = `circle ${color}`;
                    // Copy size classes
                    c.classList.forEach(cls => {
                      if (cls.startsWith('circle-')) {
                        separatedCircle.classList.add(cls);
                      }
                    });
                    separatedCircle.style.zIndex = '6'; // Slightly higher than rectangle dots to ensure visibility
                  } else if (is1156SecondClick || is1225In5x5 || is2209SecondClick) {
                    // For 1156 second click: move all 100 red dots UP 0.5 dot distance (straight up, no left movement)
                    // For 1225 third click: move all 20 orange dots + 5 black dots RIGHT 0.5 dot and UP 0.5 dot (like 225)
                    // For 2209 second click: move all orange dots in rectangle UP 1.5 dot distance (straight up, no left movement)
                    //   Rectangle: rows 0-19, cols 34-43 (47×47) or rows 0-5, cols 10-12 (13×13 scaled display)
                    // All dots maintain their exact grid spacing relative to each other - they move as a connected unit
                    // For 1225: RIGHT by 0.5 dot, UP by 0.5 dot (like square 225)
                    // For 1156: UP by 0.5 dot (straight up)
                    // For 2209: UP by 1.5 dots (straight up)
                    // Set className first, then add size classes to maintain exact spacing
                    // For blue dots (is1225BlueDot), keep them black (no color class)
                    if (is1225BlueDot) {
                      separatedCircle.className = 'circle'; // Keep black
                    } else {
                      separatedCircle.className = `circle ${color}`; // Red for 1156, orange for 1225
                    }
                    // Copy size classes AFTER setting className to maintain exact grid spacing
                    c.classList.forEach(cls => {
                      if (cls.startsWith('circle-')) {
                        separatedCircle.classList.add(cls);
                      }
                    });
                    // Use grid-specific circle size to maintain tangential connection when grid shrinks
                    // For 1156, use --circle-total-1156; for 1225, use --circle-total-1225; for 2209, use --circle-total-2209; for others, use --circle-total
                    const circleSizeVar = square === 1156 ? 'var(--circle-total-1156)' : 
                                        (square === 1225 ? 'var(--circle-total-1225)' : 
                                        (square === 2209 ? 'var(--circle-total-2209)' : 'var(--circle-total)'));
                    // For 1225, move right by 0.5 dots and up by 0.5 dots (like square 225)
                    // This includes both the 20 orange dots and the 5 black dots in col 34 for 1225
                    if (is1225In5x5) {
                      separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 0.5 * ${circleSizeVar})`;
                      separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 0.5 * ${circleSizeVar})`;
                      // For the 5 black dots in col 34 (1225), keep them black (no color class)
                      if (is1225BlueDot) {
                        separatedCircle.className = 'circle'; // Keep black
                      }
                    } else {
                      // For 1156 and 2209, move straight up only
                      const moveUpDistance = is1156SecondClick ? 0.5 : (is2209SecondClick ? 1.5 : 1);
                      separatedCircle.style.left = `calc(${circleSizeVar} * ${col})`;
                      separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - ${moveUpDistance} * ${circleSizeVar})`;
                    }
                    // Ensure no transform or other positioning that could cause separation
                    separatedCircle.style.transform = 'none';
                    separatedCircle.style.margin = '0';
                    separatedCircle.style.padding = '0';
                    
                    // Copy the dot number data attribute if it exists (for squares 1156 and 1225)
                    if (c.dataset.dotNumber) {
                      separatedCircle.dataset.dotNumber = c.dataset.dotNumber;
                    }
                  } else {
                    // Standard offset for all other dots (all 41 move together) - moves RIGHT and UP diagonally
                    // RIGHT: positive left value = col + 1.2
                    // UP: negative top value = row - 1.2
                    // Use grid-specific circle size for 441 to maintain tangential connection when grid shrinks
                    const circleSizeVar = square === 441 ? 'var(--circle-total-441)' : 'var(--circle-total)';
                    separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 1.2 * ${circleSizeVar})`;
                    separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 1.2 * ${circleSizeVar})`;
                    
                    // Copy the dot number data attribute if it exists (for squares 1156 and 1225)
                    if (c.dataset.dotNumber) {
                      separatedCircle.dataset.dotNumber = c.dataset.dotNumber;
                    } else {
                      // Copy the number span if it exists (for other numbered grids)
                      const originalNumber = c.querySelector('.circle-number');
                      if (originalNumber) {
                        const numberSpan = document.createElement('span');
                        numberSpan.className = 'circle-number';
                        numberSpan.textContent = originalNumber.textContent;
                        separatedCircle.appendChild(numberSpan);
                      }
                    }
                  }
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                  
                  // Add click listener to separated circle for 441 grid
                  // Make it trigger the grid's click handler so clicks advance the state
                  if (square === 441) {
                    separatedCircle.style.cursor = 'pointer';
                    separatedCircle.addEventListener('click', (e) => {
                      e.stopPropagation(); // Prevent event from bubbling to grid
                      // Trigger the grid's click handler
                      grid.dispatchEvent(new Event('click', { bubbles: true }));
                    });
                    separatedCircle.setAttribute('data-click-listener-added', 'true');
                  }
                }
              }
            }
            
            // For 441, offset the 1 part (ones place) - red dot at top right corner, offset
            // For 841, don't offset - just change color in place
            // Note: For 441, the separated circle update is handled BEFORE the forEach loop above
            // This code only handles the case where a new separated circle needs to be created (shouldn't happen for 441)
            if (square === 441 && isOnesPlace) {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process the single dot at top right corner (row 0, col 20)
              if (row === 0 && col === 20) {
                // Hide the original circle in the grid
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index (the black one from second click)
                // This should have been updated BEFORE the forEach loop, but check again just in case
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (existingSeparated) {
                  // Update the existing black separated circle to red (if not already updated)
                  if (!existingSeparated.classList.contains('red')) {
                  existingSeparated.classList.remove(...COLOR_CLASSES);
                    existingSeparated.classList.add('red');
                    existingSeparated.style.zIndex = '10';
                    existingSeparated.style.visibility = 'visible';
                    existingSeparated.style.display = 'block';
                    existingSeparated.style.opacity = '1';
                  }
                } else {
                  // Fallback: Create a new circle positioned offset (right and up from top-right corner)
                  // This shouldn't happen if the second click worked correctly
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = `circle ${color}`;
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '10';
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  
                  // Keep the same size as original circle - copy size classes
                  c.classList.forEach(cls => {
                    if (cls.startsWith('circle-')) {
                      separatedCircle.classList.add(cls);
                    }
                  });
                  
                  // Small offset to the RIGHT and UP (the red dot moves just a little bit more than the 40)
                  // RIGHT: positive left value = col + 1.5 (1.2 + 0.3)
                  // UP: negative top value = row - 1.5 (1.2 + 0.3)
                  // Use grid-specific circle size for 441 to maintain tangential connection when grid shrinks
                  const circleSizeVar = square === 441 ? 'var(--circle-total-441)' : 'var(--circle-total)';
                  separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 1.5 * ${circleSizeVar})`;
                  separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 1.5 * ${circleSizeVar})`;
                  
                  // Copy the number span if it exists (for numbered grids)
                  const originalNumber = c.querySelector('.circle-number');
                  if (originalNumber) {
                    const numberSpan = document.createElement('span');
                    numberSpan.className = 'circle-number';
                    numberSpan.textContent = originalNumber.textContent;
                    separatedCircle.appendChild(numberSpan);
                  }
                  
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
            
            // For 225 and 2025, make sure blue dots (ones place) appear on top
            if ((square === 225 || square === 2025) && isOnesPlace && color === 'blue') {
              c.style.zIndex = '20';
              c.style.position = 'relative';
            }
            
            // For 256, separate the 6 purple dots from the main grid
            // For 1156, keep purple dots in place (don't separate them)
            // For 256 third click: purple dots just change color, don't move
            // (No special handling needed - dots will fill normally in place)
            
            // For 225 and 2025, separate the entire 5×5 rectangle (20 orange + 5 black) from the main grid
            // On second click: 20 orange dots are separated and filled
            // Also create the 5 black dots in the separated position (rightmost column, rows 0-4)
            // For 2116, separate the entire 4×4 rectangle (10 red + 6 black) from the main grid
            // On third click: 10 red dots are separated and filled
            // Also create the 6 black dots in the separated position (triangle pattern)
            if ((square === 225 || square === 2025) && isTensPlace && color === 'orange') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the 5×5 area (first 4 columns for orange dots)
              const startCol = square === 225 ? 10 : (gridSize - 5);
              const endCol = square === 225 ? 13 : (gridSize - 2); // Exclude rightmost column (black dots)
              if (row >= 0 && row < 5 && col >= startCol && col <= endCol) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (!existingSeparated) {
                  // Create a new circle positioned to the right and DOWN, separated from the main grid
                  // All 25 dots (20 orange + 5 black) move together, maintaining tangential connection
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle orange';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '5'; // Lower z-index than blue dots
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  
                  // Copy size classes to maintain exact grid spacing and tangential connection
                  c.classList.forEach(cls => {
                    if (cls.startsWith('circle-')) {
                      separatedCircle.classList.add(cls);
                    }
                  });
                  
                  // Position to the right and UP from where the original circle was
                  // All 25 dots (20 orange + 5 black) move together maintaining tangential connection
                  // Use correct circle size variable for each grid
                  const circleSizeVar = square === 225 ? 'var(--circle-total-225)' : 'var(--circle-total-2025)';
                  separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                  
                  // Add click listener to separated circle for 225 grid
                  // Make it trigger the grid's click handler so clicks advance the state
                  if (square === 225 || square === 2025) {
                    separatedCircle.style.cursor = 'pointer';
                    separatedCircle.addEventListener('click', (e) => {
                      e.stopPropagation(); // Prevent event from bubbling to grid
                      // Trigger the grid's click handler
                      grid.dispatchEvent(new Event('click', { bubbles: true }));
                    });
                  }
                }
              }
            }
            
            // For 225, also separate the 5 blue dots (ones place) in the separated 5×5 rectangle
            // The blue dots should replace the 5 black separated dots in col 14 (rightmost column)
            if ((square === 225 || square === 2025) && isOnesPlace && color === 'blue') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the rightmost column of the 5×5 area (rows 0-4)
              const rightmostCol = square === 225 ? 14 : (gridSize - 1);
              if (row >= 0 && row < 5 && col === rightmostCol) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index (should be a black one from second click)
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (existingSeparated) {
                  // If already existing (the black separated dot from second click), just update its color and z-index
                  existingSeparated.classList.remove(...COLOR_CLASSES);
                  existingSeparated.classList.add('blue');
                  existingSeparated.style.zIndex = '20'; // Higher z-index to appear on top
                } else {
                  // Should not happen, but create it if somehow missing
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle blue';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '20'; // Higher z-index to appear on top
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Position to the right and up from where the original circle was
                  // Same offset as the orange dots so they form the complete 5×5 rectangle
                  // Use grid-specific circle size to maintain tangential connection
                  const circleSizeVar = square === 225 ? 'var(--circle-total-225)' : 'var(--circle-total-2025)';
                  separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                  
                  // Add click listener to separated circle for 225 grid
                  // Make it trigger the grid's click handler so clicks advance the state
                  if (square === 225 || square === 2025) {
                    separatedCircle.style.cursor = 'pointer';
                    separatedCircle.addEventListener('click', (e) => {
                      e.stopPropagation(); // Prevent event from bubbling to grid
                      // Trigger the grid's click handler
                      grid.dispatchEvent(new Event('click', { bubbles: true }));
                    });
                  }
                }
              }
            }
            
            // For 1225, also separate the 5 blue dots (fourth click) in the separated 5×5 rectangle
            // The blue dots should replace the 5 black separated dots in col 34 (rightmost column)
            if (square === 1225 && clickCount === 3 && color === 'blue') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the rightmost column of the 5×5 area (rows 0-4, col 34)
              const rightmostCol = gridSize - 1; // col 34 for 35×35 grid
              if (row >= 0 && row < 5 && col === rightmostCol) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index (should be a black one from third click)
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (existingSeparated) {
                  // If already existing (the black separated dot from third click), just update its color and z-index
                  existingSeparated.classList.remove(...COLOR_CLASSES);
                  existingSeparated.classList.add('blue');
                  existingSeparated.style.zIndex = '20'; // Higher z-index to appear on top
                } else {
                  // Should not happen, but create it if somehow missing
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle blue';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '20'; // Higher z-index to appear on top
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Position to the right and up from where the original circle was
                  // Same offset as the orange dots so they form the complete 5×5 rectangle
                  // Use grid-specific circle size for 1225 to maintain tangential connection
                  const circleSizeVar = 'var(--circle-total-1225)';
                  separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                  
                  // Add click listener to separated circle for 441 grid (fallback case)
                  // Make it trigger the grid's click handler so clicks advance the state
                  if (square === 441) {
                    separatedCircle.style.cursor = 'pointer';
                    separatedCircle.addEventListener('click', (e) => {
                      e.stopPropagation(); // Prevent event from bubbling to grid
                      // Trigger the grid's click handler
                      grid.dispatchEvent(new Event('click', { bubbles: true }));
                    });
                    separatedCircle.setAttribute('data-click-listener-added', 'true');
                  }
                }
              }
            }
            
            // For 2116, separate the entire 4×4 rectangle (10 red + 6 black) from the main grid
            // On third click: 10 red dots are separated and filled
            if (square === 2116 && clickCount === 2 && color === 'red') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the 4×4 area (rows 0-3, cols 42-45), excluding triangle pattern
              const triangleIndices = getTrianglePatternIndices(gridSize);
              if (row >= 0 && row < 4 && col >= gridSize - 4 && !triangleIndices.includes(i)) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (!existingSeparated) {
                  // Create a new circle positioned to the right and up, separated from the main grid
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle red';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '5'; // Lower z-index than purple dots
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Position to the right and up from where the original circle was
                  // Same offset as the 5×5 in 15×15 grid
                  // Use grid-specific circle size for 2116 to maintain correct positioning
                  const circleSizeVar = square === 2116 ? 'var(--circle-total-2116)' : 'var(--circle-total)';
                  separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 0.5 * ${circleSizeVar})`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  
                  // Copy size classes from original circle
                  c.classList.forEach(cls => {
                    if (cls.startsWith('circle-')) {
                      separatedCircle.classList.add(cls);
                    }
                  });
                  
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
          }
        });
        
        // For 441, after filling the 40 dots on second click, also offset the top-right corner dot (stays black)
        // For 841, don't offset - just change colors in place
        // Note: clickCount is 1 on second click (0-indexed: 0=first, 1=second, 2=third)
        if (square === 441 && isTensPlace) {
          const row = 0;
          const col = 20;
          const idx = row * gridSize + col;
          
          // Check if we need to offset the top-right corner dot (even though it's not being filled green)
          const existingSeparated = separatedCircles.find(sc => {
            const scRow = parseInt(sc.dataset.originalRow);
            const scCol = parseInt(sc.dataset.originalCol);
            return scRow === row && scCol === col;
          });
          
          if (!existingSeparated) {
            // Hide the original circle in the grid
            const c = circles[idx];
            if (c) {
              c.style.visibility = 'hidden';
              
              // Create a new circle positioned offset but keep it black
              const separatedCircle = document.createElement('div');
              separatedCircle.className = 'circle'; // Black (no color class)
              separatedCircle.style.position = 'absolute';
              separatedCircle.style.zIndex = '5';
              separatedCircle.dataset.originalRow = row;
              separatedCircle.dataset.originalCol = col;
              
              // Keep the same size as original circle - copy size classes
              c.classList.forEach(cls => {
                if (cls.startsWith('circle-')) {
                  separatedCircle.classList.add(cls);
                }
              });
              
              // Offset to the RIGHT and UP (moves with the other 40) - diagonal movement
              // RIGHT: positive left value = col + 1.2
              // UP: negative top value = row - 1.2
              // Use scaled circle size variable for 441 grid
              const circleSizeVar441 = 'var(--circle-total-441)';
              separatedCircle.style.left = `calc(${circleSizeVar441} * ${col} + 1.2 * ${circleSizeVar441})`;
              separatedCircle.style.top = `calc(${circleSizeVar441} * ${row} - 1.2 * ${circleSizeVar441})`;
              
              // Copy the number span if it exists (for numbered grids)
              const originalNumber = c.querySelector('.circle-number');
              if (originalNumber) {
                const numberSpan = document.createElement('span');
                numberSpan.className = 'circle-number';
                numberSpan.textContent = originalNumber.textContent;
                separatedCircle.appendChild(numberSpan);
              }
              
              separatedCircle.style.display = 'block';
              separatedCircle.style.visibility = 'visible';
              separatedCircle.style.opacity = '1';
              grid.appendChild(separatedCircle);
              separatedCircles.push(separatedCircle);
              
              // Add click listener to separated circle for 441 grid (top-right corner dot)
              // Make it trigger the grid's click handler so clicks advance the state
              if (square === 441) {
                separatedCircle.style.cursor = 'pointer';
                separatedCircle.addEventListener('click', (e) => {
                  e.stopPropagation(); // Prevent event from bubbling to grid
                  // Trigger the grid's click handler
                  grid.dispatchEvent(new Event('click', { bubbles: true }));
                });
                separatedCircle.setAttribute('data-click-listener-added', 'true');
              }
            }
          }
        }
        
        // For 2116, after filling all 10 red dots on third click, hide the original 6 black dots (triangle pattern) and create them in separated position
        if (square === 2116 && clickCount === 2 && filledCount.count === componentValue) {
          // All 10 red dots filled, now hide the original 6 black dots (triangle pattern) and create them in separated position
          const triangleIndices = getTrianglePatternIndices(gridSize);
          for (const blackIdx of triangleIndices) {
            const blackRow = Math.floor(blackIdx / gridSize);
            const blackCol = blackIdx % gridSize;
            
            // Only process dots that are in the 4×4 area (rows 0-3, cols 42-45)
            if (blackRow >= 0 && blackRow < 4 && blackCol >= gridSize - 4) {
              // Hide the original black circle in the grid
              if (circles[blackIdx]) {
                circles[blackIdx].style.visibility = 'hidden';
              }
              
              // Check if we've already created this separated black circle
              const existingBlack = separatedCircles.find(sc => {
                return parseInt(sc.dataset.originalRow) === blackRow && parseInt(sc.dataset.originalCol) === blackCol;
              });
              
              if (!existingBlack) {
                const separatedBlackCircle = document.createElement('div');
                separatedBlackCircle.className = 'circle'; // Black (no color class)
                separatedBlackCircle.style.position = 'absolute';
                separatedBlackCircle.style.zIndex = '5';
                separatedBlackCircle.dataset.originalRow = blackRow;
                separatedBlackCircle.dataset.originalCol = blackCol;
                // Position to the right and up from where the original circle was (same offset as red dots)
                // Use grid-specific circle size for 2116 to maintain correct positioning
                const circleSizeVar2116 = 'var(--circle-total-2116)';
                separatedBlackCircle.style.left = `calc(${circleSizeVar2116} * ${blackCol} + 0.5 * ${circleSizeVar2116})`;
                separatedBlackCircle.style.top = `calc(${circleSizeVar2116} * ${blackRow} - 0.5 * ${circleSizeVar2116})`;
                separatedBlackCircle.style.display = 'block';
                separatedBlackCircle.style.visibility = 'visible';
                separatedBlackCircle.style.opacity = '1';
                
                // Copy size classes from original circle
                const originalCircle = circles[blackIdx];
                if (originalCircle) {
                  originalCircle.classList.forEach(cls => {
                    if (cls.startsWith('circle-')) {
                      separatedBlackCircle.classList.add(cls);
                    }
                  });
                }
                
                grid.appendChild(separatedBlackCircle);
                separatedCircles.push(separatedBlackCircle);
              }
            }
          }
        }
        
        // For 225 and 2025, after filling all 20 orange dots on second click, hide the original 5 black dots and create them in separated position
        if ((square === 225 || square === 2025) && isTensPlace && filledCount.count === componentValue) {
          // All 20 orange dots filled, now hide the original 5 black dots and create them in separated position
          for (let blackRow = 0; blackRow < 5; blackRow++) {
            const blackCol = square === 225 ? 14 : (gridSize - 1); // Rightmost column of the 5×5
            const blackIdx = blackRow * gridSize + blackCol;
            
            // Hide the original black circle in the grid
            if (circles[blackIdx]) {
              circles[blackIdx].style.visibility = 'hidden';
            }
            
            // Check if we've already created this separated black circle
            const existingBlack = separatedCircles.find(sc => {
              return parseInt(sc.dataset.originalRow) === blackRow && parseInt(sc.dataset.originalCol) === blackCol;
            });
            
            if (!existingBlack) {
              const separatedBlackCircle = document.createElement('div');
              separatedBlackCircle.className = 'circle'; // Black (no color class)
              separatedBlackCircle.style.position = 'absolute';
              separatedBlackCircle.style.zIndex = '5';
              separatedBlackCircle.dataset.originalRow = blackRow;
              separatedBlackCircle.dataset.originalCol = blackCol;
              
              // Copy size classes to maintain exact grid spacing and tangential connection
              if (circles[blackIdx]) {
                circles[blackIdx].classList.forEach(cls => {
                  if (cls.startsWith('circle-')) {
                    separatedBlackCircle.classList.add(cls);
                  }
                });
              }
              
              // Position to the right and UP from where the original circle was
              // All 25 dots (20 orange + 5 black) move together maintaining tangential connection
              // Use correct circle size variable for each grid
              const circleSizeVar = square === 225 ? 'var(--circle-total-225)' : 'var(--circle-total-2025)';
              separatedBlackCircle.style.left = `calc(${circleSizeVar} * ${blackCol} + 0.5 * ${circleSizeVar})`;
              separatedBlackCircle.style.top = `calc(${circleSizeVar} * ${blackRow} - 0.5 * ${circleSizeVar})`;
              separatedBlackCircle.style.display = 'block';
              separatedBlackCircle.style.visibility = 'visible';
              separatedBlackCircle.style.opacity = '1';
              grid.appendChild(separatedBlackCircle);
              separatedCircles.push(separatedBlackCircle);
              
              // Add click listener to separated black circle for 225 grid
              // Make it trigger the grid's click handler so clicks advance the state
              if (square === 225 || square === 2025) {
                separatedBlackCircle.style.cursor = 'pointer';
                separatedBlackCircle.addEventListener('click', (e) => {
                  e.stopPropagation(); // Prevent event from bubbling to grid
                  // Trigger the grid's click handler
                  grid.dispatchEvent(new Event('click', { bubbles: true }));
                });
              }
            }
          }
        }
        
        // For 2116 fourth click: color the 6 separated black dots (triangle pattern) purple
        if (square === 2116 && clickCount === 3) {
          // The 6 purple dots are separated circles in the triangle pattern
          const triangleIndices = getTrianglePatternIndices(gridSize);
          for (const triangleIdx of triangleIndices) {
            const triangleRow = Math.floor(triangleIdx / gridSize);
            const triangleCol = triangleIdx % gridSize;
            
            // Find the separated circle that matches this triangle position
            const existingSeparated = separatedCircles.find(sc => {
              const scRow = parseInt(sc.dataset.originalRow);
              const scCol = parseInt(sc.dataset.originalCol);
              return scRow === triangleRow && scCol === triangleCol;
            });
            
            if (existingSeparated) {
              // Change the separated circle from black to purple
              existingSeparated.classList.remove(...COLOR_CLASSES);
              existingSeparated.classList.add('purple');
              existingSeparated.style.zIndex = '10'; // Higher z-index for purple dots
            }
          }
        }
        
        // For 1225 fourth click: color the 5 separated black dots blue
        if (square === 1225 && clickCount === 3) {
          // The 5 blue dots are separated circles at column 34 (rightmost), rows 0-4
          for (let row = 0; row < 5 && row < gridSize; row++) {
            const existingSeparated = separatedCircles.find(sc => {
              const scRow = parseInt(sc.dataset.originalRow);
              const scCol = parseInt(sc.dataset.originalCol);
              return scRow === row && scCol === gridSize - 1;
            });
            
            if (existingSeparated) {
              // Change the separated circle from black to blue
              existingSeparated.classList.remove(...COLOR_CLASSES);
              existingSeparated.classList.add('blue');
            }
          }
        }
        
        // For 1225 third click: also move the 5 black dots (that will turn blue on 4th click) up with the orange dots
        if (square === 1225 && clickCount === 2) {
          // The 5 blue dots are in column 34 (rightmost), rows 0-4
          for (let row = 0; row < 5 && row < gridSize; row++) {
            const blueDotIdx = row * gridSize + (gridSize - 1); // Column 34
            const c = circles[blueDotIdx];
            
            // Only process if not already processed (not in indicesToFill)
            if (c && !indicesToFill.includes(blueDotIdx)) {
              // Hide the original circle in the grid
              c.style.visibility = 'hidden';
              
              // Check if we've already created a separated circle for this index
              const existingSeparated = separatedCircles.find(sc => {
                const scRow = parseInt(sc.dataset.originalRow);
                const scCol = parseInt(sc.dataset.originalCol);
                return scRow === row && scCol === gridSize - 1;
              });
              
              if (!existingSeparated) {
                // Create a new circle positioned 1 dot distance up, but keep it black
                const separatedCircle = document.createElement('div');
                separatedCircle.className = 'circle'; // Keep black (no color class)
                separatedCircle.style.position = 'absolute';
                separatedCircle.style.zIndex = '5';
                separatedCircle.dataset.originalRow = row;
                separatedCircle.dataset.originalCol = gridSize - 1;
                
                // Copy size classes
                c.classList.forEach(cls => {
                  if (cls.startsWith('circle-')) {
                    separatedCircle.classList.add(cls);
                  }
                });
                
                // Move up 1 dot distance (same as orange dots)
                // Use scaled circle size variable for 1225 grid
                const circleSizeVar1225 = 'var(--circle-total-1225)';
                separatedCircle.style.left = `calc(${circleSizeVar1225} * ${gridSize - 1})`;
                separatedCircle.style.top = `calc(${circleSizeVar1225} * ${row} - 1 * ${circleSizeVar1225})`;
                separatedCircle.style.transform = 'none';
                separatedCircle.style.margin = '0';
                separatedCircle.style.padding = '0';
                
                // Copy the dot number data attribute if it exists (for square 1225)
                if (c.dataset.dotNumber) {
                  separatedCircle.dataset.dotNumber = c.dataset.dotNumber;
                } else {
                  // Copy the number span if it exists (for other squares)
                  const originalNumber = c.querySelector('.circle-number');
                  if (originalNumber) {
                    const numberSpan = document.createElement('span');
                    numberSpan.className = 'circle-number';
                    numberSpan.textContent = originalNumber.textContent;
                    separatedCircle.appendChild(numberSpan);
                  }
                }
                
                separatedCircle.style.display = 'block';
                separatedCircle.style.visibility = 'visible';
                separatedCircle.style.opacity = '1';
                grid.appendChild(separatedCircle);
                separatedCircles.push(separatedCircle);
              }
            }
          }
        }
        
        clickCount++;
        
        // Check if we've exceeded totalClicks - if so, don't speak (reset will happen on next click)
        if (clickCount > totalClicks) {
          return; // Exit early, reset will happen on next click
        }
        
        // Special: For square 1225, second click should say "1200", third click should say "1220", and fourth click should say "1225"
        // Special: For square 1296, speak cumulative totals: "1000", "1200", "1290", "1296"
        // Special: For square 1369, first three clicks say "1000", "1300", "1360", and the fourth click says just "9"
        let numberToSpeak;
        if (square === 1296) {
          // For 1296, speak cumulative totals
          if (clickCount === 1) {
            numberToSpeak = 1000;
          } else if (clickCount === 2) {
            numberToSpeak = 1200; // 1000 + 200
          } else if (clickCount === 3) {
            numberToSpeak = 1290; // Voice says cumulative total (1000 + 200 + 90), but visually fills 60 purple dots
          } else if (clickCount === 4) {
            numberToSpeak = 1296; // 1000 + 0 + 90 + 9 = 1099, but voice says cumulative total 1296
          } else {
            const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
            numberToSpeak = currentTotal;
          }
        } else if (square === 1369) {
          // For 1369, override voice:
          // 1st click: 1000 (first component)
          // 2nd click: 1300 (1000 + 300)
          // 3rd click: 1360 (1000 + 300 + 60)
          // 4th click: 9   (just the ones place)
          // 5th click and beyond: should not reach here (reset happens first)
          if (clickCount === 1) {
            numberToSpeak = 1000;
          } else if (clickCount === 2) {
            numberToSpeak = 1300;
          } else if (clickCount === 3) {
            numberToSpeak = 1360;
          } else if (clickCount === 4) {
            numberToSpeak = 9;
          } else {
            // Should not reach here - reset should have happened
            // But if we do, don't speak anything weird
            numberToSpeak = 0;
          }
        } else if (square === 1225 && clickCount === 2) {
          numberToSpeak = 1200;
        } else if (square === 1225 && clickCount === 3) {
          numberToSpeak = 1220;
        } else if (square === 1225 && clickCount === 4) {
          numberToSpeak = 1225;
        } else if (square === 2601 && clickCount === 2) {
          numberToSpeak = 2600; // 2000 + 600
        } else if (square === 2601 && clickCount === 3) {
          numberToSpeak = 2601; // 2000 + 600 + 1
        } else if (square === 2704 && clickCount === 2) {
          numberToSpeak = 2700; // 2000 + 700
        } else if (square === 2704 && clickCount === 3) {
          numberToSpeak = 2704; // 2000 + 700 + 4
        } else {
          const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
          numberToSpeak = currentTotal;
        }
        // Speak for all squares
        speakNumber(numberToSpeak);
        
        // Show answer when all components are filled (all dots are colored)
        // Check if we've processed all non-zero components OR if all dots are filled
        const nonZeroComponents = components.filter(c => c > 0);
        const processedNonZero = components.slice(0, clickCount).filter(c => c > 0).length;
        const allDotsFilled = filledCount.count >= square;
        
        // Special handling for second 39×39 grid - show answer on 4th click
        // Only show if at least one click has occurred
        if (clickCount > 0 && answerDisplay) {
          const isSecond39Grid = grid.id === 'square-1521-2';
          if (isSecond39Grid && clickCount === 4) {
            answerDisplay.classList.add('show');
          } else if (clickCount > 0 && (clickCount >= totalClicks || processedNonZero >= nonZeroComponents.length || allDotsFilled)) {
            // Append to section only when showing
            if (!answerDisplay.parentNode) {
              section.appendChild(answerDisplay);
            }
            answerDisplay.dataset.allowShow = 'true';
            answerDisplay.classList.add('show');
            answerDisplay.textContent = square;
          }
        }
      }
  });
  
  return section;
}

// Generate squares from 5^2 to 25^2
const moreSquaresContainer = document.getElementById('moreSquares');
if (moreSquaresContainer) {
  // Keep moreSquares AFTER 5² in DOM (its original position)
  // With column-reverse: DOM [1², 2², 3², 4², 5², moreSquares] → Visual [moreSquares content, 5², 4², 3², 2², 1²]
  // We want Visual [1², 2², 3², 4², 5², 6², ...]
  // So we need to reverse the sections 1-5, OR ensure moreSquares content appears after 5²
  // Actually, since moreSquares is last in DOM, its content appears FIRST visually
  // To get 6² after 5², we need 6² to be LAST in moreSquares DOM (appears FIRST in moreSquares, which is right before 5² visually)
  // Wait, that's confusing. Let me keep it simple: append 6-36 in reverse so 6² is last
  
  // Replace 5² section (keep it where it is)
  const existing25Section = document.querySelector('#square-25')?.closest('.set');
  if (existing25Section) {
    const newSection = generateSquare(5);
    existing25Section.replaceWith(newSection);
  }

  // Remove any existing 37² (1369) and 38² (1444) grids if they exist
  const existing1369 = document.querySelector('[data-square="1369"]');
  if (existing1369) {
    existing1369.remove();
  }

  // Generate remaining squares from 6^2 to 36^2
  // With column-reverse: DOM [1², 2², 3², 4², 5², moreSquares] → Visual [moreSquares content, 5², 4², 3², 2², 1²]
  // We want Visual [1², 2², 3², 4², 5², 6², 7², ...]
  // Since moreSquares is last in DOM, it appears FIRST visually
  // To get 6² right after 5² visually, 6² needs to be LAST in moreSquares DOM
  // (so it appears FIRST in moreSquares visually, which is right before 5², meaning right after 5² when scrolling)
  // Append in reverse: 36, 35, ..., 6 so 6² is appended last
  for (let n = 36; n >= 6; n--) {
    moreSquaresContainer.appendChild(generateSquare(n));
  }

  // Add spacing after 36²
  const spacingDiv = document.createElement('div');
  spacingDiv.style.height = '80px';
  spacingDiv.style.width = '100%';
  moreSquaresContainer.appendChild(spacingDiv);

  // Create a single 37×37 grid (37 rows × 37 columns = 1369 dots)
  const row37Section = document.createElement('section');
  row37Section.className = 'set';
  row37Section.style.marginBottom = '40px';
  
  // Add h2 heading "37²"
  const h2 = document.createElement('h2');
  h2.textContent = '37²';
  row37Section.appendChild(h2);
  
  const row37Grid = document.createElement('div');
  row37Grid.className = 'grid-dynamic grid-1369';
  row37Grid.style.gap = '0'; // No gap between dots - they touch tangentially
  
  // Create all 1369 dots (37 rows × 37 columns) in normal order so row 1 appears at the top
  // Skip row 8 (the numbered row that was removed)
  const row37Circles = [];
  // Create rows in normal order: row 1 first (top), then rows 2-7, skip row 8, then rows 9-37 (bottom)
  for (let row = 0; row < 38; row++) {
    if (row === 7) continue; // Skip row 8 (the numbered row)
    for (let col = 0; col < 37; col++) {
      const circle = document.createElement('div');
      circle.className = 'circle';
      row37Grid.appendChild(circle);
      row37Circles.push(circle);
    }
  }
  
  // Verify: 37 rows × 37 columns = 1369 dots
  console.log(`Grid created: ${row37Circles.length} dots (should be 1369 for 37×37 matrix)`);
  
  // Track click count for two-click behavior
  let clickCount = 0;
  // With normal order (row 8 removed): rows 1-3 are at top (indices 0-110), rows 4-7 are next (indices 111-258), 
  // row 9 becomes row 8 (indices 259-295), row 10 becomes row 9 (indices 296-332), row 11 becomes row 10 (indices 333-369),
  // rows 12-38 become rows 11-37 (indices 370-1368)
  const firstDotOfRow10 = 333; // Index 333 - first dot of row 10 (was row 11)
  const row1EndIndex = 36; // Index 36 - end of row 1
  const row2EndIndex = 73; // Index 73 - end of row 2
  const row3EndIndex = 110; // Index 110 - end of row 3
  const row4EndIndex = 147; // Index 147 - end of row 4
  const row5EndIndex = 184; // Index 184 - end of row 5
  const row6EndIndex = 221; // Index 221 - end of row 6
  const row7EndIndex = 258; // Index 258 - end of row 7
  const row8EndIndex = 295; // Index 295 - end of row 8 (was row 9)
  const row9EndIndex = 332; // Index 332 - end of row 9 (was row 10)
  const row10EndIndex = 369; // Index 369 - end of row 10 (was row 11)
  const bottom27RowsStartIndex = 370; // Index 370 - start of rows 11-37 (was rows 12-38)
  const bottom27RowsEndIndex = 37 * 37 - 1; // Index 1368 - end of rows 11-37 (27 rows)
  const last10DotsRightStart = 27; // Index 27 - start of last 10 dots on right (dots 10-1)
  const last10DotsRightEnd = 36; // Index 36 - end of last 10 dots on right
  const skyBlue3DotsStart = 34; // Index 34 - start of 3 sky blue dots (dots 3-1)
  const skyBlue3DotsEnd = 36; // Index 36 - end of 3 sky blue dots
  const purple7DotsStart = 27; // Index 27 - start of 7 purple dots (dots 10-4)
  const purple7DotsEnd = 33; // Index 33 - end of 7 purple dots
  
  // Add click handler with multi-click behavior
  let redCounter = 0;
  let yellowCounter = 0;
  let purpleCounter = 0;
  let skyBlueCounter = 0;
  
  row37Grid.addEventListener('click', () => {
    if (clickCount === 0) {
      // First click: All 27×37 dots (999 dots from rows 11-37) turn red, plus the first dot of row 10 = 1000 red dots
      // Rows 11-37 are indices 370-1368, plus first dot of row 10 (index 333)
      redCounter = 0;
      row37Circles[firstDotOfRow10].classList.remove(...COLOR_CLASSES, 'red', 'red-final', 'yellow');
      row37Circles[firstDotOfRow10].classList.add('red');
      redCounter++;
      for (let i = bottom27RowsStartIndex; i <= bottom27RowsEndIndex; i++) {
        row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final', 'yellow');
        row37Circles[i].classList.add('red');
        redCounter++;
      }
      speakNumber(1000); // Cumulative: 1000 dots (1000 red)
      clickCount = 1;
    } else if (clickCount === 1) {
      // Second click: Yellow dots come in
      yellowCounter = 0;
      // Rows 1-3 (indices 0-110): first 27 dots of each row turn yellow
      for (let rowOffset = 0; rowOffset < 3; rowOffset++) {
        const rowStartIndex = rowOffset * 37;
        for (let i = rowStartIndex; i < rowStartIndex + purple7DotsStart; i++) {
          row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final');
          row37Circles[i].classList.add('yellow');
          yellowCounter++;
        }
      }
      // Rows 4-7 (indices 111-258): first 27 dots of each row turn yellow (last 10 will be purple)
      for (let rowOffset = 3; rowOffset < 7; rowOffset++) {
        const rowStartIndex = rowOffset * 37;
        for (let i = rowStartIndex; i < rowStartIndex + last10DotsRightStart; i++) {
          row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final');
          row37Circles[i].classList.add('yellow');
          yellowCounter++;
        }
      }
      // Rows 8-10 (indices 259-369): all turn yellow except first dot of row 10 (red)
      // Row 8 (indices 259-295, was row 9): all turn yellow
      for (let i = 259; i <= row8EndIndex; i++) {
        row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final');
        row37Circles[i].classList.add('yellow');
        yellowCounter++;
      }
      // Row 9 (indices 296-332, was row 10): all turn yellow
      for (let i = 296; i <= row9EndIndex; i++) {
        row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final');
        row37Circles[i].classList.add('yellow');
        yellowCounter++;
      }
      // Row 10 (indices 333-369, was row 11): all turn yellow except first dot (red)
      for (let i = firstDotOfRow10 + 1; i <= row10EndIndex; i++) {
        row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final');
        row37Circles[i].classList.add('yellow');
        yellowCounter++;
      }
      // Ensure the first dot of row 10 stays red
      row37Circles[firstDotOfRow10].classList.remove(...COLOR_CLASSES, 'yellow');
      row37Circles[firstDotOfRow10].classList.add('red');
      // Add the dot that would have been purple dot #52 (index 249, row 7, first of last 10 dots) to yellow on second click
      const purpleDot52Index = 6 * 37 + last10DotsRightStart; // Row 7, first of last 10 dots = index 249
      row37Circles[purpleDot52Index].classList.remove(...COLOR_CLASSES, 'red', 'red-final');
      row37Circles[purpleDot52Index].classList.add('yellow');
      yellowCounter++;
      speakNumber(1300); // Cumulative: 1300 dots (1000 red + 300 yellow)
      clickCount = 2;
    } else if (clickCount === 2) {
      // Third click: Purple dots come in
      purpleCounter = 0;
      // Rows 1-3 (indices 0-110): next 7 dots of each row turn purple
      for (let rowOffset = 0; rowOffset < 3; rowOffset++) {
        const rowStartIndex = rowOffset * 37;
        for (let i = rowStartIndex + purple7DotsStart; i <= rowStartIndex + purple7DotsEnd; i++) {
          row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final', 'yellow');
          row37Circles[i].classList.add('purple');
          purpleCounter++;
        }
      }
      // Rows 4-7 (indices 111-258): last 10 dots of each row turn purple, except the dot that would have been purple dot #52 (already yellow)
      // Purple dots: rows 1-3 (21 dots), row 4 (10 dots = purple #22-31), row 5 (10 dots = purple #32-41), 
      // row 6 (10 dots = purple #42-51), row 7 (9 dots = purple #52-60, first dot already yellow)
      const purpleDot52Index = 6 * 37 + last10DotsRightStart; // Row 7, first of last 10 dots = index 249 (already yellow)
      for (let rowOffset = 3; rowOffset < 7; rowOffset++) {
        const rowStartIndex = rowOffset * 37;
        for (let i = rowStartIndex + last10DotsRightStart; i <= rowStartIndex + 36; i++) {
          if (i === purpleDot52Index) {
            // Skip this dot - it's already yellow from second click
            continue;
          }
          row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final', 'yellow');
          row37Circles[i].classList.add('purple');
          purpleCounter++;
        }
      }
      speakNumber(1360); // Cumulative: 1360 dots (1000 red + 300 yellow + 60 purple)
      clickCount = 3;
    } else if (clickCount === 3) {
      // Fourth click: Sky blue dots come in - last 3 dots of rows 1-3 turn sky blue
      skyBlueCounter = 0;
      for (let rowOffset = 0; rowOffset < 3; rowOffset++) {
        const rowStartIndex = rowOffset * 37;
        for (let i = rowStartIndex + skyBlue3DotsStart; i <= rowStartIndex + skyBlue3DotsEnd; i++) {
          row37Circles[i].classList.remove(...COLOR_CLASSES, 'red', 'red-final', 'yellow', 'purple');
          row37Circles[i].classList.add('sky');
          skyBlueCounter++;
        }
      }
      speakNumber(1369); // Cumulative: 1369 dots (1000 red + 300 yellow + 60 purple + 9 sky blue)
      clickCount = 4;
      // Show answer display after 4th click
      const answerDisplay = row37Section.querySelector('.answer-display');
      if (answerDisplay) {
        answerDisplay.classList.add('show');
      }
    } else {
      // Reset on fifth click
      speakNumber(0); // Cumulative: 0 dots (reset)
      row37Circles.forEach((circle, index) => {
        circle.classList.remove(...COLOR_CLASSES, 'red', 'red-final', 'yellow', 'purple', 'sky');
        // Remove all number spans
        const existingNumber = circle.querySelector('.circle-number');
        if (existingNumber) {
          existingNumber.remove();
        }
      });
      // Hide answer display on reset
      const answerDisplay = row37Section.querySelector('.answer-display');
      if (answerDisplay) {
        answerDisplay.classList.remove('show');
      }
      redCounter = 0;
      yellowCounter = 0;
      purpleCounter = 0;
      skyBlueCounter = 0;
      clickCount = 0;
    }
  });
  
  row37Section.appendChild(row37Grid);
  
  // Add answer display showing "1369"
  const answerDisplay = document.createElement('div');
  answerDisplay.className = 'answer-display';
  answerDisplay.dataset.answer = '1369';
  answerDisplay.textContent = '1369';
  row37Section.appendChild(answerDisplay);
  
  moreSquaresContainer.appendChild(row37Section);
  
  // Create a 38×38 grid (38 rows × 38 columns = 1444 dots)
  const row38Section = document.createElement('section');
  row38Section.className = 'set';
  row38Section.style.marginBottom = '40px';
  
  // Add h2 heading "38²"
  const h2_38 = document.createElement('h2');
  h2_38.textContent = '38²';
  row38Section.appendChild(h2_38);
  
  const row38Grid = document.createElement('div');
  row38Grid.className = 'grid-dynamic grid-1444';
  row38Grid.style.gap = '0'; // No gap between dots - they touch tangentially
  row38Grid.style.position = 'relative'; // Allow absolute positioning for offset dots
  
  // Create all 1444 dots (38 rows × 38 columns)
  const row38Circles = [];
  for (let row = 0; row < 38; row++) {
    for (let col = 0; col < 38; col++) {
      const circle = document.createElement('div');
      circle.className = 'circle';
      row38Grid.appendChild(circle);
      row38Circles.push(circle);
    }
  }
  
  // Add answer display showing "1444" (create before click handler)
  const answerDisplay38 = document.createElement('div');
  answerDisplay38.className = 'answer-display';
  answerDisplay38.dataset.answer = '1444';
  answerDisplay38.textContent = '1444';
  
  // Add click handler for 38×38 grid (1444 = 1000 + 400 + 40 + 4)
  let row38ClickCount = 0;
  const lastTwoCols = new Set([36, 37]); // Last 2 columns for 38×38 grid
  const row38SeparatedCircles = []; // Track separated circles for the 11×4 rectangle
  
  row38Grid.addEventListener('click', (e) => {
    if (e.target.dataset.originalRow !== undefined) {
      return;
    }
    
    row38ClickCount++;
    
    if (row38ClickCount === 1) {
      // First click: Fill 1000 dots red from bottom, excluding 20×20 square in top left (400 dots) and 11×4 grid in top right (44 dots)
      // 20×20 square in top left corner: rows 0-19, cols 0-19 (400 dots) - leave black for green on second click
      // Top right 11×4 grid: rows 0-10, cols 34-37 (44 dots) - leave black
      const excludedIndices = new Set();
      // 20×20 square in top left corner: rows 0-19, cols 0-19
      for (let row = 0; row < 20; row++) {
        for (let col = 0; col < 20; col++) {
          excludedIndices.add(row * 38 + col);
        }
      }
      // 11×4 grid in top right corner: rows 0-10, cols 34-37
      for (let row = 0; row < 11; row++) {
        for (let col = 34; col < 38; col++) {
          excludedIndices.add(row * 38 + col);
        }
      }
      
      // Fill from bottom row upward, left to right within each row, excluding 20×20 square and top right 11×4 grid
      let filledCount = 0;
      for (let row = 37; row >= 0 && filledCount < 1000; row--) {
        for (let col = 0; col < 38 && filledCount < 1000; col++) {
          const index = row * 38 + col;
          if (!excludedIndices.has(index)) {
            row38Circles[index].classList.remove(...COLOR_CLASSES, 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
            row38Circles[index].classList.add('red');
            filledCount++;
          }
        }
      }
      speakNumber(1000);
    } else if (row38ClickCount === 2) {
      // Second click: Fill 20×20 square in top left corner (400 green dots)
      // NO MOVEMENT - only color changes
      // 20×20 square: rows 0-19, cols 0-19 (400 green dots)
      // Top right corner: rows 0-10, cols 34-37 (11 rows × 4 columns = 44 dots) - stays black, no movement
      let greenCount = 0;
      for (let row = 0; row < 20; row++) {
        for (let col = 0; col < 20; col++) {
          const index = row * 38 + col;
          // Turn all dots in 20×20 square green (don't change red dots if any overlap)
          if (!row38Circles[index].classList.contains('red')) {
            row38Circles[index].classList.remove(...COLOR_CLASSES, 'blue', 'orange', 'yellow', 'purple', 'sky', 'brown', 'pink');
            row38Circles[index].classList.add('green');
            greenCount++;
          }
        }
      }
      
      speakNumber(1000 + greenCount);
    } else if (row38ClickCount === 3) {
      // Third click: Color 40 dots of the rectangle green, leaving the top-right 2×2 square (4 dots) black
      // NO MOVEMENT - only color changes on original circles
      const rectangleRows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // 11 rows
      const rectangleCols = [34, 35, 36, 37]; // 4 columns
      
      // Color 40 dots of the rectangle green (all except top-right 2×2 square)
      // The top-right 2×2 square is rows 0-1, cols 36-37 of the rectangle
      // Work with original circles since no movement has occurred yet
      rectangleRows.forEach(row => {
        rectangleCols.forEach(col => {
          // Skip the top-right 2×2 square (rows 0-1, cols 36-37) - keep it black
          if (row < 2 && col >= 36) {
            return; // Leave these 4 dots black
          }
          
          // Use original circle (no separated circles exist yet)
          const index = row * 38 + col;
          const originalCircle = row38Circles[index];
          
          if (originalCircle) {
            // Only change color classes - do not modify position, left, top, or any style properties that affect position
            originalCircle.classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange', 'yellow', 'purple', 'sky', 'brown', 'pink');
            originalCircle.classList.add('green');
          }
        });
      });
      
      speakNumber(1440);
    } else if (row38ClickCount === 4) {
      // Fourth click: Move ONLY the 2×2 black square (rows 0-1, cols 36-37) right 0.5 dot and up 0.5 dot, then turn green
      // Do NOT move the 11×4 rectangle - only move the 4 dots in the top right corner
      const circleSizeVar = 'var(--circle-total-1444)';
      const twoByTwoRows = [0, 1];
      const twoByTwoCols = [36, 37];
      
      // Move ONLY the 2×2 square (4 dots) by creating separated circles offset right 0.5 and up 0.5
      twoByTwoRows.forEach(row => {
        twoByTwoCols.forEach(col => {
          const index = row * 38 + col;
          const originalCircle = row38Circles[index];
          
          // Create a separated circle for this position
          const separatedCircle = document.createElement('div');
          separatedCircle.className = 'circle';
          // Store original position as data attributes for easy lookup
          separatedCircle.dataset.originalRow = row;
          separatedCircle.dataset.originalCol = col;
          // Copy all classes from original circle (including color classes)
          originalCircle.classList.forEach(cls => {
            separatedCircle.classList.add(cls);
          });
          // Remove any color classes that shouldn't be copied, then re-add the current ones
          separatedCircle.classList.remove(...COLOR_CLASSES);
          // Copy current color state
          if (originalCircle.classList.contains('red')) {
            separatedCircle.classList.add('red');
          } else if (originalCircle.classList.contains('green')) {
            separatedCircle.classList.add('green');
          }
          // If it's black, it stays black (no color class added)
          
          // Position offset: right 0.5 dot, up 0.5 dot
          separatedCircle.style.position = 'absolute';
          separatedCircle.style.left = `calc(${circleSizeVar} * ${col} + 0.5 * ${circleSizeVar})`;
          separatedCircle.style.top = `calc(${circleSizeVar} * ${row} - 0.5 * ${circleSizeVar})`;
          separatedCircle.style.display = 'block';
          separatedCircle.style.visibility = 'visible';
          separatedCircle.style.opacity = '1';
          row38Grid.appendChild(separatedCircle);
          row38SeparatedCircles.push(separatedCircle);
          
          // Hide the original circle
          originalCircle.style.visibility = 'hidden';
          
          // Turn it green
          separatedCircle.classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange', 'yellow', 'purple', 'sky', 'brown', 'pink');
          separatedCircle.classList.add('green');
        });
      });
      
      answerDisplay38.classList.add('show');
      speakNumber(1444);
    } else if (row38ClickCount === 5) {
      // Fifth click: Reset
      row38ClickCount = 0;
      answerDisplay38.classList.remove('show');
      
      // Remove separated circles
      row38SeparatedCircles.forEach(separatedCircle => {
        separatedCircle.remove();
      });
      row38SeparatedCircles.length = 0;
      
      // Reset all original circles
      row38Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
        circle.style.visibility = 'visible'; // Make sure all circles are visible again
      });
      speakNumber(0);
    }
  });
  
  row38Section.appendChild(row38Grid);
  row38Section.appendChild(answerDisplay38);
  
  moreSquaresContainer.appendChild(row38Section);
  
  // Add a second 39×39 grid
  const second39Section = document.createElement('section');
  second39Section.className = 'set';
  second39Section.style.marginBottom = '40px';
  
  // Add h2 heading "39²" - EXACTLY like 38² grid
  const h2_39 = document.createElement('h2');
  h2_39.textContent = '39²';
  second39Section.appendChild(h2_39);
  
  // Create the grid element - EXACTLY like 38² grid
  const second39Grid = document.createElement('div');
  second39Grid.className = 'grid-dynamic grid-1521';
  second39Grid.id = 'square-1521-2';
  second39Grid.style.gap = '0';
  second39Grid.style.position = 'relative';
  
  // Create all 1521 circles (39 rows × 39 columns) - EXACTLY like 38² grid
  const second39Circles = [];
  for (let row = 0; row < 39; row++) {
    for (let col = 0; col < 39; col++) {
      const circle = document.createElement('div');
      circle.className = 'circle';
      second39Grid.appendChild(circle);
      second39Circles.push(circle);
    }
  }
  
  // Add the grid to the section
  second39Section.appendChild(second39Grid);
  
  // Add answer display - EXACTLY like 38² grid
  const second39AnswerDisplay = document.createElement('div');
  second39AnswerDisplay.className = 'answer-display';
  second39AnswerDisplay.id = 'answer-1521-2';
  second39AnswerDisplay.dataset.answer = '1521';
  second39AnswerDisplay.textContent = '1521';
  second39Section.appendChild(second39AnswerDisplay);
  
  // Add click handler - use the same pattern as the second 39×39 grid click handler
  let second39ClickCount = 0;
  const lastThreeCols = new Set([36, 37, 38]);
  second39Grid.addEventListener('click', (e) => {
    if (e.target.dataset.originalRow !== undefined) {
      return;
    }
    
    second39ClickCount++;
    
    if (second39ClickCount === 1) {
      // First click: Fill 1000 dots red from bottom, excluding last 3 columns in top 2 rows
      // Use optimized batch update
      const indicesToFill = [];
      let filledCount = 0;
      // Fill from bottom row upward, left to right within each row
      for (let row = 38; row >= 0 && filledCount < 1000; row--) {
        for (let col = 0; col < 39 && filledCount < 1000; col++) {
          const index = row * 39 + col;
          // Skip last 3 columns in top 2 rows (rows 0 and 1)
          if (!((row === 0 || row === 1) && lastThreeCols.has(col))) {
            indicesToFill.push(index);
            filledCount++;
          }
        }
      }
      // Batch update all at once for better performance
      batchUpdateCircles(second39Circles, indicesToFill, 'red', [...COLOR_CLASSES, 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink']);
      speakNumber(1000);
    } else if (second39ClickCount === 2) {
      // Second click: Fill exactly 500 dots blue
      // Pattern matches original 39x39 grid:
      // - Top row (row 0): all blue except last 3 columns (36 dots)
      // - Rows 1-6: all blue except last 3 columns (36 dots each = 216 dots)
      // - Rows 7-12: all blue (6 rows × 39 = 234 dots)
      // - Row 13: 14 black dots turn blue (14 dots)
      // Total: 36 + 216 + 234 + 14 = 500 blue dots
      
      // Top row (row 0): all blue except last 3 columns
      for (let col = 0; col < 39; col++) {
        const index = 0 * 39 + col;
        if (lastThreeCols.has(col)) {
          // Keep last 3 columns black
          second39Circles[index].classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
        } else {
          // Turn blue (change red to blue if needed)
          second39Circles[index].classList.remove(...COLOR_CLASSES, 'red', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
          second39Circles[index].classList.add('blue');
        }
      }
      
      // Rows 1-6: all blue except last 3 columns
      for (let row = 1; row < 7; row++) {
        for (let col = 0; col < 39; col++) {
          const index = row * 39 + col;
          if (lastThreeCols.has(col)) {
            // Keep last 3 columns black
            second39Circles[index].classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
          } else {
            // Turn blue (change red to blue if needed)
            second39Circles[index].classList.remove(...COLOR_CLASSES, 'red', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
            second39Circles[index].classList.add('blue');
          }
        }
      }
      
      // Rows 7-12: all blue
      for (let row = 7; row < 13; row++) {
        for (let col = 0; col < 39; col++) {
          const index = row * 39 + col;
          // Only turn black dots blue (don't change red dots)
          if (!second39Circles[index].classList.contains('red')) {
            second39Circles[index].classList.remove(...COLOR_CLASSES, 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
            second39Circles[index].classList.add('blue');
          }
        }
      }
      
      // Row 13: turn 14 black dots blue
      let blueCountInRow13 = 0;
      for (let col = 0; col < 39 && blueCountInRow13 < 14; col++) {
        const index = 13 * 39 + col;
        // Only turn black dots blue (don't change red dots)
        if (!second39Circles[index].classList.contains('red') && !second39Circles[index].classList.contains('blue')) {
          second39Circles[index].classList.remove(...COLOR_CLASSES, 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
          second39Circles[index].classList.add('blue');
          blueCountInRow13++;
        }
      }
      
      speakNumber(1500);
    } else if (second39ClickCount === 3) {
      // Third click: All remaining black dots turn orange except top-right corner
      // Keep red dots red, keep blue dots blue, only change black dots to orange
      second39Circles.forEach((circle, index) => {
        const actualRow = Math.floor(index / 39);
        const actualCol = index % 39;
        // Skip if it's blue (keep blue)
        if (circle.classList.contains('blue')) {
          return;
        }
        // Skip if it's red (keep red)
        if (circle.classList.contains('red')) {
          return;
        }
        // Skip top-right corner (keep it black for now)
        if (actualRow === 0 && actualCol === 38) {
          return;
        }
        // Turn remaining black dots orange
        circle.classList.remove(...COLOR_CLASSES, 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
        circle.classList.add('orange');
      });
      speakNumber(1520);
    } else if (second39ClickCount === 4) {
      // Fourth click: Top-right corner turns red, show answer
      const topRightIndex = 0 * 39 + 38;
      second39Circles[topRightIndex].classList.remove(...COLOR_CLASSES, 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
      second39Circles[topRightIndex].classList.add('red');
      second39AnswerDisplay.classList.add('show');
      speakNumber(1521);
    } else if (second39ClickCount === 5) {
      // Fifth click: Reset
      second39ClickCount = 0;
      second39AnswerDisplay.classList.remove('show');
      second39Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'red', 'blue', 'orange', 'green', 'yellow', 'purple', 'sky', 'brown', 'pink');
      });
    }
  });
  
  // Debug: Log everything before appending
  console.log('=== BEFORE APPENDING 39² SECTION ===');
  console.log('Section element:', second39Section);
  console.log('Section children:', Array.from(second39Section.children).map(c => c.tagName + (c.id ? '#' + c.id : '') + (c.className ? '.' + c.className : '')));
  console.log('Heading element:', h2_39);
  console.log('Heading text:', h2_39.textContent);
  console.log('Heading computed style display:', window.getComputedStyle(h2_39).display);
  console.log('Heading computed style visibility:', window.getComputedStyle(h2_39).visibility);
  console.log('Heading computed style opacity:', window.getComputedStyle(h2_39).opacity);
  console.log('Heading computed style color:', window.getComputedStyle(h2_39).color);
  console.log('Heading offsetHeight:', h2_39.offsetHeight);
  console.log('Heading offsetWidth:', h2_39.offsetWidth);
  console.log('Heading offsetTop:', h2_39.offsetTop);
  console.log('Heading offsetLeft:', h2_39.offsetLeft);
  console.log('Grid element:', second39Grid);
  console.log('Grid offsetTop:', second39Grid.offsetTop);
  
  moreSquaresContainer.appendChild(second39Section);
  
  // Generate remaining squares from 40^2 to 52^2 in REVERSE order (for column-reverse layout)
  // Append 52 first, then 51, 50, ..., 40 so they appear visually as 40, 41, 42, ..., 52
  for (let n = 52; n >= 40; n--) {
    moreSquaresContainer.appendChild(generateSquare(n));
  }
  
  // Create 53×53 grid (2809 dots) with special click behavior
  const grid53Section = document.createElement('section');
  grid53Section.className = 'set';
  grid53Section.dataset.square = '2809';
  grid53Section.dataset.base = '53';
  grid53Section.style.marginBottom = '40px';
  
  // Add h2 heading "53²"
  const h2_53 = document.createElement('h2');
  h2_53.textContent = '53²';
  grid53Section.appendChild(h2_53);
  
  const grid53 = document.createElement('div');
  grid53.className = 'grid-dynamic grid-2809';
  grid53.id = 'square-2809';
  grid53.style.gridTemplateColumns = 'repeat(53, var(--circle-total))';
  grid53.style.gridTemplateRows = 'repeat(53, var(--circle-total))';
  grid53.style.width = 'calc(var(--circle-total) * 53)';
  grid53.style.height = 'calc(var(--circle-total) * 53)';
  grid53.style.position = 'relative';
  
  const gridSize53 = 53;
  const totalDots53 = 2809;
  const grid53Circles = [];
  
  // Create all 2809 circles with numbers
  for (let i = 0; i < totalDots53; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-2809';
    
    // Calculate dot number (right to left, row by row)
    const row = Math.floor(i / gridSize53);
    const col = i % gridSize53;
    const dotNumber = row * gridSize53 + (gridSize53 - col);
    
    // Store dot number in data attribute (no visible number displayed)
    circle.dataset.dotNumber = dotNumber.toString();
    
    grid53.appendChild(circle);
    grid53Circles.push(circle);
  }
  
  grid53Section.appendChild(grid53);
  
  // Add answer display
  const answerDisplay53 = document.createElement('div');
  answerDisplay53.className = 'answer-display';
  answerDisplay53.dataset.answer = '2809';
  grid53Section.appendChild(answerDisplay53);
  
  // Click handler for 53×53 grid
  let clickCount53 = 0;
  
  grid53.addEventListener('click', () => {
    if (clickCount53 === 0) {
      // First click: Fill 2000 orange dots from bottom row
      // Start from bottom row (row 52) and work upwards
      let orangeCount = 0;
      for (let row = gridSize53 - 1; row >= 0 && orangeCount < 2000; row--) {
        for (let col = 0; col < gridSize53 && orangeCount < 2000; col++) {
          const idx = row * gridSize53 + col;
          grid53Circles[idx].classList.remove(...COLOR_CLASSES);
          grid53Circles[idx].classList.add('orange');
          orangeCount++;
        }
      }
      speakNumber(2000);
      clickCount53 = 1;
    } else if (clickCount53 === 1) {
      // Second click: Fill pink dots everywhere except a 3x3 square (which stays black)
      // The 3x3 square should be in the top-right corner (rows 0-2, cols 50-52)
      const blackSquareRows = [0, 1, 2];
      const blackSquareCols = [50, 51, 52];
      const blackSquareIndices = new Set();
      
      for (let row of blackSquareRows) {
        for (let col of blackSquareCols) {
          blackSquareIndices.add(row * gridSize53 + col);
        }
      }
      
      let pinkCount = 0;
      for (let i = 0; i < totalDots53; i++) {
        // Skip the 3x3 black square
        if (!blackSquareIndices.has(i)) {
          // Only fill if not already orange (from first click)
          if (!grid53Circles[i].classList.contains('orange')) {
            grid53Circles[i].classList.remove(...COLOR_CLASSES);
            grid53Circles[i].classList.add('pink');
            pinkCount++;
          }
        }
      }
      speakNumber(2800); // 2000 orange + 800 pink
      clickCount53 = 2;
    } else if (clickCount53 === 2) {
      // Third click: Fill the 3x3 square with sky blue
      const blackSquareRows = [0, 1, 2];
      const blackSquareCols = [50, 51, 52];
      
      for (let row of blackSquareRows) {
        for (let col of blackSquareCols) {
          const idx = row * gridSize53 + col;
          grid53Circles[idx].classList.remove(...COLOR_CLASSES);
          grid53Circles[idx].classList.add('sky');
        }
      }
      speakNumber(2809); // All 2809 dots filled
      clickCount53 = 3;
      
      // Show answer
      if (answerDisplay53) {
        answerDisplay53.textContent = '2809';
        answerDisplay53.classList.add('show');
      }
    } else {
      // Reset on 4th click
      grid53Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'orange', 'pink', 'sky');
      });
      speakNumber(0);
      clickCount53 = 0;
      if (answerDisplay53) {
        answerDisplay53.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid53Section);
  
  // Create 54×54 grid (2916 dots) with special click behavior
  const grid54Section = document.createElement('section');
  grid54Section.className = 'set';
  grid54Section.dataset.square = '2916';
  grid54Section.dataset.base = '54';
  grid54Section.style.marginBottom = '40px';
  
  // Add h2 heading "54²"
  const h2_54 = document.createElement('h2');
  h2_54.textContent = '54²';
  grid54Section.appendChild(h2_54);
  
  const grid54 = document.createElement('div');
  grid54.className = 'grid-dynamic grid-2916';
  grid54.id = 'square-2916';
  grid54.style.gridTemplateColumns = 'repeat(54, var(--circle-total))';
  grid54.style.gridTemplateRows = 'repeat(54, var(--circle-total))';
  grid54.style.width = 'calc(var(--circle-total) * 54)';
  grid54.style.height = 'calc(var(--circle-total) * 54)';
  grid54.style.position = 'relative';
  
  const gridSize54 = 54;
  const totalDots54 = 2916;
  const grid54Circles = [];
  
  // Create all 2916 circles with numbers
  for (let i = 0; i < totalDots54; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-2916';
    
    // Calculate dot number (right to left, row by row)
    const row = Math.floor(i / gridSize54);
    const col = i % gridSize54;
    const dotNumber = row * gridSize54 + (gridSize54 - col);
    
    // Store dot number in data attribute (no visible number displayed)
    circle.dataset.dotNumber = dotNumber.toString();
    
    grid54.appendChild(circle);
    grid54Circles.push(circle);
  }
  
  grid54Section.appendChild(grid54);
  
  // Add answer display
  const answerDisplay54 = document.createElement('div');
  answerDisplay54.className = 'answer-display';
  answerDisplay54.dataset.answer = '2916';
  grid54Section.appendChild(answerDisplay54);
  
  // Click handler for 54×54 grid
  let clickCount54 = 0;
  
  grid54.addEventListener('click', () => {
    if (clickCount54 === 0) {
      // First click: Fill 2000 orange dots from bottom row
      let orangeCount = 0;
      for (let row = gridSize54 - 1; row >= 0 && orangeCount < 2000; row--) {
        for (let col = 0; col < gridSize54 && orangeCount < 2000; col++) {
          const idx = row * gridSize54 + col;
          grid54Circles[idx].classList.remove(...COLOR_CLASSES);
          grid54Circles[idx].classList.add('orange');
          orangeCount++;
        }
      }
      speakNumber(2000);
      clickCount54 = 1;
    } else if (clickCount54 === 1) {
      // Second click: Fill 900 sky blue dots, leaving a 4×4 square in top-right corner (black)
      // The 4×4 square is in the top-right corner: rows 0-3, cols 50-53
      const blackSquareRows = [0, 1, 2, 3];
      const blackSquareCols = [50, 51, 52, 53];
      const blackSquareIndices = new Set();
      
      for (let row of blackSquareRows) {
        for (let col of blackSquareCols) {
          blackSquareIndices.add(row * gridSize54 + col);
        }
      }
      
      let skyBlueCount = 0;
      for (let i = 0; i < totalDots54 && skyBlueCount < 900; i++) {
        // Skip the 4×4 black square and already orange dots
        if (!blackSquareIndices.has(i) && !grid54Circles[i].classList.contains('orange')) {
          grid54Circles[i].classList.remove(...COLOR_CLASSES);
          grid54Circles[i].classList.add('sky');
          skyBlueCount++;
        }
      }
      speakNumber(2900); // 2000 orange + 900 sky blue
      clickCount54 = 2;
    } else if (clickCount54 === 2) {
      // Third click: Fill 10 red dots, leaving a triangle of 6 black dots in top-right corner
      // The 4×4 square has 16 dots. We need to fill 10 red, leaving 6 black in a triangle pattern.
      // Triangle pattern (6 dots): 
      // Row 0: col 50, 51, 52, 53 (4 dots) - fill 2 red, leave 2 black
      // Row 1: col 50, 51, 52 (3 dots) - fill 1 red, leave 2 black  
      // Row 2: col 50, 51 (2 dots) - fill 0 red, leave 2 black
      // Row 3: col 50 (1 dot) - fill 0 red, leave 1 black
      // Actually, let me think of a better triangle pattern:
      // Row 0: col 50, 51, 52, 53 (4 dots) - all black (triangle base)
      // Row 1: col 51, 52, 53 (3 dots) - all black
      // Row 2: col 52, 53 (2 dots) - all black
      // Row 3: col 53 (1 dot) - all black
      // That's 10 dots total, but we need 6 black. Let me reconsider:
      // We have 16 dots in 4×4, fill 10 red, leave 6 black.
      // Triangle with 6 dots:
      // Row 0: col 50, 51, 52, 53 (4 dots) - fill 2 red (cols 50, 51), leave 2 black (cols 52, 53)
      // Row 1: col 50, 51, 52, 53 (4 dots) - fill 2 red (cols 50, 51), leave 2 black (cols 52, 53)
      // Row 2: col 50, 51, 52, 53 (4 dots) - fill 1 red (col 50), leave 3 black (cols 51, 52, 53)
      // Row 3: col 50, 51, 52, 53 (4 dots) - fill 0 red, leave 4 black
      // That's 5 red, not 10. Let me try:
      // Fill 10 red from the 4×4 square, leaving 6 black in triangle:
      // Triangle pattern (6 dots at top-right):
      // Row 0: col 52, 53 (2 dots) - black
      // Row 1: col 51, 52, 53 (3 dots) - black
      // Row 2: col 50, 51, 52, 53 (4 dots) - but we need only 1 more, so col 50 is black
      // Wait, that's 2+3+1=6. But we need to fill 10 red from the 16 dots.
      // Let me think: 16 - 6 = 10, so fill 10 red.
      // Triangle of 6 dots (top-right corner):
      // Row 0: col 52, 53 (2 dots)
      // Row 1: col 51, 52, 53 (3 dots)
      // Row 2: col 50 (1 dot)
      // That's 6 dots. Fill the other 10 with red.
      // Red dots: Row 0: col 50, 51; Row 1: col 50; Row 2: col 51, 52, 53; Row 3: col 50, 51, 52, 53
      // Let me count: Row 0: 2, Row 1: 1, Row 2: 3, Row 3: 4 = 10 red ✓
      // Black triangle: Row 0: col 52, 53; Row 1: col 51, 52, 53; Row 2: col 50 = 6 black ✓
      
      const blackSquareRows = [0, 1, 2, 3];
      const blackSquareCols = [50, 51, 52, 53];
      
      // Define the pattern (6 black dots to remain in top-right corner)
      // Pattern: Top row (row 0): 3 purple dots all the way to the right (cols 51, 52, 53)
      //          Second row (row 1): 2 purple dots all the way to the right (cols 52, 53)
      //          Third row (row 2): 1 purple dot all the way to the right (col 53)
      // For 54×54 4×4 square (rows 0-3, cols 50-53): 
      // Row 0: cols 51, 52, 53 (3 dots)
      // Row 1: cols 52, 53 (2 dots)
      // Row 2: col 53 (1 dot)
      const purpleIndices = new Set([
        0 * gridSize54 + 51, // Row 0, col 51 (3 dots - leftmost)
        0 * gridSize54 + 52, // Row 0, col 52 (3 dots - middle)
        0 * gridSize54 + 53, // Row 0, col 53 (3 dots - rightmost)
        1 * gridSize54 + 52, // Row 1, col 52 (2 dots - left)
        1 * gridSize54 + 53, // Row 1, col 53 (2 dots - right)
        2 * gridSize54 + 53  // Row 2, col 53 (1 dot - rightmost)
      ]);
      
      // Fill 10 red dots in the 4×4 square (all except the 6 purple rectangle dots)
      let redCount = 0;
      for (let row of blackSquareRows) {
        for (let col of blackSquareCols) {
          const idx = row * gridSize54 + col;
          if (!purpleIndices.has(idx) && redCount < 10) {
            grid54Circles[idx].classList.remove(...COLOR_CLASSES);
            grid54Circles[idx].classList.add('red');
            redCount++;
          }
        }
      }
      speakNumber(2910); // 2000 orange + 900 sky blue + 10 red
      clickCount54 = 3;
    } else if (clickCount54 === 3) {
      // Fourth click: Fill the 6 black dots with purple
      // Pattern: Top row (row 0): 3 purple dots all the way to the right (cols 51, 52, 53)
      //          Second row (row 1): 2 purple dots all the way to the right (cols 52, 53)
      //          Third row (row 2): 1 purple dot all the way to the right (col 53)
      const purpleIndices = [
        0 * gridSize54 + 51, // Row 0, col 51 (3 dots - leftmost)
        0 * gridSize54 + 52, // Row 0, col 52 (3 dots - middle)
        0 * gridSize54 + 53, // Row 0, col 53 (3 dots - rightmost)
        1 * gridSize54 + 52, // Row 1, col 52 (2 dots - left)
        1 * gridSize54 + 53, // Row 1, col 53 (2 dots - right)
        2 * gridSize54 + 53  // Row 2, col 53 (1 dot - rightmost)
      ];
      
      for (let idx of purpleIndices) {
        grid54Circles[idx].classList.remove(...COLOR_CLASSES);
        grid54Circles[idx].classList.add('purple');
      }
      speakNumber(2916); // All 2916 dots filled
      clickCount54 = 4;
      
      // Show answer
      if (answerDisplay54) {
        answerDisplay54.textContent = '2916';
        answerDisplay54.classList.add('show');
      }
    } else {
      // Reset on 5th click
      grid54Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'orange', 'sky', 'red', 'purple');
      });
      speakNumber(0);
      clickCount54 = 0;
      if (answerDisplay54) {
        answerDisplay54.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid54Section);
  
  // Create 55×55 grid (3025 dots) with special click behavior
  const grid55Section = document.createElement('section');
  grid55Section.className = 'set';
  grid55Section.style.marginBottom = '40px';
  
  // Add h2 heading "55²"
  const h2_55 = document.createElement('h2');
  h2_55.textContent = '55²';
  grid55Section.appendChild(h2_55);
  
  const grid55 = document.createElement('div');
  grid55.className = 'grid-dynamic grid-3025';
  grid55.id = 'square-3025';
  grid55.style.gridTemplateColumns = 'repeat(55, var(--circle-total))';
  grid55.style.gridTemplateRows = 'repeat(55, var(--circle-total))';
  grid55.style.width = 'calc(var(--circle-total) * 55)';
  grid55.style.height = 'calc(var(--circle-total) * 55)';
  grid55.style.position = 'relative';
  
  const gridSize55 = 55;
  const totalDots55 = 3025;
  const grid55Circles = [];
  
  // Create all 3025 circles with numbers
  for (let i = 0; i < totalDots55; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3025';
    
    // Calculate dot number (right to left, row by row)
    const row = Math.floor(i / gridSize55);
    const col = i % gridSize55;
    const dotNumber = row * gridSize55 + (gridSize55 - col);
    
    // Store dot number in data attribute (no visible number displayed)
    circle.dataset.dotNumber = dotNumber.toString();
    
    grid55.appendChild(circle);
    grid55Circles.push(circle);
  }
  
  grid55Section.appendChild(grid55);
  
  // Add answer display
  const answerDisplay55 = document.createElement('div');
  answerDisplay55.className = 'answer-display';
  answerDisplay55.dataset.answer = '3025';
  grid55Section.appendChild(answerDisplay55);
  
  // Click handler for 55×55 grid
  let clickCount55 = 0;
  
  grid55.addEventListener('click', () => {
    if (clickCount55 === 0) {
      // First click: Fill 3000 yellow dots, leaving 5×5 square in top-right corner (black)
      // The 5×5 square is in the top-right corner: rows 0-4, cols 50-54
      const blackSquareRows = [0, 1, 2, 3, 4];
      const blackSquareCols = [50, 51, 52, 53, 54];
      const blackSquareIndices = new Set();
      
      for (let row of blackSquareRows) {
        for (let col of blackSquareCols) {
          blackSquareIndices.add(row * gridSize55 + col);
        }
      }
      
      let yellowCount = 0;
      for (let i = 0; i < totalDots55 && yellowCount < 3000; i++) {
        // Skip the 5×5 black square
        if (!blackSquareIndices.has(i)) {
          grid55Circles[i].classList.remove(...COLOR_CLASSES);
          grid55Circles[i].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount55 = 1;
    } else if (clickCount55 === 1) {
      // Second click: Fill 20 orange dots in 5×5 square (first 4 columns)
      // Pattern matches 5×5 grid: rows 0-4, cols 50-53 (first 4 columns)
      const orangeIndices = [];
      for (let row = 0; row < 5 && row < gridSize55; row++) {
        for (let col = 50; col < 54 && col < gridSize55; col++) {
          const idx = row * gridSize55 + col;
          orangeIndices.push(idx);
        }
      }
      
      for (let idx of orangeIndices) {
        grid55Circles[idx].classList.remove(...COLOR_CLASSES);
        grid55Circles[idx].classList.add('orange');
      }
      speakNumber(3020); // 3000 yellow + 20 orange
      clickCount55 = 2;
    } else if (clickCount55 === 2) {
      // Third click: Fill 5 blue dots in 5×5 square (rightmost column)
      // Pattern matches 5×5 grid: rows 0-4, col 54 (rightmost column)
      const blueIndices = [];
      for (let row = 0; row < 5 && row < gridSize55; row++) {
        const idx = row * gridSize55 + 54; // Rightmost column
        blueIndices.push(idx);
      }
      
      for (let idx of blueIndices) {
        grid55Circles[idx].classList.remove(...COLOR_CLASSES);
        grid55Circles[idx].classList.add('blue');
      }
      speakNumber(3025); // All 3025 dots filled
      clickCount55 = 3;
      
      // Show answer
      if (answerDisplay55) {
        answerDisplay55.textContent = '3025';
        answerDisplay55.classList.add('show');
      }
    } else {
      // Reset on 4th click
      grid55Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'orange', 'blue');
      });
      speakNumber(0);
      clickCount55 = 0;
      if (answerDisplay55) {
        answerDisplay55.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid55Section);
  
  // Create 56×56 grid (3136 dots) with special click behavior
  const grid56Section = document.createElement('section');
  grid56Section.className = 'set';
  grid56Section.style.marginBottom = '40px';
  
  // Add h2 heading "56²"
  const h2_56 = document.createElement('h2');
  h2_56.textContent = '56²';
  grid56Section.appendChild(h2_56);
  
  const grid56 = document.createElement('div');
  grid56.className = 'grid-dynamic grid-3136';
  grid56.id = 'square-3136';
  grid56.style.gridTemplateColumns = 'repeat(56, var(--circle-total))';
  grid56.style.gridTemplateRows = 'repeat(56, var(--circle-total))';
  grid56.style.width = 'calc(var(--circle-total) * 56)';
  grid56.style.height = 'calc(var(--circle-total) * 56)';
  grid56.style.position = 'relative'; // Required for absolute positioning of separated circles
  
  // Track separated circles for movement
  const separatedCircles56 = [];
  
  const gridSize56 = 56;
  const totalDots56 = 3136;
  const grid56Circles = [];
  
  // Create all 3136 circles with numbers
  for (let i = 0; i < totalDots56; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3136';
    
    // Calculate dot number (right to left, row by row)
    const row = Math.floor(i / gridSize56);
    const col = i % gridSize56;
    const dotNumber = row * gridSize56 + (gridSize56 - col);
    
    // Store dot number in data attribute (no visible number displayed)
    circle.dataset.dotNumber = dotNumber.toString();
    
    grid56.appendChild(circle);
    grid56Circles.push(circle);
  }
  
  grid56Section.appendChild(grid56);
  
  // Add answer display
  const answerDisplay56 = document.createElement('div');
  answerDisplay56.className = 'answer-display';
  answerDisplay56.dataset.answer = '3136';
  grid56Section.appendChild(answerDisplay56);
  
  // Click handler for 56×56 grid
  let clickCount56 = 0;
  
  grid56.addEventListener('click', () => {
    if (clickCount56 === 0) {
      // First click: Fill 3000 yellow dots, leaving 136 black dots:
      // - 6×6 square in top right corner: rows 0-5, cols 50-55 (36 dots)
      // - 10×10 square directly to the left: rows 0-9, cols 40-49 (100 dots)
      // Total: 36 + 100 = 136 black dots
      const blackSquare6x6Rows = [0, 1, 2, 3, 4, 5];
      const blackSquare6x6Cols = [50, 51, 52, 53, 54, 55];
      const blackSquare10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackSquare10x10Cols = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      const blackIndices = new Set();
      
      // Add 6×6 square indices (top right corner)
      for (let row of blackSquare6x6Rows) {
        for (let col of blackSquare6x6Cols) {
          blackIndices.add(row * gridSize56 + col);
        }
      }
      
      // Add 10×10 square indices (directly to the left of 6×6)
      for (let row of blackSquare10x10Rows) {
        for (let col of blackSquare10x10Cols) {
          blackIndices.add(row * gridSize56 + col);
        }
      }
      
      let yellowCount = 0;
      for (let i = 0; i < totalDots56 && yellowCount < 3000; i++) {
        // Skip the black squares
        if (!blackIndices.has(i)) {
          grid56Circles[i].classList.remove(...COLOR_CLASSES);
          grid56Circles[i].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount56 = 1;
    } else if (clickCount56 === 1) {
      // Second click: 10×10 square turns red (6×6 stays black)
      // 10×10 square: rows 0-9, cols 40-49 (directly to the left of 6×6)
      const blackSquare10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackSquare10x10Cols = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      
      // Fill entire 10×10 square red
      for (let row of blackSquare10x10Rows) {
        for (let col of blackSquare10x10Cols) {
          const idx = row * gridSize56 + col;
          grid56Circles[idx].classList.remove(...COLOR_CLASSES);
          grid56Circles[idx].classList.add('red');
        }
      }
      speakNumber(3100); // 3000 yellow + 100 red
      clickCount56 = 2;
    } else if (clickCount56 === 2) {
      // Third click: Fill 30 yellow dots in 6×6 square and move ENTIRE 6×6 grid up
      // Pattern matches 6×6 grid: fill all except triangle pattern (6 dots)
      const blackSquare6x6Rows = [0, 1, 2, 3, 4, 5];
      const blackSquare6x6Cols = [50, 51, 52, 53, 54, 55];
      
      // Get triangle pattern indices (6 dots) - these will stay black (turn purple on 4th click)
      const triangleIndices = new Set([
        0 * gridSize56 + 53, // Row 0, col 53
        0 * gridSize56 + 54, // Row 0, col 54
        0 * gridSize56 + 55, // Row 0, col 55
        1 * gridSize56 + 54, // Row 1, col 54
        1 * gridSize56 + 55, // Row 1, col 55
        2 * gridSize56 + 55  // Row 2, col 55
      ]);
      
      // Move ALL 36 dots of the 6×6 grid up (both yellow and black/purple)
      for (let row of blackSquare6x6Rows) {
        for (let col of blackSquare6x6Cols) {
          const idx = row * gridSize56 + col;
          const circle = grid56Circles[idx];
          const isTriangleDot = triangleIndices.has(idx);
          
          // Hide the original circle
          circle.style.visibility = 'hidden';
          
          // Create a separated circle that moves up
          const separatedCircle = document.createElement('div');
          // Yellow for non-triangle dots, black for triangle dots (will turn purple on 4th click)
          separatedCircle.className = isTriangleDot ? 'circle' : 'circle yellow';
          separatedCircle.style.position = 'absolute';
          separatedCircle.style.zIndex = '5';
          separatedCircle.dataset.originalRow = row;
          separatedCircle.dataset.originalCol = col;
          separatedCircle.dataset.isTriangleDot = isTriangleDot ? 'true' : 'false';
          
          // Copy size classes
          circle.classList.forEach(cls => {
            if (cls.startsWith('circle-')) {
              separatedCircle.classList.add(cls);
            }
          });
          
          // Move up by 0.5 dot distance (straight up)
          // Use scaled circle size to maintain proper movement when grid shrinks
          separatedCircle.style.left = `calc(var(--circle-total-3136) * ${col})`;
          separatedCircle.style.top = `calc(var(--circle-total-3136) * ${row} - 0.5 * var(--circle-total-3136))`;
          separatedCircle.style.transform = 'none';
          
          grid56.appendChild(separatedCircle);
          separatedCircles56.push(separatedCircle);
        }
      }
      speakNumber(3130); // 3000 yellow + 100 red + 30 yellow
      clickCount56 = 3;
    } else if (clickCount56 === 3) {
      // Fourth click: Fill 6 purple dots in triangle pattern in 6×6 square (which are already moved up)
      // Find the separated circles that are triangle dots and turn them purple
      separatedCircles56.forEach(sc => {
        if (sc.dataset.isTriangleDot === 'true') {
          sc.classList.remove(...COLOR_CLASSES);
          sc.classList.add('purple');
        }
      });
      speakNumber(3136); // All 3136 dots filled
      clickCount56 = 4;
      
      // Show answer
      if (answerDisplay56) {
        answerDisplay56.textContent = '3136';
        answerDisplay56.classList.add('show');
      }
    } else {
      // Reset on 5th click
      // Remove separated circles
      separatedCircles56.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      separatedCircles56.length = 0;
      
      // Show all original circles and reset colors
      grid56Circles.forEach(circle => {
        circle.style.visibility = 'visible';
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'red', 'purple');
      });
      speakNumber(0);
      clickCount56 = 0;
      if (answerDisplay56) {
        answerDisplay56.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid56Section);
  
  // Create 57×57 grid (3249 dots) with special click behavior
  const grid57Section = document.createElement('section');
  grid57Section.className = 'set';
  grid57Section.style.marginBottom = '40px';
  
  // Add h2 heading "57²"
  const h2_57 = document.createElement('h2');
  h2_57.textContent = '57²';
  grid57Section.appendChild(h2_57);
  
  const grid57 = document.createElement('div');
  grid57.className = 'grid-dynamic grid-3249';
  grid57.id = 'square-3249';
  grid57.style.gridTemplateColumns = 'repeat(57, var(--circle-total))';
  grid57.style.gridTemplateRows = 'repeat(57, var(--circle-total))';
  grid57.style.width = 'calc(var(--circle-total) * 57)';
  grid57.style.height = 'calc(var(--circle-total) * 57)';
  grid57.style.position = 'relative';
  
  const gridSize57 = 57;
  const totalDots57 = 3249;
  const grid57Circles = [];
  
  // Create all 3249 circles
  for (let i = 0; i < totalDots57; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3249';
    grid57.appendChild(circle);
    grid57Circles.push(circle);
  }
  
  grid57Section.appendChild(grid57);
  
  // Add answer display
  const answerDisplay57 = document.createElement('div');
  answerDisplay57.className = 'answer-display';
  answerDisplay57.dataset.answer = '3249';
  grid57Section.appendChild(answerDisplay57);
  
  // Click handler for 57×57 grid
  let clickCount57 = 0;
  
  grid57.addEventListener('click', () => {
    if (clickCount57 === 0) {
      // First click: Fill 3000 yellow dots, leaving 249 black dots:
      // - 7×7 square in top right corner: rows 0-6, cols 50-56 (49 dots)
      // - 20×10 rectangle right next to it: rows 0-19, cols 40-49 (200 dots)
      // Total: 49 + 200 = 249 black dots
      const blackSquare7x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackSquare7x7Cols = [50, 51, 52, 53, 54, 55, 56];
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x10Cols = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      const blackIndices = new Set();
      
      // Add 7×7 square indices (top right corner)
      for (let row of blackSquare7x7Rows) {
        for (let col of blackSquare7x7Cols) {
          blackIndices.add(row * gridSize57 + col);
        }
      }
      
      // Add 20×10 rectangle indices (to the left of 7×7)
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          blackIndices.add(row * gridSize57 + col);
        }
      }
      
      let yellowCount = 0;
      for (let i = 0; i < totalDots57 && yellowCount < 3000; i++) {
        // Skip the black squares
        if (!blackIndices.has(i)) {
          grid57Circles[i].classList.remove(...COLOR_CLASSES);
          grid57Circles[i].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount57 = 1;
    } else if (clickCount57 === 1) {
      // Second click: 20×10 rectangle turns orange
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x10Cols = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      
      // Fill entire 20×10 rectangle orange
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          const idx = row * gridSize57 + col;
          grid57Circles[idx].classList.remove(...COLOR_CLASSES);
          grid57Circles[idx].classList.add('orange');
        }
      }
      speakNumber(3200); // 3000 yellow + 200 orange
      clickCount57 = 2;
    } else if (clickCount57 === 2) {
      // Third click: Fill 40 green dots in 7×7 square (all except 3×3 top-right corner)
      // Pattern matches 7×7 grid: fill all except 3×3 top-right corner (9 dots)
      const blackSquare7x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackSquare7x7Cols = [50, 51, 52, 53, 54, 55, 56];
      
      // 3×3 top-right corner of 7×7: rows 0-2, cols 54-56
      const skyBlue3x3Indices = new Set([
        0 * gridSize57 + 54, // Row 0, col 54
        0 * gridSize57 + 55, // Row 0, col 55
        0 * gridSize57 + 56, // Row 0, col 56
        1 * gridSize57 + 54, // Row 1, col 54
        1 * gridSize57 + 55, // Row 1, col 55
        1 * gridSize57 + 56, // Row 1, col 56
        2 * gridSize57 + 54, // Row 2, col 54
        2 * gridSize57 + 55, // Row 2, col 55
        2 * gridSize57 + 56  // Row 2, col 56
      ]);
      
      const greenIndices = [];
      for (let row of blackSquare7x7Rows) {
        for (let col of blackSquare7x7Cols) {
          const idx = row * gridSize57 + col;
          // Skip the 3×3 top-right corner (9 dots) - that's for the 4th click
          if (!skyBlue3x3Indices.has(idx)) {
            greenIndices.push(idx);
          }
        }
      }
      
      // Fill exactly 40 green dots
      for (let i = 0; i < 40 && i < greenIndices.length; i++) {
        const idx = greenIndices[i];
        grid57Circles[idx].classList.remove(...COLOR_CLASSES);
        grid57Circles[idx].classList.add('green');
      }
      speakNumber(3240); // 3000 yellow + 200 orange + 40 green
      clickCount57 = 3;
    } else if (clickCount57 === 3) {
      // Fourth click: Fill 9 sky blue dots in 3×3 top-right corner of 7×7 square
      const skyBlue3x3Indices = [
        0 * gridSize57 + 54, // Row 0, col 54
        0 * gridSize57 + 55, // Row 0, col 55
        0 * gridSize57 + 56, // Row 0, col 56
        1 * gridSize57 + 54, // Row 1, col 54
        1 * gridSize57 + 55, // Row 1, col 55
        1 * gridSize57 + 56, // Row 1, col 56
        2 * gridSize57 + 54, // Row 2, col 54
        2 * gridSize57 + 55, // Row 2, col 55
        2 * gridSize57 + 56  // Row 2, col 56
      ];
      
      for (let idx of skyBlue3x3Indices) {
        grid57Circles[idx].classList.remove(...COLOR_CLASSES);
        grid57Circles[idx].classList.add('sky');
      }
      speakNumber(3249); // All 3249 dots filled
      clickCount57 = 4;
      
      // Show answer
      if (answerDisplay57) {
        answerDisplay57.textContent = '3249';
        answerDisplay57.classList.add('show');
      }
    } else {
      // Reset on 5th click
      grid57Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'orange', 'green', 'sky');
      });
      speakNumber(0);
      clickCount57 = 0;
      if (answerDisplay57) {
        answerDisplay57.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid57Section);
  
  // Create 58×58 grid (3364 dots) with special click behavior
  const grid58Section = document.createElement('section');
  grid58Section.className = 'set';
  grid58Section.style.marginBottom = '40px';
  
  // Add h2 heading "58²"
  const h2_58 = document.createElement('h2');
  h2_58.textContent = '58²';
  grid58Section.appendChild(h2_58);
  
  const grid58 = document.createElement('div');
  grid58.className = 'grid-dynamic grid-3364';
  grid58.id = 'square-3364';
  grid58.style.gridTemplateColumns = 'repeat(58, var(--circle-total))';
  grid58.style.gridTemplateRows = 'repeat(58, var(--circle-total))';
  grid58.style.width = 'calc(var(--circle-total) * 58)';
  grid58.style.height = 'calc(var(--circle-total) * 58)';
  grid58.style.position = 'relative';
  
  // Track separated circles for movement
  const separatedCircles58 = [];
  
  const gridSize58 = 58;
  const totalDots58 = 3364;
  const grid58Circles = [];
  
  // Create all 3364 circles
  for (let i = 0; i < totalDots58; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3364';
    grid58.appendChild(circle);
    grid58Circles.push(circle);
  }
  
  grid58Section.appendChild(grid58);
  
  // Add answer display
  const answerDisplay58 = document.createElement('div');
  answerDisplay58.className = 'answer-display';
  answerDisplay58.dataset.answer = '3364';
  grid58Section.appendChild(answerDisplay58);
  
  // Click handler for 58×58 grid
  let clickCount58 = 0;
  
  grid58.addEventListener('click', () => {
    if (clickCount58 === 0) {
      // First click: Fill 3000 yellow dots, leaving 364 black dots:
      // - 8×8 square in top right corner: rows 0-7, cols 50-57 (64 dots)
      // - 10×30 rectangle to the left: rows 0-9, cols 28-57 (300 dots, 30 across, 10 deep)
      //   Note: This overlaps with 8×8 in rows 0-7, cols 50-57, but we'll handle that separately
      const blackSquare8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackSquare8x8Cols = [50, 51, 52, 53, 54, 55, 56, 57];
      const blackRectangle10x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      // Rectangle: 30 across (columns), 10 deep (rows), positioned just to the left of 8×8
      // If 8×8 is cols 50-57, rectangle should be cols 20-49 (30 columns, directly to the left)
      const blackRectangle10x30Cols = [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      const blackIndices = new Set();
      
      // Add 8×8 square indices (top right corner)
      for (let row of blackSquare8x8Rows) {
        for (let col of blackSquare8x8Cols) {
          blackIndices.add(row * gridSize58 + col);
        }
      }
      
      // Add 10×30 rectangle indices (30 across, 10 deep, positioned just to the left of 8×8)
      // Rectangle: rows 0-9, cols 28-57 (30 columns), but we only want cols 28-49 to avoid overlap
      // Actually, if 8×8 is cols 50-57, rectangle should be cols 20-49 (30 columns, directly to the left)
      // Wait, let me recalculate: if rectangle is 30 columns and positioned to the left of 8×8 (cols 50-57)
      // Then rectangle should be cols 20-49 (ending just before col 50)
      const blackRectangle10x30ColsCorrected = [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      for (let row of blackRectangle10x30Rows) {
        for (let col of blackRectangle10x30ColsCorrected) {
          blackIndices.add(row * gridSize58 + col);
        }
      }
      
      let yellowCount = 0;
      for (let i = 0; i < totalDots58 && yellowCount < 3000; i++) {
        // Skip the black squares
        if (!blackIndices.has(i)) {
          grid58Circles[i].classList.remove(...COLOR_CLASSES);
          grid58Circles[i].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount58 = 1;
    } else if (clickCount58 === 1) {
      // Second click: Fill 300 yellow dots in 10×30 rectangle and move them up 1/2 dot distance
      // Rectangle: rows 0-9, cols 20-49 (30 across, 10 deep, positioned just to the left of 8×8)
      // Grid always has 58×58 structure, coordinates remain the same
      const blackRectangle10x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle10x30Cols = [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      
      // Fill all 300 dots in rectangle and move them up
      for (let row of blackRectangle10x30Rows) {
        for (let col of blackRectangle10x30Cols) {
          const idx = row * gridSize58 + col;
          const circle = grid58Circles[idx];
          
          // Hide the original circle
          circle.style.visibility = 'hidden';
          
          // Create a separated circle that moves up 1/2 dot distance
          const separatedCircle = document.createElement('div');
          separatedCircle.className = 'circle yellow';
          separatedCircle.style.position = 'absolute';
          separatedCircle.style.zIndex = '5';
          separatedCircle.dataset.originalRow = row;
          separatedCircle.dataset.originalCol = col;
          
          // Copy size classes
          circle.classList.forEach(cls => {
            if (cls.startsWith('circle-')) {
              separatedCircle.classList.add(cls);
            }
          });
          
          // Move up by 0.5 dot distance (straight up)
          // Use scaled circle size to maintain proper movement when grid shrinks
          separatedCircle.style.left = `calc(var(--circle-total-3364) * ${col})`;
          separatedCircle.style.top = `calc(var(--circle-total-3364) * ${row} - 0.5 * var(--circle-total-3364))`;
          separatedCircle.style.transform = 'none';
          
          grid58.appendChild(separatedCircle);
          separatedCircles58.push(separatedCircle);
        }
      }
      speakNumber(3300); // 3000 yellow + 300 yellow
      clickCount58 = 2;
    } else if (clickCount58 === 2) {
      // Third click: Fill 60 purple dots in 8×8 square (all except 2×2 top-right corner)
      // Pattern matches 8×8 grid: fill all except 2×2 top-right corner (4 dots)
      const blackSquare8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackSquare8x8Cols = [50, 51, 52, 53, 54, 55, 56, 57];
      
      // 2×2 top-right corner of 8×8: rows 0-1, cols 56-57
      const green2x2Indices = new Set([
        0 * gridSize58 + 56, // Row 0, col 56
        0 * gridSize58 + 57, // Row 0, col 57
        1 * gridSize58 + 56, // Row 1, col 56
        1 * gridSize58 + 57  // Row 1, col 57
      ]);
      
      const purpleIndices = [];
      for (let row of blackSquare8x8Rows) {
        for (let col of blackSquare8x8Cols) {
          const idx = row * gridSize58 + col;
          // Skip the 2×2 top-right corner (4 dots) - that's for the 4th click
          if (!green2x2Indices.has(idx)) {
            purpleIndices.push(idx);
          }
        }
      }
      
      // Fill exactly 60 purple dots
      for (let i = 0; i < 60 && i < purpleIndices.length; i++) {
        const idx = purpleIndices[i];
        grid58Circles[idx].classList.remove(...COLOR_CLASSES);
        grid58Circles[idx].classList.add('purple');
      }
      speakNumber(3360); // 3000 yellow + 300 yellow + 60 purple
      clickCount58 = 3;
    } else if (clickCount58 === 3) {
      // Fourth click: Fill 4 green dots in 2×2 top-right corner of 8×8 square
      const green2x2Indices = [
        0 * gridSize58 + 56, // Row 0, col 56
        0 * gridSize58 + 57, // Row 0, col 57
        1 * gridSize58 + 56, // Row 1, col 56
        1 * gridSize58 + 57  // Row 1, col 57
      ];
      
      for (let idx of green2x2Indices) {
        grid58Circles[idx].classList.remove(...COLOR_CLASSES);
        grid58Circles[idx].classList.add('green');
      }
      speakNumber(3364); // All 3364 dots filled
      clickCount58 = 4;
      
      // Show answer
      if (answerDisplay58) {
        answerDisplay58.textContent = '3364';
        answerDisplay58.classList.add('show');
      }
    } else {
      // Reset on 5th click
      // Remove separated circles
      separatedCircles58.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      separatedCircles58.length = 0;
      
      // Show all original circles and reset colors
      grid58Circles.forEach(circle => {
        circle.style.visibility = 'visible';
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'purple', 'green');
      });
      speakNumber(0);
      clickCount58 = 0;
      if (answerDisplay58) {
        answerDisplay58.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid58Section);
  
  // Create 59×59 grid (3481 dots) with special click behavior
  const grid59Section = document.createElement('section');
  grid59Section.className = 'set';
  grid59Section.style.marginBottom = '40px';
  grid59Section.id = 'square-3481';
  
  const h2_59 = document.createElement('h2');
  h2_59.textContent = '59²';
  grid59Section.appendChild(h2_59);
  
  const grid59 = document.createElement('div');
  grid59.className = 'grid-dynamic grid-3481';
  grid59.id = 'square-3481';
  grid59.style.gridTemplateColumns = 'repeat(59, var(--circle-total))';
  grid59.style.gridTemplateRows = 'repeat(59, var(--circle-total))';
  grid59.style.width = 'calc(var(--circle-total) * 59)';
  grid59.style.height = 'calc(var(--circle-total) * 59)';
  grid59.style.position = 'relative';
  
  const gridSize59 = 59;
  const totalDots59 = 3481;
  const grid59Circles = [];
  
  // Create all 3481 circles
  for (let i = 0; i < totalDots59; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3481';
    grid59.appendChild(circle);
    grid59Circles.push(circle);
  }
  
  grid59Section.appendChild(grid59);
  
  // Add answer display
  const answerDisplay59 = document.createElement('div');
  answerDisplay59.className = 'answer-display';
  answerDisplay59.dataset.answer = '3481';
  grid59Section.appendChild(answerDisplay59);
  
  // Click handler for 59×59 grid
  let clickCount59 = 0;
  
  grid59.addEventListener('click', () => {
    if (clickCount59 === 0) {
      // First click: Fill 3000 yellow dots, leaving 481 black dots:
      // - 20×20 square: rows 0-19, cols 30-49 (400 dots) - positioned right next to 9×9
      // - 9×9 square: rows 0-8, cols 50-58 (81 dots) - top-right corner
      const blackSquare20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackSquare20x20Cols = [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      const blackSquare9x9Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackSquare9x9Cols = [50, 51, 52, 53, 54, 55, 56, 57, 58];
      const blackIndices = new Set();
      
      // Add 20×20 square indices (positioned right next to 9×9)
      for (let row of blackSquare20x20Rows) {
        for (let col of blackSquare20x20Cols) {
          blackIndices.add(row * gridSize59 + col);
        }
      }
      
      // Add 9×9 square indices (top-right corner)
      for (let row of blackSquare9x9Rows) {
        for (let col of blackSquare9x9Cols) {
          blackIndices.add(row * gridSize59 + col);
        }
      }
      
      let yellowCount = 0;
      for (let i = 0; i < totalDots59 && yellowCount < 3000; i++) {
        // Skip the black squares
        if (!blackIndices.has(i)) {
          grid59Circles[i].classList.remove(...COLOR_CLASSES);
          grid59Circles[i].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount59 = 1;
    } else if (clickCount59 === 1) {
      // Second click: Fill 20×20 square with green (400 dots)
      const blackSquare20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackSquare20x20Cols = [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
      
      for (let row of blackSquare20x20Rows) {
        for (let col of blackSquare20x20Cols) {
          const idx = row * gridSize59 + col;
          grid59Circles[idx].classList.remove(...COLOR_CLASSES);
          grid59Circles[idx].classList.add('green');
        }
      }
      speakNumber(3400); // 3000 yellow + 400 green
      clickCount59 = 2;
    } else if (clickCount59 === 2) {
      // Third click: Fill 80 pink dots in 9×9 square (all except top-right corner)
      const blackSquare9x9Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackSquare9x9Cols = [50, 51, 52, 53, 54, 55, 56, 57, 58];
      
      // Top-right corner dot: row 0, col 58 (this stays black for now)
      const topRightCornerIdx = 0 * gridSize59 + 58;
      
      // Fill all 81 dots except the top-right corner (80 pink dots)
      for (let row of blackSquare9x9Rows) {
        for (let col of blackSquare9x9Cols) {
          const idx = row * gridSize59 + col;
          if (idx !== topRightCornerIdx) {
            grid59Circles[idx].classList.remove(...COLOR_CLASSES);
            grid59Circles[idx].classList.add('pink');
          }
        }
      }
      speakNumber(3480); // 3000 yellow + 400 green + 80 pink
      clickCount59 = 3;
    } else if (clickCount59 === 3) {
      // Fourth click: Fill 1 red dot in top-right corner of 9×9 square
      const topRightCornerIdx = 0 * gridSize59 + 58; // Row 0, col 58
      
      grid59Circles[topRightCornerIdx].classList.remove(...COLOR_CLASSES);
      grid59Circles[topRightCornerIdx].classList.add('red-final');
      speakNumber(3481); // All 3481 dots filled
      clickCount59 = 4;
      
      // Show answer
      if (answerDisplay59) {
        answerDisplay59.textContent = '3481';
        answerDisplay59.classList.add('show');
      }
    } else {
      // Reset
      grid59Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'green', 'pink', 'red-final');
      });
      speakNumber(0);
      clickCount59 = 0;
      if (answerDisplay59) {
        answerDisplay59.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid59Section);
  
  // Create 60×60 grid (3600 dots) with special click behavior
  const grid60Section = document.createElement('section');
  grid60Section.className = 'set';
  grid60Section.style.marginBottom = '40px';
  grid60Section.id = 'square-3600';
  
  const h2_60 = document.createElement('h2');
  h2_60.textContent = '60²';
  grid60Section.appendChild(h2_60);
  
  const grid60 = document.createElement('div');
  grid60.className = 'grid-dynamic grid-3600';
  grid60.id = 'square-3600';
  grid60.style.gridTemplateColumns = 'repeat(60, var(--circle-total))';
  grid60.style.gridTemplateRows = 'repeat(60, var(--circle-total))';
  grid60.style.width = 'calc(var(--circle-total) * 60)';
  grid60.style.height = 'calc(var(--circle-total) * 60)';
  grid60.style.position = 'relative';
  
  const gridSize60 = 60;
  const totalDots60 = 3600;
  const grid60Circles = [];
  
  // Create all 3600 circles
  for (let i = 0; i < totalDots60; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3600';
    grid60.appendChild(circle);
    grid60Circles.push(circle);
  }
  
  grid60Section.appendChild(grid60);
  
  // Add answer display
  const answerDisplay60 = document.createElement('div');
  answerDisplay60.className = 'answer-display';
  answerDisplay60.dataset.answer = '3600';
  grid60Section.appendChild(answerDisplay60);
  
  // Click handler for 60×60 grid
  let clickCount60 = 0;
  
  grid60.addEventListener('click', () => {
    if (clickCount60 === 0) {
      // First click: Fill 3000 yellow dots from the bottom row upward
      let yellowCount = 0;
      // Fill from bottom row (row 59) upward
      for (let row = gridSize60 - 1; row >= 0 && yellowCount < 3000; row--) {
        for (let col = 0; col < gridSize60 && yellowCount < 3000; col++) {
          const idx = row * gridSize60 + col;
          grid60Circles[idx].classList.remove(...COLOR_CLASSES);
          grid60Circles[idx].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount60 = 1;
    } else if (clickCount60 === 1) {
      // Second click: Fill 600 purple dots from the bottom row upward (remaining dots)
      let purpleCount = 0;
      // Fill from bottom row (row 59) upward
      for (let row = gridSize60 - 1; row >= 0 && purpleCount < 600; row--) {
        for (let col = 0; col < gridSize60 && purpleCount < 600; col++) {
          const idx = row * gridSize60 + col;
          // Skip dots that are already yellow
          if (!grid60Circles[idx].classList.contains('yellow')) {
            grid60Circles[idx].classList.remove(...COLOR_CLASSES);
            grid60Circles[idx].classList.add('purple');
            purpleCount++;
          }
        }
      }
      speakNumber(3600); // All 3600 dots filled
      clickCount60 = 2;
      
      // Show answer
      if (answerDisplay60) {
        answerDisplay60.textContent = '3600';
        answerDisplay60.classList.add('show');
      }
    } else {
      // Reset
      grid60Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'purple');
      });
      speakNumber(0);
      clickCount60 = 0;
      if (answerDisplay60) {
        answerDisplay60.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid60Section);
  
  // Create 61×61 grid (3721 dots) with special click behavior
  const grid61Section = document.createElement('section');
  grid61Section.className = 'set';
  grid61Section.style.marginBottom = '40px';
  grid61Section.id = 'square-3721';
  
  const h2_61 = document.createElement('h2');
  h2_61.textContent = '61²';
  grid61Section.appendChild(h2_61);
  
  const grid61 = document.createElement('div');
  grid61.className = 'grid-dynamic grid-3721';
  grid61.id = 'square-3721';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid61.style.gridTemplateColumns = 'repeat(61, calc(var(--circle-total) * 13 / 61))';
  grid61.style.gridTemplateRows = 'repeat(61, calc(var(--circle-total) * 13 / 61))';
  grid61.style.width = 'calc(var(--circle-total) * 13)';
  grid61.style.height = 'calc(var(--circle-total) * 13)';
  grid61.style.position = 'relative';
  
  const gridSize61 = 61;
  const totalDots61 = 3721;
  const grid61Circles = [];
  
  // Create all 3721 circles
  for (let i = 0; i < totalDots61; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3721';
    grid61.appendChild(circle);
    grid61Circles.push(circle);
  }
  
  grid61Section.appendChild(grid61);
  
  // Add answer display
  const answerDisplay61 = document.createElement('div');
  answerDisplay61.className = 'answer-display';
  answerDisplay61.dataset.answer = '3721';
  grid61Section.appendChild(answerDisplay61);
  
  // Click handler for 61×61 grid
  let clickCount61 = 0;
  
  grid61.addEventListener('click', () => {
    if (clickCount61 === 0) {
      // First click: Fill 3000 yellow dots from the bottom row upward
      let yellowCount = 0;
      // Fill from bottom row (row 60) upward
      for (let row = gridSize61 - 1; row >= 0 && yellowCount < 3000; row--) {
        for (let col = 0; col < gridSize61 && yellowCount < 3000; col++) {
          const idx = row * gridSize61 + col;
          grid61Circles[idx].classList.remove(...COLOR_CLASSES);
          grid61Circles[idx].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount61 = 1;
    } else if (clickCount61 === 1) {
      // Second click: Fill 700 brown dots from the bottom row upward, leaving 21 black dots in 7×3 rectangle
      // 7×3 rectangle in top-right corner: rows 0-6, cols 58-60
      const blackRectangle7x3Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle7x3Cols = [58, 59, 60];
      const blackIndices = new Set();
      
      // Add 7×3 rectangle indices (top-right corner)
      for (let row of blackRectangle7x3Rows) {
        for (let col of blackRectangle7x3Cols) {
          blackIndices.add(row * gridSize61 + col);
        }
      }
      
      let brownCount = 0;
      // Fill from bottom row (row 60) upward
      for (let row = gridSize61 - 1; row >= 0 && brownCount < 700; row--) {
        for (let col = 0; col < gridSize61 && brownCount < 700; col++) {
          const idx = row * gridSize61 + col;
          // Skip dots that are already yellow or in the 7×3 rectangle
          if (!grid61Circles[idx].classList.contains('yellow') && !blackIndices.has(idx)) {
            grid61Circles[idx].classList.remove(...COLOR_CLASSES);
            grid61Circles[idx].classList.add('brown');
            brownCount++;
          }
        }
      }
      speakNumber(3700); // 3000 yellow + 700 brown
      clickCount61 = 2;
    } else if (clickCount61 === 2) {
      // Third click: Fill 20 orange dots in the 7×3 rectangle (leaving 1 black dot in top-right corner)
      const blackRectangle7x3Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle7x3Cols = [58, 59, 60];
      
      // Top-right corner dot: row 0, col 60 (this stays black for now)
      const topRightCornerIdx = 0 * gridSize61 + 60;
      
      // Fill all 21 dots except the top-right corner (20 orange dots)
      for (let row of blackRectangle7x3Rows) {
        for (let col of blackRectangle7x3Cols) {
          const idx = row * gridSize61 + col;
          if (idx !== topRightCornerIdx) {
            grid61Circles[idx].classList.remove(...COLOR_CLASSES);
            grid61Circles[idx].classList.add('orange');
          }
        }
      }
      speakNumber(3720); // 3000 yellow + 700 brown + 20 orange
      clickCount61 = 3;
    } else if (clickCount61 === 3) {
      // Fourth click: Fill 1 red dot in top-right corner of 7×3 rectangle
      const topRightCornerIdx = 0 * gridSize61 + 60; // Row 0, col 60
      
      grid61Circles[topRightCornerIdx].classList.remove(...COLOR_CLASSES);
      grid61Circles[topRightCornerIdx].classList.add('red-final');
      speakNumber(3721); // All 3721 dots filled
      clickCount61 = 4;
      
      // Show answer
      if (answerDisplay61) {
        answerDisplay61.textContent = '3721';
        answerDisplay61.classList.add('show');
      }
    } else {
      // Reset
      grid61Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'brown', 'orange', 'red-final');
      });
      speakNumber(0);
      clickCount61 = 0;
      if (answerDisplay61) {
        answerDisplay61.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid61Section);
  
  // Create 62×62 grid (3844 dots)
  const grid62Section = document.createElement('section');
  grid62Section.className = 'set';
  grid62Section.style.marginBottom = '40px';
  grid62Section.id = 'square-3844';
  
  const h2_62 = document.createElement('h2');
  h2_62.textContent = '62²';
  grid62Section.appendChild(h2_62);
  
  const grid62 = document.createElement('div');
  grid62.className = 'grid-dynamic grid-3844';
  grid62.id = 'square-3844';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid62.style.gridTemplateColumns = 'repeat(62, calc(var(--circle-total) * 13 / 62))';
  grid62.style.gridTemplateRows = 'repeat(62, calc(var(--circle-total) * 13 / 62))';
  grid62.style.width = 'calc(var(--circle-total) * 13)';
  grid62.style.height = 'calc(var(--circle-total) * 13)';
  grid62.style.position = 'relative';
  
  const gridSize62 = 62;
  const totalDots62 = 3844;
  const grid62Circles = [];
  
  // Create all 3844 circles
  for (let i = 0; i < totalDots62; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3844';
    grid62.appendChild(circle);
    grid62Circles.push(circle);
  }
  
  grid62Section.appendChild(grid62);
  
  // Add answer display
  const answerDisplay62 = document.createElement('div');
  answerDisplay62.className = 'answer-display';
  answerDisplay62.dataset.answer = '3844';
  grid62Section.appendChild(answerDisplay62);
  
  // Click handler for 62×62 grid
  let clickCount62 = 0;
  const separatedCircles62 = []; // Track separated circles for movement
  
  grid62.addEventListener('click', () => {
    if (clickCount62 === 0) {
      // First click: Fill 3000 yellow dots from the bottom row upward
      let yellowCount = 0;
      // Fill from bottom row (row 61) upward
      for (let row = gridSize62 - 1; row >= 0 && yellowCount < 3000; row--) {
        for (let col = 0; col < gridSize62 && yellowCount < 3000; col++) {
          const idx = row * gridSize62 + col;
          grid62Circles[idx].classList.remove(...COLOR_CLASSES);
          grid62Circles[idx].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount62 = 1;
    } else if (clickCount62 === 1) {
      // Second click: Fill 800 pink dots from the bottom row upward, leaving 44 black dots in 4×11 rectangle
      // 4×11 rectangle in top-right corner: rows 0-3, cols 51-61
      const blackRectangle4x11Rows = [0, 1, 2, 3];
      const blackRectangle4x11Cols = [51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61];
      const blackIndices = new Set();
      
      // Add 4×11 rectangle indices (top-right corner)
      for (let row of blackRectangle4x11Rows) {
        for (let col of blackRectangle4x11Cols) {
          blackIndices.add(row * gridSize62 + col);
        }
      }
      
      let pinkCount = 0;
      // Fill from bottom row (row 61) upward
      for (let row = gridSize62 - 1; row >= 0 && pinkCount < 800; row--) {
        for (let col = 0; col < gridSize62 && pinkCount < 800; col++) {
          const idx = row * gridSize62 + col;
          // Skip dots that are already yellow or in the 4×11 rectangle
          if (!grid62Circles[idx].classList.contains('yellow') && !blackIndices.has(idx)) {
            grid62Circles[idx].classList.remove(...COLOR_CLASSES);
            grid62Circles[idx].classList.add('pink');
            pinkCount++;
          }
        }
      }
      speakNumber(3800); // 3000 yellow + 800 pink
      clickCount62 = 2;
    } else if (clickCount62 === 2) {
      // Third click: Color 40 dots in 4×11 rectangle, keep 4 black in top-right corner (2×2)
      // Nothing moves on this click - just color the dots
      // Top-right corner 2×2 square: rows 0-1, cols 60-61
      const topRightCornerIndices = [
        0 * gridSize62 + 60, // Row 0, Col 60
        0 * gridSize62 + 61, // Row 0, Col 61
        1 * gridSize62 + 60, // Row 1, Col 60
        1 * gridSize62 + 61  // Row 1, Col 61
      ];
      
      // Find all black dots in the 4×11 rectangle
      const blackRectangle4x11Rows = [0, 1, 2, 3];
      const blackRectangle4x11Cols = [51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61];
      
      // Color 40 of the black dots (excluding the 4 in top-right corner) - no movement
      let coloredCount = 0;
      for (let row of blackRectangle4x11Rows) {
        for (let col of blackRectangle4x11Cols) {
          const idx = row * gridSize62 + col;
          const circle = grid62Circles[idx];
          
          // Check if this dot is black (not yellow, not pink)
          if (!circle.classList.contains('yellow') && !circle.classList.contains('pink')) {
            // Skip the 4 dots in top-right corner - keep them black
            if (topRightCornerIndices.includes(idx)) {
              continue;
            }
            
            // Color this dot green
            if (coloredCount < 40) {
              circle.classList.remove(...COLOR_CLASSES);
              circle.classList.add('green');
              coloredCount++;
            }
          }
        }
      }
      
      speakNumber(3840); // 3000 yellow + 800 pink + 40 green
      clickCount62 = 3;
    } else if (clickCount62 === 3) {
      // Fourth click: Move the 2×2 square (top-right corner) 1/2 dot right and 1/2 dot up, and turn it green
      // Top-right corner 2×2 square: rows 0-1, cols 60-61
      const topRightCornerRows = [0, 1];
      const topRightCornerCols = [60, 61];
      
      // Move all 4 dots of the 2×2 square
      for (let row of topRightCornerRows) {
        for (let col of topRightCornerCols) {
          const idx = row * gridSize62 + col;
          const circle = grid62Circles[idx];
          
          // Hide the original circle
          circle.style.visibility = 'hidden';
          
          // Create a separated circle that moves 1/2 dot right and 1/2 dot up
          const separatedCircle = document.createElement('div');
          separatedCircle.className = 'circle green';
          separatedCircle.style.position = 'absolute';
          separatedCircle.style.zIndex = '5';
          separatedCircle.dataset.originalRow = row;
          separatedCircle.dataset.originalCol = col;
          
          // Copy size classes
          circle.classList.forEach(cls => {
            if (cls.startsWith('circle-')) {
              separatedCircle.classList.add(cls);
            }
          });
          
          // Move 1/2 dot right and 1/2 dot up
          // Use scaled circle size variable for 62×62 grid
          separatedCircle.style.left = `calc(var(--circle-total-3844) * ${col} + 0.5 * var(--circle-total-3844))`;
          separatedCircle.style.top = `calc(var(--circle-total-3844) * ${row} - 0.5 * var(--circle-total-3844))`;
          separatedCircle.style.transform = 'none';
          
          grid62.appendChild(separatedCircle);
          separatedCircles62.push(separatedCircle);
        }
      }
      
      speakNumber(3844); // All 3844 dots filled
      clickCount62 = 4;
      
      // Show answer
      if (answerDisplay62) {
        answerDisplay62.textContent = '3844';
        answerDisplay62.classList.add('show');
      }
    } else {
      // Reset
      // Remove separated circles
      separatedCircles62.forEach(sc => sc.remove());
      separatedCircles62.length = 0;
      
      // Reset all circles
      grid62Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'pink', 'green');
        circle.style.visibility = 'visible'; // Make sure visibility is reset
      });
      speakNumber(0);
      clickCount62 = 0;
      if (answerDisplay62) {
        answerDisplay62.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid62Section);
  
  // Create 63×63 grid (3969 dots) with special click behavior
  const grid63Section = document.createElement('section');
  grid63Section.className = 'set';
  grid63Section.style.marginBottom = '40px';
  grid63Section.id = 'square-3969';
  
  const h2_63 = document.createElement('h2');
  h2_63.textContent = '63²';
  grid63Section.appendChild(h2_63);
  
  const grid63 = document.createElement('div');
  grid63.className = 'grid-dynamic grid-3969';
  grid63.id = 'square-3969';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid63.style.gridTemplateColumns = 'repeat(63, calc(var(--circle-total) * 13 / 63))';
  grid63.style.gridTemplateRows = 'repeat(63, calc(var(--circle-total) * 13 / 63))';
  grid63.style.width = 'calc(var(--circle-total) * 13)';
  grid63.style.height = 'calc(var(--circle-total) * 13)';
  grid63.style.position = 'relative';
  
  const gridSize63 = 63;
  const totalDots63 = 3969;
  const grid63Circles = [];
  
  // Create all 3969 circles
  for (let i = 0; i < totalDots63; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-3969';
    grid63.appendChild(circle);
    grid63Circles.push(circle);
  }
  
  grid63Section.appendChild(grid63);
  
  // Add answer display
  const answerDisplay63 = document.createElement('div');
  answerDisplay63.className = 'answer-display';
  answerDisplay63.dataset.answer = '3969';
  grid63Section.appendChild(answerDisplay63);
  
  // Click handler for 63×63 grid
  let clickCount63 = 0;
  
  grid63.addEventListener('click', () => {
    if (clickCount63 === 0) {
      // First click: Fill 3000 yellow dots from the bottom row upward
      let yellowCount = 0;
      // Fill from bottom row (row 62) upward
      for (let row = gridSize63 - 1; row >= 0 && yellowCount < 3000; row--) {
        for (let col = 0; col < gridSize63 && yellowCount < 3000; col++) {
          const idx = row * gridSize63 + col;
          grid63Circles[idx].classList.remove(...COLOR_CLASSES);
          grid63Circles[idx].classList.add('yellow');
          yellowCount++;
        }
      }
      speakNumber(3000);
      clickCount63 = 1;
    } else if (clickCount63 === 1) {
      // Second click: Fill 900 sky blue dots from the bottom row upward
      // Leave a 7×10 rectangle (70 dots) black, except the bottom-left corner of that rectangle should be sky blue
      // 7×10 rectangle in top-right corner: rows 0-6, cols 53-62
      const blackRectangle7x10Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle7x10Cols = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62];
      const blackIndices = new Set();
      
      // Add all 7×10 rectangle indices (70 dots)
      for (let row of blackRectangle7x10Rows) {
        for (let col of blackRectangle7x10Cols) {
          blackIndices.add(row * gridSize63 + col);
        }
      }
      
      // Bottom-left corner of rectangle: row 6, col 53 - this should be sky blue, not black
      const bottomLeftCornerIdx = 6 * gridSize63 + 53;
      blackIndices.delete(bottomLeftCornerIdx); // Remove it from black indices so it gets filled with sky blue
      
      let skyBlueCount = 0;
      // Fill from bottom row (row 62) upward
      for (let row = gridSize63 - 1; row >= 0 && skyBlueCount < 900; row--) {
        for (let col = 0; col < gridSize63 && skyBlueCount < 900; col++) {
          const idx = row * gridSize63 + col;
          // Skip dots that are already yellow or in the black rectangle (except bottom-left corner)
          if (!grid63Circles[idx].classList.contains('yellow') && !blackIndices.has(idx)) {
            grid63Circles[idx].classList.remove(...COLOR_CLASSES);
            grid63Circles[idx].classList.add('sky');
            skyBlueCount++;
          }
        }
      }
      speakNumber(3900); // 3000 yellow + 900 sky blue
      clickCount63 = 2;
    } else if (clickCount63 === 2) {
      // Third click: Fill 60 of the black dots, leaving a 3×3 square in the top-right corner remaining black
      // 7×10 rectangle: rows 0-6, cols 53-62
      // 3×3 square in top-right corner of rectangle: rows 0-2, cols 60-62
      const blackRectangle7x10Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle7x10Cols = [53, 54, 55, 56, 57, 58, 59, 60, 61, 62];
      const topRight3x3Rows = [0, 1, 2];
      const topRight3x3Cols = [60, 61, 62];
      const topRight3x3Indices = new Set();
      
      // Add 3×3 square indices (top-right corner of 7×10 rectangle)
      for (let row of topRight3x3Rows) {
        for (let col of topRight3x3Cols) {
          topRight3x3Indices.add(row * gridSize63 + col);
        }
      }
      
      // Find all black dots in the 7×10 rectangle (excluding the 3×3 square)
      const blackDotIndices = [];
      for (let row of blackRectangle7x10Rows) {
        for (let col of blackRectangle7x10Cols) {
          const idx = row * gridSize63 + col;
          const circle = grid63Circles[idx];
          
          // Check if this dot is black (not yellow, not sky blue, not purple) and not in the 3×3 square
          if (!circle.classList.contains('yellow') && !circle.classList.contains('sky') && !circle.classList.contains('purple') && !topRight3x3Indices.has(idx)) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 60 of the black dots with purple
      for (let i = 0; i < 60 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid63Circles[idx].classList.remove(...COLOR_CLASSES);
        grid63Circles[idx].classList.add('purple');
      }
      speakNumber(3960); // 3000 yellow + 900 sky blue + 60 purple
      clickCount63 = 3;
    } else if (clickCount63 === 3) {
      // Fourth click: Fill the 3×3 square in the top-right corner with sky blue (9 dots)
      const topRight3x3Rows = [0, 1, 2];
      const topRight3x3Cols = [60, 61, 62];
      
      for (let row of topRight3x3Rows) {
        for (let col of topRight3x3Cols) {
          const idx = row * gridSize63 + col;
          grid63Circles[idx].classList.remove(...COLOR_CLASSES);
          grid63Circles[idx].classList.add('sky');
        }
      }
      speakNumber(3969); // All 3969 dots filled
      clickCount63 = 4;
      
      // Show answer
      if (answerDisplay63) {
        answerDisplay63.textContent = '3969';
        answerDisplay63.classList.add('show');
      }
    } else {
      // Reset
      grid63Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'sky', 'purple');
      });
      speakNumber(0);
      clickCount63 = 0;
      if (answerDisplay63) {
        answerDisplay63.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid63Section);
  
  // Create 64×64 grid (4096 dots) with special click behavior
  const grid64Section = document.createElement('section');
  grid64Section.className = 'set';
  grid64Section.style.marginBottom = '40px';
  grid64Section.id = 'square-4096';
  
  const h2_64 = document.createElement('h2');
  h2_64.textContent = '64²';
  grid64Section.appendChild(h2_64);
  
  const grid64 = document.createElement('div');
  grid64.className = 'grid-dynamic grid-4096';
  grid64.id = 'square-4096';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid64.style.gridTemplateColumns = 'repeat(64, calc(var(--circle-total) * 13 / 64))';
  grid64.style.gridTemplateRows = 'repeat(64, calc(var(--circle-total) * 13 / 64))';
  grid64.style.width = 'calc(var(--circle-total) * 13)';
  grid64.style.height = 'calc(var(--circle-total) * 13)';
  grid64.style.position = 'relative';
  
  const gridSize64 = 64;
  const totalDots64 = 4096;
  const grid64Circles = [];
  
  // Create all 4096 circles
  for (let i = 0; i < totalDots64; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-4096';
    grid64.appendChild(circle);
    grid64Circles.push(circle);
  }
  
  grid64Section.appendChild(grid64);
  
  // Add answer display
  const answerDisplay64 = document.createElement('div');
  answerDisplay64.className = 'answer-display';
  answerDisplay64.dataset.answer = '4096';
  grid64Section.appendChild(answerDisplay64);
  
  // Click handler for 64×64 grid
  let clickCount64 = 0;
  
  grid64.addEventListener('click', () => {
    if (clickCount64 === 0) {
      // First click: Fill 4000 green dots from the bottom row upward
      // Leave a 10×10 grid in upper right corner all black EXCEPT the bottom-left corner of that 10×10
      // Bottom-left corner of 10×10 is a 2×2 square (4 dots) that should be part of the 4000 green dots
      // 10×10 grid in upper right: rows 0-9, cols 54-63
      const blackSquare10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackSquare10x10Cols = [54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
      const blackIndices = new Set();
      
      // Add all 10×10 rectangle indices (100 dots)
      for (let row of blackSquare10x10Rows) {
        for (let col of blackSquare10x10Cols) {
          blackIndices.add(row * gridSize64 + col);
        }
      }
      
      // Bottom-left corner of 10×10: rows 8-9, cols 54-55 (2×2 = 4 dots) - these should be green
      const bottomLeft2x2Indices = [
        8 * gridSize64 + 54, // Row 8, Col 54
        8 * gridSize64 + 55, // Row 8, Col 55
        9 * gridSize64 + 54, // Row 9, Col 54
        9 * gridSize64 + 55  // Row 9, Col 55
      ];
      
      // Remove the 2×2 bottom-left corner from black indices so it gets filled with green
      bottomLeft2x2Indices.forEach(idx => blackIndices.delete(idx));
      
      let greenCount = 0;
      // Fill from bottom row (row 63) upward
      for (let row = gridSize64 - 1; row >= 0 && greenCount < 4000; row--) {
        for (let col = 0; col < gridSize64 && greenCount < 4000; col++) {
          const idx = row * gridSize64 + col;
          // Skip dots in the black square (except the 2×2 bottom-left corner)
          if (!blackIndices.has(idx)) {
            grid64Circles[idx].classList.remove(...COLOR_CLASSES);
            grid64Circles[idx].classList.add('green');
            greenCount++;
          }
        }
      }
      speakNumber(4000);
      clickCount64 = 1;
    } else if (clickCount64 === 1) {
      // Second click: Fill 90 sky blue dots in the 10×10 grid, leaving:
      // - 3 dots in row 0 (zero row) black
      // - 2 dots in row 1 (first row) black
      // - 1 dot in row 2 (second row) all the way to the right black
      const blackSquare10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackSquare10x10Cols = [54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
      
      // Dots that should remain black after second click:
      // Row 0: 3 dots (cols 61, 62, 63 - the rightmost 3)
      // Row 1: 2 dots (cols 62, 63 - the rightmost 2)
      // Row 2: 1 dot (col 63 - all the way to the right)
      const remainingBlackIndices = new Set([
        0 * gridSize64 + 61, // Row 0, Col 61
        0 * gridSize64 + 62, // Row 0, Col 62
        0 * gridSize64 + 63, // Row 0, Col 63
        1 * gridSize64 + 62, // Row 1, Col 62
        1 * gridSize64 + 63, // Row 1, Col 63
        2 * gridSize64 + 63  // Row 2, Col 63
      ]);
      
      // Find all black dots in the 10×10 grid (excluding the ones that should remain black)
      const blackDotIndices = [];
      for (let row of blackSquare10x10Rows) {
        for (let col of blackSquare10x10Cols) {
          const idx = row * gridSize64 + col;
          const circle = grid64Circles[idx];
          
          // Check if this dot is black (not green) and not in the remaining black set
          if (!circle.classList.contains('green') && !remainingBlackIndices.has(idx)) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 90 sky blue dots
      for (let i = 0; i < 90 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid64Circles[idx].classList.remove(...COLOR_CLASSES);
        grid64Circles[idx].classList.add('sky');
      }
      speakNumber(4090); // 4000 green + 90 sky blue
      clickCount64 = 2;
    } else if (clickCount64 === 2) {
      // Third click: Fill the remaining 6 black dots with purple
      // Row 0: 3 dots (cols 61, 62, 63)
      // Row 1: 2 dots (cols 62, 63)
      // Row 2: 1 dot (col 63)
      const purpleIndices = [
        0 * gridSize64 + 61, // Row 0, Col 61
        0 * gridSize64 + 62, // Row 0, Col 62
        0 * gridSize64 + 63, // Row 0, Col 63
        1 * gridSize64 + 62, // Row 1, Col 62
        1 * gridSize64 + 63, // Row 1, Col 63
        2 * gridSize64 + 63  // Row 2, Col 63
      ];
      
      for (let idx of purpleIndices) {
        grid64Circles[idx].classList.remove(...COLOR_CLASSES);
        grid64Circles[idx].classList.add('purple');
      }
      speakNumber(4096); // All 4096 dots filled
      clickCount64 = 3;
      
      // Show answer
      if (answerDisplay64) {
        answerDisplay64.textContent = '4096';
        answerDisplay64.classList.add('show');
      }
    } else {
      // Reset
      grid64Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'green', 'sky', 'purple');
      });
      speakNumber(0);
      clickCount64 = 0;
      if (answerDisplay64) {
        answerDisplay64.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid64Section);
  
  // Create 65×65 grid (4225 dots) with special click behavior
  const grid65Section = document.createElement('section');
  grid65Section.className = 'set';
  grid65Section.style.marginBottom = '40px';
  grid65Section.id = 'square-4225';
  
  const h2_65 = document.createElement('h2');
  h2_65.textContent = '65²';
  grid65Section.appendChild(h2_65);
  
  const grid65 = document.createElement('div');
  grid65.className = 'grid-dynamic grid-4225';
  grid65.id = 'square-4225';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid65.style.gridTemplateColumns = 'repeat(65, calc(var(--circle-total) * 13 / 65))';
  grid65.style.gridTemplateRows = 'repeat(65, calc(var(--circle-total) * 13 / 65))';
  grid65.style.width = 'calc(var(--circle-total) * 13)';
  grid65.style.height = 'calc(var(--circle-total) * 13)';
  grid65.style.position = 'relative';
  
  const gridSize65 = 65;
  const totalDots65 = 4225;
  const grid65Circles = [];
  
  // Create all 4225 circles
  for (let i = 0; i < totalDots65; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-4225';
    grid65.appendChild(circle);
    grid65Circles.push(circle);
  }
  
  grid65Section.appendChild(grid65);
  
  // Add answer display
  const answerDisplay65 = document.createElement('div');
  answerDisplay65.className = 'answer-display';
  answerDisplay65.dataset.answer = '4225';
  grid65Section.appendChild(answerDisplay65);
  
  // Click handler for 65×65 grid
  let clickCount65 = 0;
  const separatedCircles65 = []; // Track separated circles for movement
  
  grid65.addEventListener('click', () => {
    if (clickCount65 === 0) {
      // First click: Fill 4000 dots from the bottom row upward, leaving:
      // - 20×10 rectangle: rows 0-19, cols 50-59 (200 dots)
      // - 5×5 square: rows 0-4, cols 60-64 (25 dots)
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x10Cols = [50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      const blackSquare5x5Cols = [60, 61, 62, 63, 64];
      const blackIndices = new Set();
      
      // Add 20×10 rectangle indices
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          blackIndices.add(row * gridSize65 + col);
        }
      }
      
      // Add 5×5 square indices
      for (let row of blackSquare5x5Rows) {
        for (let col of blackSquare5x5Cols) {
          blackIndices.add(row * gridSize65 + col);
        }
      }
      
      let fillCount = 0;
      // Fill from bottom row (row 64) upward
      for (let row = gridSize65 - 1; row >= 0 && fillCount < 4000; row--) {
        for (let col = 0; col < gridSize65 && fillCount < 4000; col++) {
          const idx = row * gridSize65 + col;
          // Skip dots in the black areas
          if (!blackIndices.has(idx)) {
            grid65Circles[idx].classList.remove(...COLOR_CLASSES);
            grid65Circles[idx].classList.add('yellow');
            fillCount++;
          }
        }
      }
      speakNumber(4000);
      clickCount65 = 1;
    } else if (clickCount65 === 1) {
      // Second click: Fill 200 orange dots in the 20×10 rectangle
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x10Cols = [50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
      
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          const idx = row * gridSize65 + col;
          grid65Circles[idx].classList.remove(...COLOR_CLASSES);
          grid65Circles[idx].classList.add('orange');
        }
      }
      speakNumber(4200); // 4000 yellow + 200 orange
      clickCount65 = 2;
    } else if (clickCount65 === 2) {
      // Third click: The 5×5 grid moves right and up, and the first 4 columns turn orange
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      const blackSquare5x5Cols = [60, 61, 62, 63, 64];
      
      // First 4 columns: cols 60-63 (20 dots)
      const orangeCols = [60, 61, 62, 63];
      
      // Find all dots in the 5×5 square
      const square5x5Indices = [];
      for (let row of blackSquare5x5Rows) {
        for (let col of blackSquare5x5Cols) {
          const idx = row * gridSize65 + col;
          square5x5Indices.push({ index: idx, row, col });
        }
      }
      
      // Color the first 4 columns orange and move all 25 dots
      for (const { index, row, col } of square5x5Indices) {
        const circle = grid65Circles[index];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Determine color: first 4 columns are orange, last column stays black
        const isOrange = orangeCols.includes(col);
        
        // Create a separated circle
        const separatedCircle = document.createElement('div');
        separatedCircle.className = isOrange ? 'circle orange' : 'circle';
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = row;
        separatedCircle.dataset.originalCol = col;
        
        // Copy size classes
        circle.classList.forEach(cls => {
          if (cls.startsWith('circle-')) {
            separatedCircle.classList.add(cls);
          }
        });
        
        // Move right and up a little bit (similar to other grids)
        // Use scaled circle size variable for 65×65 grid
        separatedCircle.style.left = `calc(var(--circle-total-4225) * ${col} + 0.6 * var(--circle-total-4225))`;
        separatedCircle.style.top = `calc(var(--circle-total-4225) * ${row} - 0.6 * var(--circle-total-4225))`;
        
        separatedCircle.style.display = 'block';
        separatedCircle.style.visibility = 'visible';
        separatedCircle.style.opacity = '1';
        grid65.appendChild(separatedCircle);
        separatedCircles65.push(separatedCircle);
      }
      
      speakNumber(4220); // 4000 yellow + 200 orange + 20 orange
      clickCount65 = 3;
    } else if (clickCount65 === 3) {
      // Fourth click: Fill 5 blue dots (the remaining column of the 5×5)
      // The last column (col 64) should turn blue
      const lastColumn = 64;
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      
      // Find the separated circles for the last column
      separatedCircles65.forEach(sc => {
        const scRow = parseInt(sc.dataset.originalRow);
        const scCol = parseInt(sc.dataset.originalCol);
        
        // Check if this is in the last column (col 64)
        if (blackSquare5x5Rows.includes(scRow) && scCol === lastColumn) {
          sc.classList.remove(...COLOR_CLASSES);
          sc.classList.add('blue');
        }
      });
      
      speakNumber(4225); // All 4225 dots filled
      clickCount65 = 4;
      
      // Show answer
      if (answerDisplay65) {
        answerDisplay65.textContent = '4225';
        answerDisplay65.classList.add('show');
      }
    } else {
      // Reset
      // Remove separated circles
      separatedCircles65.forEach(sc => sc.remove());
      separatedCircles65.length = 0;
      
      // Reset all circles
      grid65Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'yellow', 'orange', 'blue');
        circle.style.visibility = 'visible'; // Make sure visibility is reset
      });
      speakNumber(0);
      clickCount65 = 0;
      if (answerDisplay65) {
        answerDisplay65.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid65Section);
  
  // Create 66×66 grid (4356 dots) with special click behavior
  const grid66Section = document.createElement('section');
  grid66Section.className = 'set';
  grid66Section.style.marginBottom = '40px';
  grid66Section.id = 'square-4356';
  
  const h2_66 = document.createElement('h2');
  h2_66.textContent = '66²';
  grid66Section.appendChild(h2_66);
  
  const grid66 = document.createElement('div');
  grid66.className = 'grid-dynamic grid-4356';
  grid66.id = 'square-4356';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid66.style.gridTemplateColumns = 'repeat(66, calc(var(--circle-total) * 13 / 66))';
  grid66.style.gridTemplateRows = 'repeat(66, calc(var(--circle-total) * 13 / 66))';
  grid66.style.width = 'calc(var(--circle-total) * 13)';
  grid66.style.height = 'calc(var(--circle-total) * 13)';
  grid66.style.position = 'relative';
  
  const gridSize66 = 66;
  const totalDots66 = 4356;
  const grid66Circles = [];
  
  // Create all 4356 circles
  for (let i = 0; i < totalDots66; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-4356';
    grid66.appendChild(circle);
    grid66Circles.push(circle);
  }
  
  grid66Section.appendChild(grid66);
  
  // Add answer display
  const answerDisplay66 = document.createElement('div');
  answerDisplay66.className = 'answer-display';
  answerDisplay66.dataset.answer = '4356';
  grid66Section.appendChild(answerDisplay66);
  
  // Click handler for 66×66 grid
  let clickCount66 = 0;
  
  grid66.addEventListener('click', () => {
    if (clickCount66 === 0) {
      // First click: Fill 4000 green dots from the bottom row upward, leaving:
      // - 30×10 rectangle: rows 0-9, cols 26-55 (300 dots)
      // - 6×10 rectangle: rows 0-5, cols 56-65 (60 dots) in top right corner
      // The 6×10 rectangle is black EXCEPT the bottom-left corner (2×2 square, 4 dots) which is green
      const blackRectangle30x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle30x10Cols = [26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55];
      const blackRectangle6x10Rows = [0, 1, 2, 3, 4, 5];
      const blackRectangle6x10Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65];
      const blackIndices = new Set();
      
      // Add 30×10 rectangle indices
      for (let row of blackRectangle30x10Rows) {
        for (let col of blackRectangle30x10Cols) {
          blackIndices.add(row * gridSize66 + col);
        }
      }
      
      // Add 6×10 rectangle indices
      for (let row of blackRectangle6x10Rows) {
        for (let col of blackRectangle6x10Cols) {
          blackIndices.add(row * gridSize66 + col);
        }
      }
      
      // Bottom-left corner of 6×10: rows 4-5, cols 56-57 (2×2 = 4 dots) - these should be green
      const bottomLeft2x2Indices = [
        4 * gridSize66 + 56, // Row 4, Col 56
        4 * gridSize66 + 57, // Row 4, Col 57
        5 * gridSize66 + 56, // Row 5, Col 56
        5 * gridSize66 + 57  // Row 5, Col 57
      ];
      
      // Remove the 2×2 bottom-left corner from black indices so it gets filled with green
      bottomLeft2x2Indices.forEach(idx => blackIndices.delete(idx));
      
      let greenCount = 0;
      // Fill from bottom row (row 65) upward
      for (let row = gridSize66 - 1; row >= 0 && greenCount < 4000; row--) {
        for (let col = 0; col < gridSize66 && greenCount < 4000; col++) {
          const idx = row * gridSize66 + col;
          // Skip dots in the black areas (except the 2×2 bottom-left corner)
          if (!blackIndices.has(idx)) {
            grid66Circles[idx].classList.remove(...COLOR_CLASSES);
            grid66Circles[idx].classList.add('green');
            greenCount++;
          }
        }
      }
      speakNumber(4000);
      clickCount66 = 1;
    } else if (clickCount66 === 1) {
      // Second click: Fill 300 yellow dots in the 30×10 rectangle
      const blackRectangle30x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle30x10Cols = [26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55];
      
      for (let row of blackRectangle30x10Rows) {
        for (let col of blackRectangle30x10Cols) {
          const idx = row * gridSize66 + col;
          grid66Circles[idx].classList.remove(...COLOR_CLASSES);
          grid66Circles[idx].classList.add('yellow');
        }
      }
      speakNumber(4300); // 4000 green + 300 yellow
      clickCount66 = 2;
    } else if (clickCount66 === 2) {
      // Third click: Fill 50 blue dots in the 6×10 rectangle, leaving 6 black dots:
      // - Row 0: 3 black dots all the way to the right (cols 63, 64, 65)
      // - Row 1: 2 black dots all the way to the right (cols 64, 65)
      // - Row 2: 1 black dot all the way to the right (col 65)
      const blackRectangle6x10Rows = [0, 1, 2, 3, 4, 5];
      const blackRectangle6x10Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65];
      
      // Dots that should remain black after third click:
      const remainingBlackIndices = new Set([
        0 * gridSize66 + 63, // Row 0, Col 63
        0 * gridSize66 + 64, // Row 0, Col 64
        0 * gridSize66 + 65, // Row 0, Col 65
        1 * gridSize66 + 64, // Row 1, Col 64
        1 * gridSize66 + 65, // Row 1, Col 65
        2 * gridSize66 + 65  // Row 2, Col 65
      ]);
      
      // Find all black dots in the 6×10 rectangle (excluding the ones that should remain black)
      const blackDotIndices = [];
      for (let row of blackRectangle6x10Rows) {
        for (let col of blackRectangle6x10Cols) {
          const idx = row * gridSize66 + col;
          const circle = grid66Circles[idx];
          
          // Check if this dot is black (not green) and not in the remaining black set
          if (!circle.classList.contains('green') && !remainingBlackIndices.has(idx)) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 50 blue dots
      for (let i = 0; i < 50 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid66Circles[idx].classList.remove(...COLOR_CLASSES);
        grid66Circles[idx].classList.add('blue');
      }
      speakNumber(4350); // 4000 green + 300 yellow + 50 blue
      clickCount66 = 3;
    } else if (clickCount66 === 3) {
      // Fourth click: Fill the remaining 6 black dots with purple
      const purpleIndices = [
        0 * gridSize66 + 63, // Row 0, Col 63
        0 * gridSize66 + 64, // Row 0, Col 64
        0 * gridSize66 + 65, // Row 0, Col 65
        1 * gridSize66 + 64, // Row 1, Col 64
        1 * gridSize66 + 65, // Row 1, Col 65
        2 * gridSize66 + 65  // Row 2, Col 65
      ];
      
      for (let idx of purpleIndices) {
        grid66Circles[idx].classList.remove(...COLOR_CLASSES);
        grid66Circles[idx].classList.add('purple');
      }
      speakNumber(4356); // All 4356 dots filled
      clickCount66 = 4;
      
      // Show answer
      if (answerDisplay66) {
        answerDisplay66.textContent = '4356';
        answerDisplay66.classList.add('show');
      }
    } else {
      // Reset
      grid66Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'green', 'yellow', 'blue', 'purple');
      });
      speakNumber(0);
      clickCount66 = 0;
      if (answerDisplay66) {
        answerDisplay66.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid66Section);
  
  // Create 67×67 grid (4489 dots) with special click behavior
  const grid67Section = document.createElement('section');
  grid67Section.className = 'set';
  grid67Section.style.marginBottom = '40px';
  grid67Section.id = 'square-4489';
  
  const h2_67 = document.createElement('h2');
  h2_67.textContent = '67²';
  grid67Section.appendChild(h2_67);
  
  const grid67 = document.createElement('div');
  grid67.className = 'grid-dynamic grid-4489';
  grid67.id = 'square-4489';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid67.style.gridTemplateColumns = 'repeat(67, calc(var(--circle-total) * 13 / 67))';
  grid67.style.gridTemplateRows = 'repeat(67, calc(var(--circle-total) * 13 / 67))';
  grid67.style.width = 'calc(var(--circle-total) * 13)';
  grid67.style.height = 'calc(var(--circle-total) * 13)';
  grid67.style.position = 'relative';
  
  const gridSize67 = 67;
  const totalDots67 = 4489;
  const grid67Circles = [];
  
  // Create all 4489 circles
  for (let i = 0; i < totalDots67; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-4489';
    grid67.appendChild(circle);
    grid67Circles.push(circle);
  }
  
  grid67Section.appendChild(grid67);
  
  // Add answer display
  const answerDisplay67 = document.createElement('div');
  answerDisplay67.className = 'answer-display';
  answerDisplay67.dataset.answer = '4489';
  grid67Section.appendChild(answerDisplay67);
  
  // Click handler for 67×67 grid
  let clickCount67 = 0;
  const separatedCircles67 = []; // Track separated circles for movement
  
  grid67.addEventListener('click', () => {
    if (clickCount67 === 0) {
      // First click: Fill 4000 green dots from the bottom row upward, leaving:
      // - 40×10 rectangle: rows 0-9, cols 17-56 (400 dots)
      // - 9×10 rectangle: rows 0-8, cols 57-66 (90 dots) in top right corner
      // The 9×10 rectangle is black EXCEPT the bottom-left corner (row 8, col 57) which is green
      const blackRectangle40x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle40x10Cols = [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56];
      const blackRectangle9x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackRectangle9x10Cols = [57, 58, 59, 60, 61, 62, 63, 64, 65, 66];
      const blackIndices = new Set();
      
      // Add 40×10 rectangle indices
      for (let row of blackRectangle40x10Rows) {
        for (let col of blackRectangle40x10Cols) {
          blackIndices.add(row * gridSize67 + col);
        }
      }
      
      // Add 9×10 rectangle indices
      for (let row of blackRectangle9x10Rows) {
        for (let col of blackRectangle9x10Cols) {
          blackIndices.add(row * gridSize67 + col);
        }
      }
      
      // Bottom-left corner of 9×10: row 8, col 57 - this should be green
      const bottomLeftCornerIdx = 8 * gridSize67 + 57;
      blackIndices.delete(bottomLeftCornerIdx); // Remove it from black indices so it gets filled with green
      
      let greenCount = 0;
      // Fill from bottom row (row 66) upward
      for (let row = gridSize67 - 1; row >= 0 && greenCount < 4000; row--) {
        for (let col = 0; col < gridSize67 && greenCount < 4000; col++) {
          const idx = row * gridSize67 + col;
          // Skip dots in the black areas (except the bottom-left corner of 9×10)
          if (!blackIndices.has(idx)) {
            grid67Circles[idx].classList.remove(...COLOR_CLASSES);
            grid67Circles[idx].classList.add('green');
            greenCount++;
          }
        }
      }
      speakNumber(4000);
      clickCount67 = 1;
    } else if (clickCount67 === 1) {
      // Second click: Fill 400 green dots in the 40×10 rectangle and move it up by 1 dot diameter
      const blackRectangle40x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle40x10Cols = [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56];
      
      // Fill all 400 dots in rectangle and move them up
      for (let row of blackRectangle40x10Rows) {
        for (let col of blackRectangle40x10Cols) {
          const idx = row * gridSize67 + col;
          const circle = grid67Circles[idx];
          
          // Hide the original circle
          circle.style.visibility = 'hidden';
          
          // Create a separated circle that moves up by 1 dot diameter
          const separatedCircle = document.createElement('div');
          separatedCircle.className = 'circle green';
          separatedCircle.style.position = 'absolute';
          separatedCircle.style.zIndex = '5';
          separatedCircle.dataset.originalRow = row;
          separatedCircle.dataset.originalCol = col;
          
          // Copy size classes
          circle.classList.forEach(cls => {
            if (cls.startsWith('circle-')) {
              separatedCircle.classList.add(cls);
            }
          });
          
          // Move up by 1 dot diameter (straight up)
          // Use scaled circle size variable for 67×67 grid
          separatedCircle.style.left = `calc(var(--circle-total-4489) * ${col})`;
          separatedCircle.style.top = `calc(var(--circle-total-4489) * ${row} - var(--circle-total-4489))`;
          separatedCircle.style.transform = 'none';
          
          grid67.appendChild(separatedCircle);
          separatedCircles67.push(separatedCircle);
        }
      }
      speakNumber(4400); // 4000 green + 400 green
      clickCount67 = 2;
    } else if (clickCount67 === 2) {
      // Third click: Fill 80 pink dots in the 9×10 rectangle, leaving a 3×3 black square in the top-right corner
      const blackRectangle9x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackRectangle9x10Cols = [57, 58, 59, 60, 61, 62, 63, 64, 65, 66];
      
      // 3×3 square in top-right corner of 9×10: rows 0-2, cols 64-66
      const topRight3x3Rows = [0, 1, 2];
      const topRight3x3Cols = [64, 65, 66];
      const topRight3x3Indices = new Set();
      
      // Add 3×3 square indices
      for (let row of topRight3x3Rows) {
        for (let col of topRight3x3Cols) {
          topRight3x3Indices.add(row * gridSize67 + col);
        }
      }
      
      // Find all black dots in the 9×10 rectangle (excluding the 3×3 square)
      const blackDotIndices = [];
      for (let row of blackRectangle9x10Rows) {
        for (let col of blackRectangle9x10Cols) {
          const idx = row * gridSize67 + col;
          const circle = grid67Circles[idx];
          
          // Check if this dot is black (not green) and not in the 3×3 square
          if (!circle.classList.contains('green') && !topRight3x3Indices.has(idx)) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 80 pink dots
      for (let i = 0; i < 80 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid67Circles[idx].classList.remove(...COLOR_CLASSES);
        grid67Circles[idx].classList.add('pink');
      }
      speakNumber(4480); // 4000 green + 400 green + 80 pink
      clickCount67 = 3;
    } else if (clickCount67 === 3) {
      // Fourth click: Fill the 3×3 square (9 dots) with sky blue
      const topRight3x3Rows = [0, 1, 2];
      const topRight3x3Cols = [64, 65, 66];
      
      for (let row of topRight3x3Rows) {
        for (let col of topRight3x3Cols) {
          const idx = row * gridSize67 + col;
          grid67Circles[idx].classList.remove(...COLOR_CLASSES);
          grid67Circles[idx].classList.add('sky');
        }
      }
      speakNumber(4489); // All 4489 dots filled
      clickCount67 = 4;
      
      // Show answer
      if (answerDisplay67) {
        answerDisplay67.textContent = '4489';
        answerDisplay67.classList.add('show');
      }
    } else {
      // Reset
      // Remove separated circles
      separatedCircles67.forEach(sc => sc.remove());
      separatedCircles67.length = 0;
      
      // Reset all circles
      grid67Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'green', 'pink', 'sky');
        circle.style.visibility = 'visible'; // Make sure visibility is reset
      });
      speakNumber(0);
      clickCount67 = 0;
      if (answerDisplay67) {
        answerDisplay67.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid67Section);
  
  // Create 68×68 grid (4624 dots) with special click behavior
  const grid68Section = document.createElement('section');
  grid68Section.className = 'set';
  grid68Section.style.marginBottom = '40px';
  grid68Section.id = 'square-4624';
  
  const h2_68 = document.createElement('h2');
  h2_68.textContent = '68²';
  grid68Section.appendChild(h2_68);
  
  const grid68 = document.createElement('div');
  grid68.className = 'grid-dynamic grid-4624';
  grid68.id = 'square-4624';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid68.style.gridTemplateColumns = 'repeat(68, calc(var(--circle-total) * 13 / 68))';
  grid68.style.gridTemplateRows = 'repeat(68, calc(var(--circle-total) * 13 / 68))';
  grid68.style.width = 'calc(var(--circle-total) * 13)';
  grid68.style.height = 'calc(var(--circle-total) * 13)';
  grid68.style.position = 'relative';
  
  const gridSize68 = 68;
  const totalDots68 = 4624;
  const grid68Circles = [];
  
  // Create all 4624 circles
  for (let i = 0; i < totalDots68; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-4624';
    grid68.appendChild(circle);
    grid68Circles.push(circle);
  }
  
  grid68Section.appendChild(grid68);
  
  // Add answer display
  const answerDisplay68 = document.createElement('div');
  answerDisplay68.className = 'answer-display';
  answerDisplay68.dataset.answer = '4624';
  grid68Section.appendChild(answerDisplay68);
  
  // Click handler for 68×68 grid
  let clickCount68 = 0;
  
  grid68.addEventListener('click', () => {
    if (clickCount68 === 0) {
      // First click: Fill 4000 green dots from the bottom row upward, leaving:
      // - 30×20 rectangle: rows 0-19, cols 33-62 (600 dots)
      // - 5×5 square: rows 0-4, cols 63-67 (25 dots) in top right corner
      // The 5×5 square is black EXCEPT the bottom-left corner (row 4, col 63) which is green
      const blackRectangle30x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle30x20Cols = [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62];
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      const blackSquare5x5Cols = [63, 64, 65, 66, 67];
      const blackIndices = new Set();
      
      // Add 30×20 rectangle indices
      for (let row of blackRectangle30x20Rows) {
        for (let col of blackRectangle30x20Cols) {
          blackIndices.add(row * gridSize68 + col);
        }
      }
      
      // Add 5×5 square indices
      for (let row of blackSquare5x5Rows) {
        for (let col of blackSquare5x5Cols) {
          blackIndices.add(row * gridSize68 + col);
        }
      }
      
      // Bottom-left corner of 5×5: row 4, col 63 - this should be green
      const bottomLeftCornerIdx = 4 * gridSize68 + 63;
      blackIndices.delete(bottomLeftCornerIdx); // Remove it from black indices so it gets filled with green
      
      let greenCount = 0;
      // Fill from bottom row (row 67) upward
      for (let row = gridSize68 - 1; row >= 0 && greenCount < 4000; row--) {
        for (let col = 0; col < gridSize68 && greenCount < 4000; col++) {
          const idx = row * gridSize68 + col;
          // Skip dots in the black areas (except the bottom-left corner of 5×5)
          if (!blackIndices.has(idx)) {
            grid68Circles[idx].classList.remove(...COLOR_CLASSES);
            grid68Circles[idx].classList.add('green');
            greenCount++;
          }
        }
      }
      speakNumber(4000);
      clickCount68 = 1;
    } else if (clickCount68 === 1) {
      // Second click: Fill 600 purple dots in the 30×20 rectangle
      const blackRectangle30x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle30x20Cols = [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62];
      
      for (let row of blackRectangle30x20Rows) {
        for (let col of blackRectangle30x20Cols) {
          const idx = row * gridSize68 + col;
          grid68Circles[idx].classList.remove(...COLOR_CLASSES);
          grid68Circles[idx].classList.add('purple');
        }
      }
      speakNumber(4600); // 4000 green + 600 purple
      clickCount68 = 2;
    } else if (clickCount68 === 2) {
      // Third click: Fill 20 orange dots in the 5×5 square, leaving a 2×2 black rectangle in the top-right corner
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      const blackSquare5x5Cols = [63, 64, 65, 66, 67];
      
      // 2×2 rectangle in top-right corner of 5×5: rows 0-1, cols 66-67
      const topRight2x2Rows = [0, 1];
      const topRight2x2Cols = [66, 67];
      const topRight2x2Indices = new Set();
      
      // Add 2×2 rectangle indices
      for (let row of topRight2x2Rows) {
        for (let col of topRight2x2Cols) {
          topRight2x2Indices.add(row * gridSize68 + col);
        }
      }
      
      // Find all black dots in the 5×5 square (excluding the 2×2 rectangle)
      const blackDotIndices = [];
      for (let row of blackSquare5x5Rows) {
        for (let col of blackSquare5x5Cols) {
          const idx = row * gridSize68 + col;
          const circle = grid68Circles[idx];
          
          // Check if this dot is black (not green) and not in the 2×2 rectangle
          if (!circle.classList.contains('green') && !topRight2x2Indices.has(idx)) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 20 orange dots
      for (let i = 0; i < 20 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid68Circles[idx].classList.remove(...COLOR_CLASSES);
        grid68Circles[idx].classList.add('orange');
      }
      speakNumber(4620); // 4000 green + 600 purple + 20 orange
      clickCount68 = 3;
    } else if (clickCount68 === 3) {
      // Fourth click: Fill the 2×2 rectangle (4 dots) with green
      const topRight2x2Rows = [0, 1];
      const topRight2x2Cols = [66, 67];
      
      for (let row of topRight2x2Rows) {
        for (let col of topRight2x2Cols) {
          const idx = row * gridSize68 + col;
          grid68Circles[idx].classList.remove(...COLOR_CLASSES);
          grid68Circles[idx].classList.add('green');
        }
      }
      speakNumber(4624); // All 4624 dots filled
      clickCount68 = 4;
      
      // Show answer
      if (answerDisplay68) {
        answerDisplay68.textContent = '4624';
        answerDisplay68.classList.add('show');
      }
    } else {
      // Reset
      grid68Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'green', 'purple', 'orange');
      });
      speakNumber(0);
      clickCount68 = 0;
      if (answerDisplay68) {
        answerDisplay68.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid68Section);
  
  // Create 69×69 grid (4761 dots) with special click behavior
  const grid69Section = document.createElement('section');
  grid69Section.className = 'set';
  grid69Section.style.marginBottom = '40px';
  grid69Section.id = 'square-4761';
  
  const h2_69 = document.createElement('h2');
  h2_69.textContent = '69²';
  grid69Section.appendChild(h2_69);
  
  const grid69 = document.createElement('div');
  grid69.className = 'grid-dynamic grid-4761';
  grid69.id = 'square-4761';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid69.style.gridTemplateColumns = 'repeat(69, calc(var(--circle-total) * 13 / 69))';
  grid69.style.gridTemplateRows = 'repeat(69, calc(var(--circle-total) * 13 / 69))';
  grid69.style.width = 'calc(var(--circle-total) * 13)';
  grid69.style.height = 'calc(var(--circle-total) * 13)';
  grid69.style.position = 'relative';
  
  const gridSize69 = 69;
  const totalDots69 = 4761;
  const grid69Circles = [];
  
  // Create all 4761 circles
  for (let i = 0; i < totalDots69; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-4761';
    grid69.appendChild(circle);
    grid69Circles.push(circle);
  }
  
  grid69Section.appendChild(grid69);
  
  // Add answer display
  const answerDisplay69 = document.createElement('div');
  answerDisplay69.className = 'answer-display';
  answerDisplay69.dataset.answer = '4761';
  grid69Section.appendChild(answerDisplay69);
  
  // Click handler for 69×69 grid
  let clickCount69 = 0;
  
  grid69.addEventListener('click', () => {
    if (clickCount69 === 0) {
      // First click: Fill 4000 green dots from the bottom row upward, leaving:
      // - 20×35 rectangle: rows 0-19, cols 26-60 (700 dots total, 600 green, 100 black)
      // - 8×8 square: rows 0-7, cols 61-68 (64 dots total, 3 green, 61 black) in top right corner
      const blackRectangle20x35Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x35Cols = [26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60];
      const blackSquare8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackSquare8x8Cols = [61, 62, 63, 64, 65, 66, 67, 68];
      const blackIndices = new Set();
      
      // Add all 20×35 rectangle indices (700 dots)
      for (let row of blackRectangle20x35Rows) {
        for (let col of blackRectangle20x35Cols) {
          blackIndices.add(row * gridSize69 + col);
        }
      }
      
      // Add all 8×8 square indices (64 dots)
      for (let row of blackSquare8x8Rows) {
        for (let col of blackSquare8x8Cols) {
          blackIndices.add(row * gridSize69 + col);
        }
      }
      
      // Bottom-left corner of 8×8: 3 dots that should be green
      // Row 6, col 61; Row 7, col 61; Row 7, col 62
      const bottomLeft3DotsIndices = [
        6 * gridSize69 + 61, // Row 6, Col 61
        7 * gridSize69 + 61, // Row 7, Col 61
        7 * gridSize69 + 62  // Row 7, Col 62
      ];
      
      // Remove the 3 bottom-left dots from black indices so they get filled with green
      bottomLeft3DotsIndices.forEach(idx => blackIndices.delete(idx));
      
      // In the 20×35 rectangle, 600 dots should be green, 100 should be black
      // We'll fill 600 green dots from the rectangle, leaving 100 black
      // To do this, we'll mark 100 specific dots in the rectangle as black
      // Let's make the top-right portion of the rectangle black (100 dots)
      // 100 dots in a rectangle could be 10 rows × 10 columns, or 5 rows × 20 columns, etc.
      // Let's use rows 0-9, cols 51-60 (10 rows × 10 columns = 100 dots)
      const blackRectangle100DotsRows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle100DotsCols = [51, 52, 53, 54, 55, 56, 57, 58, 59, 60];
      for (let row of blackRectangle100DotsRows) {
        for (let col of blackRectangle100DotsCols) {
          blackIndices.add(row * gridSize69 + col);
        }
      }
      
      let greenCount = 0;
      // Fill from bottom row (row 68) upward
      for (let row = gridSize69 - 1; row >= 0 && greenCount < 4000; row--) {
        for (let col = 0; col < gridSize69 && greenCount < 4000; col++) {
          const idx = row * gridSize69 + col;
          // Skip dots in the black areas (except the 3 bottom-left dots of 8×8 and the 600 green dots in rectangle)
          if (!blackIndices.has(idx)) {
            grid69Circles[idx].classList.remove(...COLOR_CLASSES);
            grid69Circles[idx].classList.add('green');
            greenCount++;
          }
        }
      }
      speakNumber(4000);
      clickCount69 = 1;
    } else if (clickCount69 === 1) {
      // Second click: Fill the 20×35 rectangle with brown (all 700 dots, but 600 are already green, so fill the 100 black ones)
      const blackRectangle20x35Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x35Cols = [26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60];
      
      // Fill all dots in the rectangle that are black (not green)
      for (let row of blackRectangle20x35Rows) {
        for (let col of blackRectangle20x35Cols) {
          const idx = row * gridSize69 + col;
          if (!grid69Circles[idx].classList.contains('green')) {
            grid69Circles[idx].classList.remove(...COLOR_CLASSES);
            grid69Circles[idx].classList.add('brown');
          }
        }
      }
      speakNumber(4700); // 4000 green + 700 brown (all dots in 20×35 rectangle)
      clickCount69 = 2;
    } else if (clickCount69 === 2) {
      // Third click: Fill 60 purple dots in the 8×8 square, leaving the top-right corner black
      const blackSquare8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackSquare8x8Cols = [61, 62, 63, 64, 65, 66, 67, 68];
      
      // Top-right corner: row 0, col 68 - this should stay black
      const topRightCornerIdx = 0 * gridSize69 + 68;
      
      // Find all black dots in the 8×8 square (excluding the 3 green dots in bottom-left and the top-right corner)
      const blackDotIndices = [];
      for (let row of blackSquare8x8Rows) {
        for (let col of blackSquare8x8Cols) {
          const idx = row * gridSize69 + col;
          const circle = grid69Circles[idx];
          
          // Check if this dot is black (not green) and not the top-right corner
          if (!circle.classList.contains('green') && idx !== topRightCornerIdx) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 60 purple dots
      for (let i = 0; i < 60 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid69Circles[idx].classList.remove(...COLOR_CLASSES);
        grid69Circles[idx].classList.add('purple');
      }
      speakNumber(4760); // 4000 green + 700 brown + 60 purple
      clickCount69 = 3;
    } else if (clickCount69 === 3) {
      // Fourth click: Fill the top-right corner (row 0, col 68) with red
      const topRightCornerIdx = 0 * gridSize69 + 68;
      
      grid69Circles[topRightCornerIdx].classList.remove(...COLOR_CLASSES);
      grid69Circles[topRightCornerIdx].classList.add('red-final');
      speakNumber(4761); // All 4761 dots filled
      clickCount69 = 4;
      
      // Show answer
      if (answerDisplay69) {
        answerDisplay69.textContent = '4761';
        answerDisplay69.classList.add('show');
      }
    } else {
      // Reset
      grid69Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'green', 'brown', 'purple', 'red-final');
      });
      speakNumber(0);
      clickCount69 = 0;
      if (answerDisplay69) {
        answerDisplay69.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid69Section);
  
  // Create 70×70 grid (4900 dots) with special click behavior
  const grid70Section = document.createElement('section');
  grid70Section.className = 'set';
  grid70Section.style.marginBottom = '40px';
  grid70Section.id = 'square-4900';
  
  const h2_70 = document.createElement('h2');
  h2_70.textContent = '70²';
  grid70Section.appendChild(h2_70);
  
  const grid70 = document.createElement('div');
  grid70.className = 'grid-dynamic grid-4900';
  grid70.id = 'square-4900';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid70.style.gridTemplateColumns = 'repeat(70, calc(var(--circle-total) * 13 / 70))';
  grid70.style.gridTemplateRows = 'repeat(70, calc(var(--circle-total) * 13 / 70))';
  grid70.style.width = 'calc(var(--circle-total) * 13)';
  grid70.style.height = 'calc(var(--circle-total) * 13)';
  grid70.style.position = 'relative';
  
  const gridSize70 = 70;
  const totalDots70 = 4900;
  const grid70Circles = [];
  
  // Create all 4900 circles
  for (let i = 0; i < totalDots70; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-4900';
    grid70.appendChild(circle);
    grid70Circles.push(circle);
  }
  
  grid70Section.appendChild(grid70);
  
  // Add answer display
  const answerDisplay70 = document.createElement('div');
  answerDisplay70.className = 'answer-display';
  answerDisplay70.dataset.answer = '4900';
  grid70Section.appendChild(answerDisplay70);
  
  // Click handler for 70×70 grid
  let clickCount70 = 0;
  
  grid70.addEventListener('click', () => {
    if (clickCount70 === 0) {
      // First click: Fill 4000 green dots from the bottom row upward
      let greenCount = 0;
      // Fill from bottom row (row 69) upward
      for (let row = gridSize70 - 1; row >= 0 && greenCount < 4000; row--) {
        for (let col = 0; col < gridSize70 && greenCount < 4000; col++) {
          const idx = row * gridSize70 + col;
          grid70Circles[idx].classList.remove(...COLOR_CLASSES);
          grid70Circles[idx].classList.add('green');
          greenCount++;
        }
      }
      speakNumber(4000);
      clickCount70 = 1;
    } else if (clickCount70 === 1) {
      // Second click: Fill 900 sky blue dots from the bottom row upward (remaining dots)
      let skyBlueCount = 0;
      // Fill from bottom row (row 69) upward
      for (let row = gridSize70 - 1; row >= 0 && skyBlueCount < 900; row--) {
        for (let col = 0; col < gridSize70 && skyBlueCount < 900; col++) {
          const idx = row * gridSize70 + col;
          // Skip dots that are already green
          if (!grid70Circles[idx].classList.contains('green')) {
            grid70Circles[idx].classList.remove(...COLOR_CLASSES);
            grid70Circles[idx].classList.add('sky');
            skyBlueCount++;
          }
        }
      }
      speakNumber(4900); // All 4900 dots filled
      clickCount70 = 2;
      
      // Show answer
      if (answerDisplay70) {
        answerDisplay70.textContent = '4900';
        answerDisplay70.classList.add('show');
      }
    } else {
      // Reset
      grid70Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'green', 'sky');
      });
      speakNumber(0);
      clickCount70 = 0;
      if (answerDisplay70) {
        answerDisplay70.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid70Section);
  
  // Create 71×71 grid (5041 dots) with special click behavior
  const grid71Section = document.createElement('section');
  grid71Section.className = 'set';
  grid71Section.style.marginBottom = '40px';
  grid71Section.id = 'square-5041';
  
  const h2_71 = document.createElement('h2');
  h2_71.textContent = '71²';
  grid71Section.appendChild(h2_71);
  
  const grid71 = document.createElement('div');
  grid71.className = 'grid-dynamic grid-5041';
  grid71.id = 'square-5041';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid71.style.gridTemplateColumns = 'repeat(71, calc(var(--circle-total) * 13 / 71))';
  grid71.style.gridTemplateRows = 'repeat(71, calc(var(--circle-total) * 13 / 71))';
  grid71.style.width = 'calc(var(--circle-total) * 13)';
  grid71.style.height = 'calc(var(--circle-total) * 13)';
  grid71.style.position = 'relative';
  
  const gridSize71 = 71;
  const totalDots71 = 5041;
  const grid71Circles = [];
  
  // Create all 5041 circles
  for (let i = 0; i < totalDots71; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-5041';
    grid71.appendChild(circle);
    grid71Circles.push(circle);
  }
  
  grid71Section.appendChild(grid71);
  
  // Add answer display
  const answerDisplay71 = document.createElement('div');
  answerDisplay71.className = 'answer-display';
  answerDisplay71.dataset.answer = '5041';
  grid71Section.appendChild(answerDisplay71);
  
  // Click handler for 71×71 grid
  let clickCount71 = 0;
  
  grid71.addEventListener('click', () => {
    if (clickCount71 === 0) {
      // First click: Fill 5000 blue dots from the bottom row upward, leaving:
      // - 7×6 rectangle: rows 0-6, cols 65-70 (42 dots) in top right corner
      // The bottom-left corner of the rectangle (row 6, col 65) is blue (part of 5000)
      const blackRectangle7x6Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle7x6Cols = [65, 66, 67, 68, 69, 70];
      const blackIndices = new Set();
      
      // Add all 7×6 rectangle indices (42 dots)
      for (let row of blackRectangle7x6Rows) {
        for (let col of blackRectangle7x6Cols) {
          blackIndices.add(row * gridSize71 + col);
        }
      }
      
      // Bottom-left corner of rectangle: row 6, col 65 - this should be blue
      const bottomLeftCornerIdx = 6 * gridSize71 + 65;
      blackIndices.delete(bottomLeftCornerIdx); // Remove it from black indices so it gets filled with blue
      
      let blueCount = 0;
      // Fill from bottom row (row 70) upward
      for (let row = gridSize71 - 1; row >= 0 && blueCount < 5000; row--) {
        for (let col = 0; col < gridSize71 && blueCount < 5000; col++) {
          const idx = row * gridSize71 + col;
          // Skip dots in the black rectangle (except the bottom-left corner)
          if (!blackIndices.has(idx)) {
            grid71Circles[idx].classList.remove(...COLOR_CLASSES);
            grid71Circles[idx].classList.add('blue');
            blueCount++;
          }
        }
      }
      speakNumber(5000);
      clickCount71 = 1;
    } else if (clickCount71 === 1) {
      // Second click: Fill 40 green dots in the 7×6 rectangle, leaving 1 black dot in the top-right corner
      const blackRectangle7x6Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle7x6Cols = [65, 66, 67, 68, 69, 70];
      
      // Top-right corner: row 0, col 70 - this should stay black
      const topRightCornerIdx = 0 * gridSize71 + 70;
      
      // Find all black dots in the 7×6 rectangle (excluding the top-right corner)
      const blackDotIndices = [];
      for (let row of blackRectangle7x6Rows) {
        for (let col of blackRectangle7x6Cols) {
          const idx = row * gridSize71 + col;
          const circle = grid71Circles[idx];
          
          // Check if this dot is black (not blue) and not the top-right corner
          if (!circle.classList.contains('blue') && idx !== topRightCornerIdx) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 40 green dots
      for (let i = 0; i < 40 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid71Circles[idx].classList.remove(...COLOR_CLASSES);
        grid71Circles[idx].classList.add('green');
      }
      speakNumber(5040); // 5000 blue + 40 green
      clickCount71 = 2;
    } else if (clickCount71 === 2) {
      // Third click: Fill the top-right corner (row 0, col 70) with red
      const topRightCornerIdx = 0 * gridSize71 + 70;
      
      grid71Circles[topRightCornerIdx].classList.remove(...COLOR_CLASSES);
      grid71Circles[topRightCornerIdx].classList.add('red-final');
      speakNumber(5041); // All 5041 dots filled
      clickCount71 = 3;
      
      // Show answer
      if (answerDisplay71) {
        answerDisplay71.textContent = '5041';
        answerDisplay71.classList.add('show');
      }
    } else {
      // Reset
      grid71Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'red-final');
      });
      speakNumber(0);
      clickCount71 = 0;
      if (answerDisplay71) {
        answerDisplay71.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid71Section);
  
  // Create 72×72 grid (5184 dots) with special click behavior
  const grid72Section = document.createElement('section');
  grid72Section.className = 'set';
  grid72Section.style.marginBottom = '40px';
  grid72Section.id = 'square-5184';
  
  const h2_72 = document.createElement('h2');
  h2_72.textContent = '72²';
  grid72Section.appendChild(h2_72);
  
  const grid72 = document.createElement('div');
  grid72.className = 'grid-dynamic grid-5184';
  grid72.id = 'square-5184';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid72.style.gridTemplateColumns = 'repeat(72, calc(var(--circle-total) * 13 / 72))';
  grid72.style.gridTemplateRows = 'repeat(72, calc(var(--circle-total) * 13 / 72))';
  grid72.style.width = 'calc(var(--circle-total) * 13)';
  grid72.style.height = 'calc(var(--circle-total) * 13)';
  grid72.style.position = 'relative';
  
  const gridSize72 = 72;
  const totalDots72 = 5184;
  const grid72Circles = [];
  
  // Create all 5184 circles
  for (let i = 0; i < totalDots72; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-5184';
    grid72.appendChild(circle);
    grid72Circles.push(circle);
  }
  
  grid72Section.appendChild(grid72);
  
  // Add answer display
  const answerDisplay72 = document.createElement('div');
  answerDisplay72.className = 'answer-display';
  answerDisplay72.dataset.answer = '5184';
  grid72Section.appendChild(answerDisplay72);
  
  // Click handler for 72×72 grid
  let clickCount72 = 0;
  
  grid72.addEventListener('click', () => {
    if (clickCount72 === 0) {
      // First click: Fill 5000 blue dots from the bottom row upward, leaving:
      // - 10×10 square: rows 0-9, cols 55-64 (100 dots)
      // - 12×7 rectangle: rows 0-11, cols 65-71 (84 dots) in top right corner
      const blackSquare10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackSquare10x10Cols = [55, 56, 57, 58, 59, 60, 61, 62, 63, 64];
      const blackRectangle12x7Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      const blackRectangle12x7Cols = [65, 66, 67, 68, 69, 70, 71];
      const blackIndices = new Set();
      
      // Add 10×10 square indices
      for (let row of blackSquare10x10Rows) {
        for (let col of blackSquare10x10Cols) {
          blackIndices.add(row * gridSize72 + col);
        }
      }
      
      // Add 12×7 rectangle indices
      for (let row of blackRectangle12x7Rows) {
        for (let col of blackRectangle12x7Cols) {
          blackIndices.add(row * gridSize72 + col);
        }
      }
      
      let blueCount = 0;
      // Fill from bottom row (row 71) upward
      for (let row = gridSize72 - 1; row >= 0 && blueCount < 5000; row--) {
        for (let col = 0; col < gridSize72 && blueCount < 5000; col++) {
          const idx = row * gridSize72 + col;
          // Skip dots in the black areas
          if (!blackIndices.has(idx)) {
            grid72Circles[idx].classList.remove(...COLOR_CLASSES);
            grid72Circles[idx].classList.add('blue');
            blueCount++;
          }
        }
      }
      speakNumber(5000);
      clickCount72 = 1;
    } else if (clickCount72 === 1) {
      // Second click: Fill the 10×10 square with red dots (100 dots)
      const blackSquare10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackSquare10x10Cols = [55, 56, 57, 58, 59, 60, 61, 62, 63, 64];
      
      for (let row of blackSquare10x10Rows) {
        for (let col of blackSquare10x10Cols) {
          const idx = row * gridSize72 + col;
          grid72Circles[idx].classList.remove(...COLOR_CLASSES);
          grid72Circles[idx].classList.add('red-final');
        }
      }
      speakNumber(5100); // 5000 blue + 100 red
      clickCount72 = 2;
    } else if (clickCount72 === 2) {
      // Third click: Fill 80 pink dots in the 12×7 rectangle, leaving a 2×2 square in the top-right corner
      const blackRectangle12x7Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      const blackRectangle12x7Cols = [65, 66, 67, 68, 69, 70, 71];
      
      // 2×2 square in top-right corner of 12×7: rows 0-1, cols 70-71
      const topRight2x2Rows = [0, 1];
      const topRight2x2Cols = [70, 71];
      const topRight2x2Indices = new Set();
      
      // Add 2×2 square indices
      for (let row of topRight2x2Rows) {
        for (let col of topRight2x2Cols) {
          topRight2x2Indices.add(row * gridSize72 + col);
        }
      }
      
      // Find all black dots in the 12×7 rectangle (excluding the 2×2 square)
      const blackDotIndices = [];
      for (let row of blackRectangle12x7Rows) {
        for (let col of blackRectangle12x7Cols) {
          const idx = row * gridSize72 + col;
          const circle = grid72Circles[idx];
          
          // Check if this dot is black (not blue) and not in the 2×2 square
          if (!circle.classList.contains('blue') && !topRight2x2Indices.has(idx)) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill 80 pink dots
      for (let i = 0; i < 80 && i < blackDotIndices.length; i++) {
        const idx = blackDotIndices[i];
        grid72Circles[idx].classList.remove(...COLOR_CLASSES);
        grid72Circles[idx].classList.add('pink');
      }
      speakNumber(5180); // 5000 blue + 100 red + 80 pink
      clickCount72 = 3;
    } else if (clickCount72 === 3) {
      // Fourth click: Fill the 2×2 square (4 dots) with green
      const topRight2x2Rows = [0, 1];
      const topRight2x2Cols = [70, 71];
      
      for (let row of topRight2x2Rows) {
        for (let col of topRight2x2Cols) {
          const idx = row * gridSize72 + col;
          grid72Circles[idx].classList.remove(...COLOR_CLASSES);
          grid72Circles[idx].classList.add('green');
        }
      }
      speakNumber(5184); // All 5184 dots filled
      clickCount72 = 4;
      
      // Show answer
      if (answerDisplay72) {
        answerDisplay72.textContent = '5184';
        answerDisplay72.classList.add('show');
      }
    } else {
      // Reset
      grid72Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'red-final', 'pink', 'green');
      });
      speakNumber(0);
      clickCount72 = 0;
      if (answerDisplay72) {
        answerDisplay72.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid72Section);
  
  // Create 73×73 grid (5329 dots) with special click behavior
  const grid73Section = document.createElement('section');
  grid73Section.className = 'set';
  grid73Section.style.marginBottom = '40px';
  grid73Section.id = 'square-5329';
  
  const h2_73 = document.createElement('h2');
  h2_73.textContent = '73²';
  grid73Section.appendChild(h2_73);
  
  const grid73 = document.createElement('div');
  grid73.className = 'grid-dynamic grid-5329';
  grid73.id = 'square-5329';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid73.style.gridTemplateColumns = 'repeat(73, calc(var(--circle-total) * 13 / 73))';
  grid73.style.gridTemplateRows = 'repeat(73, calc(var(--circle-total) * 13 / 73))';
  grid73.style.width = 'calc(var(--circle-total) * 13)';
  grid73.style.height = 'calc(var(--circle-total) * 13)';
  grid73.style.position = 'relative';
  
  const gridSize73 = 73;
  const totalDots73 = 5329;
  const grid73Circles = [];
  
  // Create all 5329 circles
  for (let i = 0; i < totalDots73; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-5329';
    grid73.appendChild(circle);
    grid73Circles.push(circle);
  }
  
  grid73Section.appendChild(grid73);
  
  // Add answer display
  const answerDisplay73 = document.createElement('div');
  answerDisplay73.className = 'answer-display';
  answerDisplay73.dataset.answer = '5329';
  grid73Section.appendChild(answerDisplay73);
  
  // Click handler for 73×73 grid
  let clickCount73 = 0;
  
  grid73.addEventListener('click', () => {
    if (clickCount73 === 0) {
      // First click: Fill 5000 blue dots from the bottom row upward, leaving:
      // - 30×10 rectangle: rows 0-9, cols 36-65 (300 dots)
      // - 5×4 rectangle: rows 0-4, cols 66-69 (20 dots)
      // - 3×3 rectangle: rows 0-2, cols 70-72 (9 dots) in top right corner
      const blackRectangle30x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle30x10Cols = [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65];
      const blackRectangle5x4Rows = [0, 1, 2, 3, 4];
      const blackRectangle5x4Cols = [66, 67, 68, 69];
      const blackSquare3x3Rows = [0, 1, 2];
      const blackSquare3x3Cols = [70, 71, 72];
      const blackIndices = new Set();
      
      // Add 30×10 rectangle indices
      for (let row of blackRectangle30x10Rows) {
        for (let col of blackRectangle30x10Cols) {
          blackIndices.add(row * gridSize73 + col);
        }
      }
      
      // Add 5×4 rectangle indices
      for (let row of blackRectangle5x4Rows) {
        for (let col of blackRectangle5x4Cols) {
          blackIndices.add(row * gridSize73 + col);
        }
      }
      
      // Add 3×3 rectangle indices
      for (let row of blackSquare3x3Rows) {
        for (let col of blackSquare3x3Cols) {
          blackIndices.add(row * gridSize73 + col);
        }
      }
      
      let blueCount = 0;
      // Fill from bottom row (row 72) upward
      for (let row = gridSize73 - 1; row >= 0 && blueCount < 5000; row--) {
        for (let col = 0; col < gridSize73 && blueCount < 5000; col++) {
          const idx = row * gridSize73 + col;
          // Skip dots in the black areas
          if (!blackIndices.has(idx)) {
            grid73Circles[idx].classList.remove(...COLOR_CLASSES);
            grid73Circles[idx].classList.add('blue');
            blueCount++;
          }
        }
      }
      speakNumber(5000);
      clickCount73 = 1;
    } else if (clickCount73 === 1) {
      // Second click: Fill 300 yellow dots in the 30×10 rectangle
      const blackRectangle30x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle30x10Cols = [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65];
      
      for (let row of blackRectangle30x10Rows) {
        for (let col of blackRectangle30x10Cols) {
          const idx = row * gridSize73 + col;
          grid73Circles[idx].classList.remove(...COLOR_CLASSES);
          grid73Circles[idx].classList.add('yellow');
        }
      }
      speakNumber(5300); // 5000 blue + 300 yellow
      clickCount73 = 2;
    } else if (clickCount73 === 2) {
      // Third click: Fill 20 orange dots in the 5×4 rectangle
      const blackRectangle5x4Rows = [0, 1, 2, 3, 4];
      const blackRectangle5x4Cols = [66, 67, 68, 69];
      
      for (let row of blackRectangle5x4Rows) {
        for (let col of blackRectangle5x4Cols) {
          const idx = row * gridSize73 + col;
          grid73Circles[idx].classList.remove(...COLOR_CLASSES);
          grid73Circles[idx].classList.add('orange');
        }
      }
      speakNumber(5320); // 5000 blue + 300 yellow + 20 orange
      clickCount73 = 3;
    } else if (clickCount73 === 3) {
      // Fourth click: Fill the 3×3 rectangle (9 dots) with sky blue
      const blackSquare3x3Rows = [0, 1, 2];
      const blackSquare3x3Cols = [70, 71, 72];
      
      for (let row of blackSquare3x3Rows) {
        for (let col of blackSquare3x3Cols) {
          const idx = row * gridSize73 + col;
          grid73Circles[idx].classList.remove(...COLOR_CLASSES);
          grid73Circles[idx].classList.add('sky');
        }
      }
      speakNumber(5329); // All 5329 dots filled
      clickCount73 = 4;
      
      // Show answer
      if (answerDisplay73) {
        answerDisplay73.textContent = '5329';
        answerDisplay73.classList.add('show');
      }
    } else {
      // Reset
      grid73Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'yellow', 'orange', 'sky');
      });
      speakNumber(0);
      clickCount73 = 0;
      if (answerDisplay73) {
        answerDisplay73.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid73Section);
  
  // Create 74×74 grid (5476 dots) with special click behavior
  const grid74Section = document.createElement('section');
  grid74Section.className = 'set';
  grid74Section.style.marginBottom = '40px';
  grid74Section.id = 'square-5476';
  
  const h2_74 = document.createElement('h2');
  h2_74.textContent = '74²';
  grid74Section.appendChild(h2_74);
  
  const grid74 = document.createElement('div');
  grid74.className = 'grid-dynamic grid-5476';
  grid74.id = 'square-5476';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid74.style.gridTemplateColumns = 'repeat(74, calc(var(--circle-total) * 13 / 74))';
  grid74.style.gridTemplateRows = 'repeat(74, calc(var(--circle-total) * 13 / 74))';
  grid74.style.width = 'calc(var(--circle-total) * 13)';
  grid74.style.height = 'calc(var(--circle-total) * 13)';
  grid74.style.position = 'relative';
  
  const gridSize74 = 74;
  const totalDots74 = 5476;
  const grid74Circles = [];
  
  // Create all 5476 circles
  for (let i = 0; i < totalDots74; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-5476';
    grid74.appendChild(circle);
    grid74Circles.push(circle);
  }
  
  grid74Section.appendChild(grid74);
  
  // Add answer display
  const answerDisplay74 = document.createElement('div');
  answerDisplay74.className = 'answer-display';
  answerDisplay74.dataset.answer = '5476';
  grid74Section.appendChild(answerDisplay74);
  
  // Click handler for 74×74 grid
  let clickCount74 = 0;
  
  grid74.addEventListener('click', () => {
    if (clickCount74 === 0) {
      // First click: Fill 5000 blue dots from the bottom row upward, leaving:
      // - 20×20 square: rows 0-19, cols 44-63 (400 dots)
      // - 8×10 rectangle: rows 0-7, cols 64-73 (80 dots) in top right corner
      // The bottom 2×2 (4 dots) of the 8×10 rectangle are blue (part of 5000)
      const blackSquare20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackSquare20x20Cols = [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
      const blackRectangle8x10Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackRectangle8x10Cols = [64, 65, 66, 67, 68, 69, 70, 71, 72, 73];
      const blackIndices = new Set();
      
      // Add 20×20 square indices
      for (let row of blackSquare20x20Rows) {
        for (let col of blackSquare20x20Cols) {
          blackIndices.add(row * gridSize74 + col);
        }
      }
      
      // Add 8×10 rectangle indices
      for (let row of blackRectangle8x10Rows) {
        for (let col of blackRectangle8x10Cols) {
          blackIndices.add(row * gridSize74 + col);
        }
      }
      
      // Bottom 2×2 of 8×10: rows 6-7, cols 64-65 (4 dots) - these should be blue
      const bottom2x2Indices = [
        6 * gridSize74 + 64, // Row 6, Col 64
        6 * gridSize74 + 65, // Row 6, Col 65
        7 * gridSize74 + 64, // Row 7, Col 64
        7 * gridSize74 + 65  // Row 7, Col 65
      ];
      
      // Remove the bottom 2×2 from black indices so it gets filled with blue
      bottom2x2Indices.forEach(idx => blackIndices.delete(idx));
      
      let blueCount = 0;
      // Fill from bottom row (row 73) upward
      for (let row = gridSize74 - 1; row >= 0 && blueCount < 5000; row--) {
        for (let col = 0; col < gridSize74 && blueCount < 5000; col++) {
          const idx = row * gridSize74 + col;
          // Skip dots in the black areas (except the bottom 2×2 of 8×10)
          if (!blackIndices.has(idx)) {
            grid74Circles[idx].classList.remove(...COLOR_CLASSES);
            grid74Circles[idx].classList.add('blue');
            blueCount++;
          }
        }
      }
      speakNumber(5000);
      clickCount74 = 1;
    } else if (clickCount74 === 1) {
      // Second click: Fill 400 green dots in the 20×20 square
      const blackSquare20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackSquare20x20Cols = [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63];
      
      for (let row of blackSquare20x20Rows) {
        for (let col of blackSquare20x20Cols) {
          const idx = row * gridSize74 + col;
          grid74Circles[idx].classList.remove(...COLOR_CLASSES);
          grid74Circles[idx].classList.add('green');
        }
      }
      speakNumber(5400); // 5000 blue + 400 green
      clickCount74 = 2;
    } else if (clickCount74 === 2) {
      // Third click: Fill dots in the 8×10 rectangle, leaving 6 black dots:
      // - Row 0: 3 dots all the way to the right (cols 71, 72, 73)
      // - Row 1: 2 dots on the top right (cols 72, 73)
      // - Row 2: 1 dot (col 73)
      const blackRectangle8x10Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackRectangle8x10Cols = [64, 65, 66, 67, 68, 69, 70, 71, 72, 73];
      
      // Dots that should remain black after third click:
      const remainingBlackIndices = new Set([
        0 * gridSize74 + 71, // Row 0, Col 71
        0 * gridSize74 + 72, // Row 0, Col 72
        0 * gridSize74 + 73, // Row 0, Col 73
        1 * gridSize74 + 72, // Row 1, Col 72
        1 * gridSize74 + 73, // Row 1, Col 73
        2 * gridSize74 + 73  // Row 2, Col 73
      ]);
      
      // Find all black dots in the 8×10 rectangle (excluding the ones that should remain black)
      const blackDotIndices = [];
      for (let row of blackRectangle8x10Rows) {
        for (let col of blackRectangle8x10Cols) {
          const idx = row * gridSize74 + col;
          const circle = grid74Circles[idx];
          
          // Check if this dot is black (not blue) and not in the remaining black set
          if (!circle.classList.contains('blue') && !remainingBlackIndices.has(idx)) {
            blackDotIndices.push(idx);
          }
        }
      }
      
      // Fill all remaining black dots (should be 70 dots: 80 total - 4 blue - 6 black = 70)
      // Digit-based coloring: 70 = 7 (tens) + 0 (ones)
      // First digit 7 = brown (COLOR_MAP: 7 = brown)
      // So 70 dots should be brown
      const colorFor70 = COLOR_MAP[7] || 'brown'; // 7 = brown
      for (let idx of blackDotIndices) {
        grid74Circles[idx].classList.remove(...COLOR_CLASSES);
        grid74Circles[idx].classList.add(colorFor70);
      }
      speakNumber(5470); // 5000 blue + 400 green + 70 brown
      clickCount74 = 3;
    } else if (clickCount74 === 3) {
      // Fourth click: Fill the remaining 6 black dots with purple
      const purpleIndices = [
        0 * gridSize74 + 71, // Row 0, Col 71
        0 * gridSize74 + 72, // Row 0, Col 72
        0 * gridSize74 + 73, // Row 0, Col 73
        1 * gridSize74 + 72, // Row 1, Col 72
        1 * gridSize74 + 73, // Row 1, Col 73
        2 * gridSize74 + 73  // Row 2, Col 73
      ];
      
      for (let idx of purpleIndices) {
        grid74Circles[idx].classList.remove(...COLOR_CLASSES);
        grid74Circles[idx].classList.add('purple');
      }
      speakNumber(5476); // All 5476 dots filled
      clickCount74 = 4;
      
      // Show answer
      if (answerDisplay74) {
        answerDisplay74.textContent = '5476';
        answerDisplay74.classList.add('show');
      }
    } else {
      // Reset
      grid74Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple');
      });
      speakNumber(0);
      clickCount74 = 0;
      if (answerDisplay74) {
        answerDisplay74.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid74Section);
  
  // Create 75×75 grid (5625 dots) with special click behavior
  // color my Math
  const grid75Section = document.createElement('section');
  grid75Section.className = 'set';
  grid75Section.style.marginBottom = '40px';
  grid75Section.id = 'square-5625';
  
  const h2_75 = document.createElement('h2');
  h2_75.textContent = '75²';
  grid75Section.appendChild(h2_75);
  
  const grid75 = document.createElement('div');
  grid75.className = 'grid-dynamic grid-5625';
  grid75.id = 'square-5625';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid75.style.gridTemplateColumns = 'repeat(75, calc(var(--circle-total) * 13 / 75))';
  grid75.style.gridTemplateRows = 'repeat(75, calc(var(--circle-total) * 13 / 75))';
  grid75.style.width = 'calc(var(--circle-total) * 13)';
  grid75.style.height = 'calc(var(--circle-total) * 13)';
  grid75.style.position = 'relative';
  
  const gridSize75 = 75;
  const totalDots75 = 5625;
  const grid75Circles = [];
  
  // Create all 5625 circles
  for (let i = 0; i < totalDots75; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-5625';
    grid75.appendChild(circle);
    grid75Circles.push(circle);
  }
  
  grid75Section.appendChild(grid75);
  
  // Add answer display
  const answerDisplay75 = document.createElement('div');
  answerDisplay75.className = 'answer-display';
  answerDisplay75.dataset.answer = '5625';
  grid75Section.appendChild(answerDisplay75);
  
  // Click handler for 75×75 grid
  let clickCount75 = 0;
  
  grid75.addEventListener('click', () => {
    if (clickCount75 === 0) {
      // First click: Fill 5000 dots from the bottom row upward, leaving:
      // - 20×30 rectangle: rows 0-19, cols 40-69 (600 dots) in top right
      // - 5×5 square: rows 0-4, cols 70-74 (25 dots) in top right corner
      const blackRectangle20x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x30Cols = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69];
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      const blackSquare5x5Cols = [70, 71, 72, 73, 74];
      const blackIndices = new Set();
      
      // Add 20×30 rectangle indices
      for (let row of blackRectangle20x30Rows) {
        for (let col of blackRectangle20x30Cols) {
          blackIndices.add(row * gridSize75 + col);
        }
      }
      
      // Add 5×5 square indices
      for (let row of blackSquare5x5Rows) {
        for (let col of blackSquare5x5Cols) {
          blackIndices.add(row * gridSize75 + col);
        }
      }
      
      let blueCount = 0;
      // Fill from bottom row (row 74) upward
      for (let row = gridSize75 - 1; row >= 0 && blueCount < 5000; row--) {
        for (let col = 0; col < gridSize75 && blueCount < 5000; col++) {
          const idx = row * gridSize75 + col;
          // Skip dots in the black areas
          if (!blackIndices.has(idx)) {
            grid75Circles[idx].classList.remove(...COLOR_CLASSES);
            grid75Circles[idx].classList.add('blue');
            blueCount++;
          }
        }
      }
      speakNumber(5000);
      clickCount75 = 1;
    } else if (clickCount75 === 1) {
      // Second click: Fill 600 purple dots in the 20×30 rectangle
      const blackRectangle20x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x30Cols = [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69];
      
      for (let row of blackRectangle20x30Rows) {
        for (let col of blackRectangle20x30Cols) {
          const idx = row * gridSize75 + col;
          grid75Circles[idx].classList.remove(...COLOR_CLASSES);
          grid75Circles[idx].classList.add('purple');
        }
      }
      speakNumber(5600); // 5000 blue + 600 purple
      clickCount75 = 2;
    } else if (clickCount75 === 2) {
      // Third click: Fill 20 orange dots in the 5×5 square, leaving the top row black
      // Fill rows 1-4, all 5 columns (4 rows × 5 columns = 20 dots)
      const columnsToFill = [70, 71, 72, 73, 74]; // All 5 columns
      const rowsToFill = [1, 2, 3, 4]; // Rows 1-4 (leaving row 0 black)
      
      // Fill going down in columns
      for (let col of columnsToFill) {
        for (let row of rowsToFill) {
          const idx = row * gridSize75 + col;
          grid75Circles[idx].classList.remove(...COLOR_CLASSES);
          // Determine color based on digit - 20 = 2 (tens) = orange
          const colorFor20 = COLOR_MAP[2] || 'orange'; // 2 = orange
          grid75Circles[idx].classList.add(colorFor20);
        }
      }
      speakNumber(5620); // 5000 blue + 600 purple + 20 orange
      clickCount75 = 3;
    } else if (clickCount75 === 3) {
      // Fourth click: Fill the 5 black dots in the top row (row 0) with blue
      const topRow = 0;
      const columnsToFill = [70, 71, 72, 73, 74]; // All 5 columns in the 5×5 square
      
      for (let col of columnsToFill) {
        const idx = topRow * gridSize75 + col;
        grid75Circles[idx].classList.remove(...COLOR_CLASSES);
        grid75Circles[idx].classList.add('blue');
      }
      speakNumber(5625); // All 5625 dots filled
      clickCount75 = 4;
      
      // Show answer
      if (answerDisplay75) {
        answerDisplay75.textContent = '5625';
        answerDisplay75.classList.add('show');
      }
    } else {
      // Reset
      grid75Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange');
      });
      speakNumber(0);
      clickCount75 = 0;
      if (answerDisplay75) {
        answerDisplay75.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid75Section);
  
  // Create 76×76 grid (5776 dots) with special click behavior
  const grid76Section = document.createElement('section');
  grid76Section.className = 'set';
  grid76Section.style.marginBottom = '40px';
  grid76Section.id = 'square-5776';
  
  const h2_76 = document.createElement('h2');
  h2_76.textContent = '76²';
  grid76Section.appendChild(h2_76);
  
  const grid76 = document.createElement('div');
  grid76.className = 'grid-dynamic grid-5776';
  grid76.id = 'square-5776';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid76.style.gridTemplateColumns = 'repeat(76, calc(var(--circle-total) * 13 / 76))';
  grid76.style.gridTemplateRows = 'repeat(76, calc(var(--circle-total) * 13 / 76))';
  grid76.style.width = 'calc(var(--circle-total) * 13)';
  grid76.style.height = 'calc(var(--circle-total) * 13)';
  grid76.style.position = 'relative';
  
  const gridSize76 = 76;
  const totalDots76 = 5776;
  const grid76Circles = [];
  
  // Create all 5776 circles
  for (let i = 0; i < totalDots76; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-5776';
    grid76.appendChild(circle);
    grid76Circles.push(circle);
  }
  
  grid76Section.appendChild(grid76);
  
  // Add answer display
  const answerDisplay76 = document.createElement('div');
  answerDisplay76.className = 'answer-display';
  answerDisplay76.dataset.answer = '5776';
  grid76Section.appendChild(answerDisplay76);
  
  // Click handler for 76×76 grid
  let clickCount76 = 0;
  
  grid76.addEventListener('click', () => {
    if (clickCount76 === 0) {
      // First click: Fill 5000 blue dots from the bottom row upward, leaving:
      // - 35×20 rectangle: rows 0-19, cols 32-66 (700 dots) - all black, to the left of 9×9
      // - 9×9 square: rows 0-8, cols 67-75 (81 dots) in top right corner
      //   5 dots in bottom left of 9×9 (rows 6-8, cols 67-68, plus row 8, col 69 = 5 dots) are blue (part of 5000)
      //   Remaining: 81 - 5 = 76 black dots in 9×9
      // Total black: 700 + 76 = 776 dots
      const blackRectangle35x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle35x20Cols = [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66];
      const blackSquare9x9Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackSquare9x9Cols = [67, 68, 69, 70, 71, 72, 73, 74, 75];
      const blackIndices = new Set();
      
      // Add 35×20 rectangle indices (all black)
      for (let row of blackRectangle35x20Rows) {
        for (let col of blackRectangle35x20Cols) {
          blackIndices.add(row * gridSize76 + col);
        }
      }
      
      // Add 9×9 square indices
      for (let row of blackSquare9x9Rows) {
        for (let col of blackSquare9x9Cols) {
          blackIndices.add(row * gridSize76 + col);
        }
      }
      
      // Bottom left of 9×9 square: 5 dots should be blue (part of 5000)
      // Pattern: rows 6-7, cols 67-68 (4 dots) + row 8, col 68 (1 dot) = 5 dots total
      // Row 6, Col 68 (row 7 from top, col 8 from right) is black (not blue)
      // Row 8, Col 68 (row 9 from top) is blue
      const bottomLeft9x9Indices = [
        6 * gridSize76 + 67, // Row 6, Col 67
        7 * gridSize76 + 67, // Row 7, Col 67
        7 * gridSize76 + 68, // Row 7, Col 68
        8 * gridSize76 + 67, // Row 8, Col 67
        8 * gridSize76 + 68  // Row 8, Col 68 (row 9 from top) - blue
      ];
      // Row 6, Col 68 (row 7 from top, col 8 from right) stays in blackIndices (black)
      
      for (let idx of bottomLeft9x9Indices) {
        blackIndices.delete(idx); // Remove from black indices so they get filled with blue
      }
      
      let blueCount = 0;
      // Fill from bottom row (row 75) upward
      for (let row = gridSize76 - 1; row >= 0 && blueCount < 5000; row--) {
        for (let col = 0; col < gridSize76 && blueCount < 5000; col++) {
          const idx = row * gridSize76 + col;
          // Skip dots in the black areas (except the bottom left 5 dots of 9×9)
          if (!blackIndices.has(idx)) {
            grid76Circles[idx].classList.remove(...COLOR_CLASSES);
            grid76Circles[idx].classList.add('blue');
            blueCount++;
          }
        }
      }
      speakNumber(5000);
      clickCount76 = 1;
    } else if (clickCount76 === 1) {
      // Second click: Fill 700 brown dots in the 35×20 rectangle
      // Digit-based coloring: 700 = 7 (hundreds) = brown
      const blackRectangle35x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle35x20Cols = [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66];
      
      const colorFor700 = COLOR_MAP[7] || 'brown'; // 7 = brown
      for (let row of blackRectangle35x20Rows) {
        for (let col of blackRectangle35x20Cols) {
          const idx = row * gridSize76 + col;
          grid76Circles[idx].classList.remove(...COLOR_CLASSES);
          grid76Circles[idx].classList.add(colorFor700);
        }
      }
      speakNumber(5700); // 5000 blue + 700 brown
      clickCount76 = 2;
    } else if (clickCount76 === 2) {
      // Third click: Fill 70 brown dots in the 9×9 square, leaving 6 black dots
      // The 9×9 has 81 dots total, 5 are already blue, so 76 are black
      // Fill 70 with brown, leaving 6 black dots in column 67 (9th column from right)
      // Digit-based coloring: 70 = 7 (tens) = brown
      const blackSquare9x9Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackSquare9x9Cols = [67, 68, 69, 70, 71, 72, 73, 74, 75];
      
      // Dots that should remain black after third click (6 dots in column 67, rows 0-5)
      const remainingBlackIndices = new Set([
        0 * gridSize76 + 67, // Row 0, Col 67
        1 * gridSize76 + 67, // Row 1, Col 67
        2 * gridSize76 + 67, // Row 2, Col 67
        3 * gridSize76 + 67, // Row 3, Col 67
        4 * gridSize76 + 67, // Row 4, Col 67
        5 * gridSize76 + 67  // Row 5, Col 67
      ]);
      
      // Find all black dots in the 9×9 square (excluding blue dots and the ones that should remain black)
      const dotsToFill = [];
      for (let row of blackSquare9x9Rows) {
        for (let col of blackSquare9x9Cols) {
          const idx = row * gridSize76 + col;
          const circle = grid76Circles[idx];
          
          // Check if this dot is black (not blue) and not in the remaining black set
          if (!circle.classList.contains('blue') && !remainingBlackIndices.has(idx)) {
            dotsToFill.push(idx);
          }
        }
      }
      
      // Fill 70 dots with brown (should be exactly 70: 76 black - 6 remaining = 70)
      const colorFor70 = COLOR_MAP[7] || 'brown'; // 7 = brown
      for (let idx of dotsToFill) {
        grid76Circles[idx].classList.remove(...COLOR_CLASSES);
        grid76Circles[idx].classList.add(colorFor70);
      }
      speakNumber(5770); // 5000 blue + 700 brown + 70 brown
      clickCount76 = 3;
    } else if (clickCount76 === 3) {
      // Fourth click: Fill the remaining 6 black dots in column 67 (9th column from right) with purple
      // Column 67 is the 9th column from the right (counting col 75 as 1st from right)
      const purpleIndices = [
        0 * gridSize76 + 67, // Row 0, Col 67
        1 * gridSize76 + 67, // Row 1, Col 67
        2 * gridSize76 + 67, // Row 2, Col 67
        3 * gridSize76 + 67, // Row 3, Col 67
        4 * gridSize76 + 67, // Row 4, Col 67
        5 * gridSize76 + 67  // Row 5, Col 67
      ];
      
      for (let idx of purpleIndices) {
        grid76Circles[idx].classList.remove(...COLOR_CLASSES);
        grid76Circles[idx].classList.add('purple');
      }
      speakNumber(5776); // All 5776 dots filled
      clickCount76 = 4;
      
      // Show answer
      if (answerDisplay76) {
        answerDisplay76.textContent = '5776';
        answerDisplay76.classList.add('show');
      }
    } else {
      // Reset
      grid76Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown');
      });
      speakNumber(0);
      clickCount76 = 0;
      if (answerDisplay76) {
        answerDisplay76.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid76Section);
  
  // Create 77×77 grid (5929 dots) with special click behavior
  const grid77Section = document.createElement('section');
  grid77Section.className = 'set';
  grid77Section.style.marginBottom = '40px';
  grid77Section.id = 'square-5929';
  
  const h2_77 = document.createElement('h2');
  h2_77.textContent = '77²';
  grid77Section.appendChild(h2_77);
  
  const grid77 = document.createElement('div');
  grid77.className = 'grid-dynamic grid-5929';
  grid77.id = 'square-5929';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid77.style.gridTemplateColumns = 'repeat(77, calc(var(--circle-total) * 13 / 77))';
  grid77.style.gridTemplateRows = 'repeat(77, calc(var(--circle-total) * 13 / 77))';
  grid77.style.width = 'calc(var(--circle-total) * 13)';
  grid77.style.height = 'calc(var(--circle-total) * 13)';
  grid77.style.position = 'relative';
  
  const gridSize77 = 77;
  const totalDots77 = 5929;
  const grid77Circles = [];
  
  // Create all 5929 circles
  for (let i = 0; i < totalDots77; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-5929';
    grid77.appendChild(circle);
    grid77Circles.push(circle);
  }
  
  grid77Section.appendChild(grid77);
  
  // Add answer display
  const answerDisplay77 = document.createElement('div');
  answerDisplay77.className = 'answer-display';
  answerDisplay77.dataset.answer = '5929';
  grid77Section.appendChild(answerDisplay77);
  
  // Click handler for 77×77 grid
  let clickCount77 = 0;
  
  grid77.addEventListener('click', () => {
    if (clickCount77 === 0) {
      // First click: Fill 5000 blue dots from the bottom row upward, leaving:
      // - 3×3 square: rows 0-2, cols 74-76 (9 dots) in top right corner - black
      // - 5×4 rectangle: rows 0-3, cols 69-73 (20 dots) to the left of 3×3 - black
      // - 30×30 square: rows 0-29, cols 39-68 (900 dots) to the left of 5×4 - black
      // Total black: 9 + 20 + 900 = 929 dots
      const blackSquare3x3Rows = [0, 1, 2];
      const blackSquare3x3Cols = [74, 75, 76];
      const blackRectangle5x4Rows = [0, 1, 2, 3];
      const blackRectangle5x4Cols = [69, 70, 71, 72, 73];
      const blackSquare30x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29];
      const blackSquare30x30Cols = [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68];
      const blackIndices = new Set();
      
      // Add 3×3 square indices
      for (let row of blackSquare3x3Rows) {
        for (let col of blackSquare3x3Cols) {
          blackIndices.add(row * gridSize77 + col);
        }
      }
      
      // Add 5×4 rectangle indices
      for (let row of blackRectangle5x4Rows) {
        for (let col of blackRectangle5x4Cols) {
          blackIndices.add(row * gridSize77 + col);
        }
      }
      
      // Add 30×30 square indices
      for (let row of blackSquare30x30Rows) {
        for (let col of blackSquare30x30Cols) {
          blackIndices.add(row * gridSize77 + col);
        }
      }
      
      let blueCount = 0;
      // Fill from bottom row (row 76) upward
      for (let row = gridSize77 - 1; row >= 0 && blueCount < 5000; row--) {
        for (let col = 0; col < gridSize77 && blueCount < 5000; col++) {
          const idx = row * gridSize77 + col;
          // Skip dots in the black areas
          if (!blackIndices.has(idx)) {
            grid77Circles[idx].classList.remove(...COLOR_CLASSES);
            grid77Circles[idx].classList.add('blue');
            blueCount++;
          }
        }
      }
      speakNumber(5000);
      clickCount77 = 1;
    } else if (clickCount77 === 1) {
      // Second click: Fill the 30×30 square with sky blue
      const blackSquare30x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29];
      const blackSquare30x30Cols = [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68];
      
      for (let row of blackSquare30x30Rows) {
        for (let col of blackSquare30x30Cols) {
          const idx = row * gridSize77 + col;
          grid77Circles[idx].classList.remove(...COLOR_CLASSES);
          grid77Circles[idx].classList.add('sky');
        }
      }
      speakNumber(5900); // 5000 blue + 900 sky blue
      clickCount77 = 2;
    } else if (clickCount77 === 2) {
      // Third click: Fill the 5×4 rectangle with orange
      // Digit-based coloring: 20 = 2 (tens) = orange
      const blackRectangle5x4Rows = [0, 1, 2, 3];
      const blackRectangle5x4Cols = [69, 70, 71, 72, 73];
      
      const colorFor20 = COLOR_MAP[2] || 'orange'; // 2 = orange
      for (let row of blackRectangle5x4Rows) {
        for (let col of blackRectangle5x4Cols) {
          const idx = row * gridSize77 + col;
          grid77Circles[idx].classList.remove(...COLOR_CLASSES);
          grid77Circles[idx].classList.add(colorFor20);
        }
      }
      speakNumber(5920); // 5000 blue + 900 sky blue + 20 orange
      clickCount77 = 3;
    } else if (clickCount77 === 3) {
      // Fourth click: Fill the 3×3 square with sky blue
      const blackSquare3x3Rows = [0, 1, 2];
      const blackSquare3x3Cols = [74, 75, 76];
      
      for (let row of blackSquare3x3Rows) {
        for (let col of blackSquare3x3Cols) {
          const idx = row * gridSize77 + col;
          grid77Circles[idx].classList.remove(...COLOR_CLASSES);
          grid77Circles[idx].classList.add('sky');
        }
      }
      speakNumber(5929); // All 5929 dots filled
      clickCount77 = 4;
      
      // Show answer
      if (answerDisplay77) {
        answerDisplay77.textContent = '5929';
        answerDisplay77.classList.add('show');
      }
    } else {
      // Reset
      grid77Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown');
      });
      speakNumber(0);
      clickCount77 = 0;
      if (answerDisplay77) {
        answerDisplay77.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid77Section);
  
  // Create 78×78 grid (6084 dots) with special click behavior
  const grid78Section = document.createElement('section');
  grid78Section.className = 'set';
  grid78Section.style.marginBottom = '40px';
  grid78Section.id = 'square-6084';
  
  const h2_78 = document.createElement('h2');
  h2_78.textContent = '78²';
  grid78Section.appendChild(h2_78);
  
  const grid78 = document.createElement('div');
  grid78.className = 'grid-dynamic grid-6084';
  grid78.id = 'square-6084';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid78.style.gridTemplateColumns = 'repeat(78, calc(var(--circle-total) * 13 / 78))';
  grid78.style.gridTemplateRows = 'repeat(78, calc(var(--circle-total) * 13 / 78))';
  grid78.style.width = 'calc(var(--circle-total) * 13)';
  grid78.style.height = 'calc(var(--circle-total) * 13)';
  grid78.style.position = 'relative';
  
  const gridSize78 = 78;
  const totalDots78 = 6084;
  const grid78Circles = [];
  
  // Create all 6084 circles
  for (let i = 0; i < totalDots78; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-6084';
    grid78.appendChild(circle);
    grid78Circles.push(circle);
  }
  
  grid78Section.appendChild(grid78);
  
  // Add answer display
  const answerDisplay78 = document.createElement('div');
  answerDisplay78.className = 'answer-display';
  answerDisplay78.dataset.answer = '6084';
  grid78Section.appendChild(answerDisplay78);
  
  // Click handler for 78×78 grid
  let clickCount78 = 0;
  
  grid78.addEventListener('click', () => {
    if (clickCount78 === 0) {
      // First click: Fill 6000 purple dots from the bottom row upward, leaving:
      // - 12×7 rectangle: rows 0-6, cols 66-77 (84 dots) in top right corner - black
      const blackRectangle12x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle12x7Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77];
      const blackIndices = new Set();
      
      // Add 12×7 rectangle indices
      for (let row of blackRectangle12x7Rows) {
        for (let col of blackRectangle12x7Cols) {
          blackIndices.add(row * gridSize78 + col);
        }
      }
      
      let purpleCount = 0;
      // Fill from bottom row (row 77) upward
      for (let row = gridSize78 - 1; row >= 0 && purpleCount < 6000; row--) {
        for (let col = 0; col < gridSize78 && purpleCount < 6000; col++) {
          const idx = row * gridSize78 + col;
          // Skip dots in the black area
          if (!blackIndices.has(idx)) {
            grid78Circles[idx].classList.remove(...COLOR_CLASSES);
            grid78Circles[idx].classList.add('purple');
            purpleCount++;
          }
        }
      }
      speakNumber(6000);
      clickCount78 = 1;
    } else if (clickCount78 === 1) {
      // Second click: Fill 80 dots with pink, leaving a 2×2 rectangle (4 dots) in top right corner - black
      // Digit-based coloring: 80 = 8 (tens) = pink
      const blackRectangle12x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle12x7Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77];
      
      // 2×2 rectangle in top right corner: rows 0-1, cols 76-77 (4 dots) should remain black
      const remainingBlackIndices = new Set([
        0 * gridSize78 + 76, // Row 0, Col 76
        0 * gridSize78 + 77, // Row 0, Col 77
        1 * gridSize78 + 76, // Row 1, Col 76
        1 * gridSize78 + 77  // Row 1, Col 77
      ]);
      
      // Find all black dots in the 12×7 rectangle (excluding the ones that should remain black)
      const dotsToFill = [];
      for (let row of blackRectangle12x7Rows) {
        for (let col of blackRectangle12x7Cols) {
          const idx = row * gridSize78 + col;
          if (!remainingBlackIndices.has(idx)) {
            dotsToFill.push(idx);
          }
        }
      }
      
      // Fill 80 dots with pink (should be exactly 80: 84 total - 4 remaining = 80)
      const colorFor80 = COLOR_MAP[8] || 'pink'; // 8 = pink
      for (let idx of dotsToFill) {
        grid78Circles[idx].classList.remove(...COLOR_CLASSES);
        grid78Circles[idx].classList.add(colorFor80);
      }
      speakNumber(6080); // 6000 purple + 80 pink
      clickCount78 = 2;
    } else if (clickCount78 === 2) {
      // Third click: Fill the remaining 4 black dots in the 2×2 rectangle with green
      const greenIndices = [
        0 * gridSize78 + 76, // Row 0, Col 76
        0 * gridSize78 + 77, // Row 0, Col 77
        1 * gridSize78 + 76, // Row 1, Col 76
        1 * gridSize78 + 77  // Row 1, Col 77
      ];
      
      for (let idx of greenIndices) {
        grid78Circles[idx].classList.remove(...COLOR_CLASSES);
        grid78Circles[idx].classList.add('green');
      }
      speakNumber(6084); // All 6084 dots filled
      clickCount78 = 3;
      
      // Show answer
      if (answerDisplay78) {
        answerDisplay78.textContent = '6084';
        answerDisplay78.classList.add('show');
      }
    } else {
      // Reset
      grid78Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink');
      });
      speakNumber(0);
      clickCount78 = 0;
      if (answerDisplay78) {
        answerDisplay78.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid78Section);
  
  // Create 79×79 grid (6241 dots) with special click behavior
  const grid79Section = document.createElement('section');
  grid79Section.className = 'set';
  grid79Section.style.marginBottom = '40px';
  grid79Section.id = 'square-6241';
  
  const h2_79 = document.createElement('h2');
  h2_79.textContent = '79²';
  grid79Section.appendChild(h2_79);
  
  const grid79 = document.createElement('div');
  grid79.className = 'grid-dynamic grid-6241';
  grid79.id = 'square-6241';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid79.style.gridTemplateColumns = 'repeat(79, calc(var(--circle-total) * 13 / 79))';
  grid79.style.gridTemplateRows = 'repeat(79, calc(var(--circle-total) * 13 / 79))';
  grid79.style.width = 'calc(var(--circle-total) * 13)';
  grid79.style.height = 'calc(var(--circle-total) * 13)';
  grid79.style.position = 'relative';
  
  const gridSize79 = 79;
  const totalDots79 = 6241;
  const grid79Circles = [];
  
  // Create all 6241 circles
  for (let i = 0; i < totalDots79; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-6241';
    grid79.appendChild(circle);
    grid79Circles.push(circle);
  }
  
  grid79Section.appendChild(grid79);
  
  // Add answer display
  const answerDisplay79 = document.createElement('div');
  answerDisplay79.className = 'answer-display';
  answerDisplay79.dataset.answer = '6241';
  grid79Section.appendChild(answerDisplay79);
  
  // Click handler for 79×79 grid
  let clickCount79 = 0;
  
  grid79.addEventListener('click', () => {
    if (clickCount79 === 0) {
      // First click: Fill 6000 purple dots from the bottom row upward, leaving:
      // - 7×6 rectangle: rows 0-5, cols 72-78 (42 dots) in top right corner - black
      //   Except: bottom left corner (row 5, col 72) turns purple (part of 6000)
      // - 20×10 rectangle: rows 0-9, cols 52-71 (200 dots) - black, right next to 7×6
      const blackRectangle7x6Rows = [0, 1, 2, 3, 4, 5];
      const blackRectangle7x6Cols = [72, 73, 74, 75, 76, 77, 78];
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle20x10Cols = [52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71];
      const blackIndices = new Set();
      
      // Add 7×6 rectangle indices
      for (let row of blackRectangle7x6Rows) {
        for (let col of blackRectangle7x6Cols) {
          blackIndices.add(row * gridSize79 + col);
        }
      }
      
      // Add 20×10 rectangle indices
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          blackIndices.add(row * gridSize79 + col);
        }
      }
      
      // Bottom left corner of 7×6 rectangle (row 5, col 72) should be purple (part of 6000)
      const bottomLeft7x6Idx = 5 * gridSize79 + 72;
      blackIndices.delete(bottomLeft7x6Idx); // Remove from black indices so it gets filled with purple
      
      let purpleCount = 0;
      // Fill from bottom row (row 78) upward
      for (let row = gridSize79 - 1; row >= 0 && purpleCount < 6000; row--) {
        for (let col = 0; col < gridSize79 && purpleCount < 6000; col++) {
          const idx = row * gridSize79 + col;
          // Skip dots in the black areas (except the bottom left of 7×6)
          if (!blackIndices.has(idx)) {
            grid79Circles[idx].classList.remove(...COLOR_CLASSES);
            grid79Circles[idx].classList.add('purple');
            purpleCount++;
          }
        }
      }
      speakNumber(6000);
      clickCount79 = 1;
    } else if (clickCount79 === 1) {
      // Second click: Fill the 20×10 rectangle with orange
      // Digit-based coloring: 200 = 2 (hundreds) = orange
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const blackRectangle20x10Cols = [52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71];
      
      const colorFor200 = COLOR_MAP[2] || 'orange'; // 2 = orange
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          const idx = row * gridSize79 + col;
          grid79Circles[idx].classList.remove(...COLOR_CLASSES);
          grid79Circles[idx].classList.add(colorFor200);
        }
      }
      speakNumber(6200); // 6000 purple + 200 orange
      clickCount79 = 2;
    } else if (clickCount79 === 2) {
      // Third click: Fill 40 dots in the 7×6 grid with green, except top right corner remains black
      // Top right corner of 7×6: row 0, col 78 (1 dot) should remain black
      const blackRectangle7x6Rows = [0, 1, 2, 3, 4, 5];
      const blackRectangle7x6Cols = [72, 73, 74, 75, 76, 77, 78];
      
      // Top right corner (row 0, col 78) should remain black
      const remainingBlackIndex = 0 * gridSize79 + 78;
      
      // Find all black dots in the 7×6 rectangle (excluding the one that should remain black)
      const dotsToFill = [];
      for (let row of blackRectangle7x6Rows) {
        for (let col of blackRectangle7x6Cols) {
          const idx = row * gridSize79 + col;
          const circle = grid79Circles[idx];
          
          // Check if this dot is black and not the top right corner
          if (!circle.classList.contains('purple') && idx !== remainingBlackIndex) {
            dotsToFill.push(idx);
          }
        }
      }
      
      // Fill 40 dots with green (should be exactly 40: 41 black - 1 remaining = 40)
      for (let idx of dotsToFill) {
        grid79Circles[idx].classList.remove(...COLOR_CLASSES);
        grid79Circles[idx].classList.add('green');
      }
      speakNumber(6240); // 6000 purple + 200 orange + 40 green
      clickCount79 = 3;
    } else if (clickCount79 === 3) {
      // Fourth click: Fill the top right corner (row 0, col 78) with red
      const redIndex = 0 * gridSize79 + 78;
      
      grid79Circles[redIndex].classList.remove(...COLOR_CLASSES);
      grid79Circles[redIndex].classList.add('red');
      speakNumber(6241); // All 6241 dots filled
      clickCount79 = 4;
      
      // Show answer
      if (answerDisplay79) {
        answerDisplay79.textContent = '6241';
        answerDisplay79.classList.add('show');
      }
    } else {
      // Reset
      grid79Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red');
      });
      speakNumber(0);
      clickCount79 = 0;
      if (answerDisplay79) {
        answerDisplay79.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid79Section);
  
  // Create 80×80 grid (6400 dots) with special click behavior
  const grid80Section = document.createElement('section');
  grid80Section.className = 'set';
  grid80Section.style.marginBottom = '40px';
  grid80Section.id = 'square-6400';
  
  const h2_80 = document.createElement('h2');
  h2_80.textContent = '80²';
  grid80Section.appendChild(h2_80);
  
  const grid80 = document.createElement('div');
  grid80.className = 'grid-dynamic grid-6400';
  grid80.id = 'square-6400';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid80.style.gridTemplateColumns = 'repeat(80, calc(var(--circle-total) * 13 / 80))';
  grid80.style.gridTemplateRows = 'repeat(80, calc(var(--circle-total) * 13 / 80))';
  grid80.style.width = 'calc(var(--circle-total) * 13)';
  grid80.style.height = 'calc(var(--circle-total) * 13)';
  grid80.style.position = 'relative';
  
  const gridSize80 = 80;
  const totalDots80 = 6400;
  const grid80Circles = [];
  
  // Create all 6400 circles
  for (let i = 0; i < totalDots80; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-6400';
    grid80.appendChild(circle);
    grid80Circles.push(circle);
  }
  
  grid80Section.appendChild(grid80);
  
  // Add answer display
  const answerDisplay80 = document.createElement('div');
  answerDisplay80.className = 'answer-display';
  answerDisplay80.dataset.answer = '6400';
  grid80Section.appendChild(answerDisplay80);
  
  // Click handler for 80×80 grid
  let clickCount80 = 0;
  
  grid80.addEventListener('click', () => {
    if (clickCount80 === 0) {
      // First click: Fill 6000 purple dots from the bottom row upward, leaving:
      // - 20×20 square: rows 0-19, cols 60-79 (400 dots) in top right corner - black
      const blackSquare20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackSquare20x20Cols = [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
      const blackIndices = new Set();
      
      // Add 20×20 square indices
      for (let row of blackSquare20x20Rows) {
        for (let col of blackSquare20x20Cols) {
          blackIndices.add(row * gridSize80 + col);
        }
      }
      
      let purpleCount = 0;
      // Fill from bottom row (row 79) upward
      for (let row = gridSize80 - 1; row >= 0 && purpleCount < 6000; row--) {
        for (let col = 0; col < gridSize80 && purpleCount < 6000; col++) {
          const idx = row * gridSize80 + col;
          // Skip dots in the black area
          if (!blackIndices.has(idx)) {
            grid80Circles[idx].classList.remove(...COLOR_CLASSES);
            grid80Circles[idx].classList.add('purple');
            purpleCount++;
          }
        }
      }
      speakNumber(6000);
      clickCount80 = 1;
    } else if (clickCount80 === 1) {
      // Second click: Fill the 20×20 square with 400 green dots
      // Digit-based coloring: 400 = 4 (hundreds) = green
      const blackSquare20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackSquare20x20Cols = [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
      
      const colorFor400 = COLOR_MAP[4] || 'green'; // 4 = green
      for (let row of blackSquare20x20Rows) {
        for (let col of blackSquare20x20Cols) {
          const idx = row * gridSize80 + col;
          grid80Circles[idx].classList.remove(...COLOR_CLASSES);
          grid80Circles[idx].classList.add(colorFor400);
        }
      }
      speakNumber(6400); // All 6400 dots filled
      clickCount80 = 2;
      
      // Show answer
      if (answerDisplay80) {
        answerDisplay80.textContent = '6400';
        answerDisplay80.classList.add('show');
      }
    } else {
      // Reset
      grid80Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red');
      });
      speakNumber(0);
      clickCount80 = 0;
      if (answerDisplay80) {
        answerDisplay80.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid80Section);
  
  // Create 81×81 grid (6561 dots) with special click behavior
  const grid81Section = document.createElement('section');
  grid81Section.className = 'set';
  grid81Section.style.marginBottom = '40px';
  grid81Section.id = 'square-6561';
  
  const h2_81 = document.createElement('h2');
  h2_81.textContent = '81²';
  grid81Section.appendChild(h2_81);
  
  const grid81 = document.createElement('div');
  grid81.className = 'grid-dynamic grid-6561';
  grid81.id = 'square-6561';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid81.style.gridTemplateColumns = 'repeat(81, calc(var(--circle-total) * 13 / 81))';
  grid81.style.gridTemplateRows = 'repeat(81, calc(var(--circle-total) * 13 / 81))';
  grid81.style.width = 'calc(var(--circle-total) * 13)';
  grid81.style.height = 'calc(var(--circle-total) * 13)';
  grid81.style.position = 'relative';
  
  const gridSize81 = 81;
  const totalDots81 = 6561;
  const grid81Circles = [];
  
  // Create all 6561 circles
  for (let i = 0; i < totalDots81; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-6561';
    grid81.appendChild(circle);
    grid81Circles.push(circle);
  }
  
  grid81Section.appendChild(grid81);
  
  // Add answer display
  const answerDisplay81 = document.createElement('div');
  answerDisplay81.className = 'answer-display';
  answerDisplay81.dataset.answer = '6561';
  grid81Section.appendChild(answerDisplay81);
  
  // Click handler for 81×81 grid
  let clickCount81 = 0;
  
  grid81.addEventListener('click', () => {
    if (clickCount81 === 0) {
      // First click: Fill 6000 purple dots from the bottom row upward, leaving:
      // - 8×8 rectangle: rows 0-7, cols 73-80 (64 dots) in top right corner - black
      //   Except: 3 dots in bottom left (rows 5-7, cols 73-75) turn purple (part of 6000)
      // - 25×20 rectangle: rows 0-19, cols 48-72 (500 dots) - black, right next to 8×8
      const blackSquare8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackSquare8x8Cols = [73, 74, 75, 76, 77, 78, 79, 80];
      const blackRectangle25x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle25x20Cols = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72];
      const blackIndices = new Set();
      
      // Add 8×8 rectangle indices
      for (let row of blackSquare8x8Rows) {
        for (let col of blackSquare8x8Cols) {
          blackIndices.add(row * gridSize81 + col);
        }
      }
      
      // Add 25×20 rectangle indices
      for (let row of blackRectangle25x20Rows) {
        for (let col of blackRectangle25x20Cols) {
          blackIndices.add(row * gridSize81 + col);
        }
      }
      
      // Bottom left of 8×8 rectangle (rows 5-7, cols 73-75, 3 dots) should be purple (part of 6000)
      const bottomLeft8x8Indices = [
        5 * gridSize81 + 73, // Row 5, Col 73
        5 * gridSize81 + 74, // Row 5, Col 74
        6 * gridSize81 + 73, // Row 6, Col 73
        6 * gridSize81 + 74, // Row 6, Col 74
        7 * gridSize81 + 73, // Row 7, Col 73
        7 * gridSize81 + 74  // Row 7, Col 74
      ];
      // Actually, let me recalculate: bottom left of 8×8 would be rows 5-7, cols 73-75 = 3×3 = 9 dots
      // But user said 3 dots, so maybe rows 6-7, cols 73-74 = 2×2 = 4 dots, or rows 5-7, col 73 = 3 dots
      // Let me use rows 5-7, col 73 = 3 dots
      const bottomLeft8x8IndicesCorrect = [
        5 * gridSize81 + 73, // Row 5, Col 73
        6 * gridSize81 + 73, // Row 6, Col 73
        7 * gridSize81 + 73  // Row 7, Col 73
      ];
      
      for (let idx of bottomLeft8x8IndicesCorrect) {
        blackIndices.delete(idx); // Remove from black indices so they get filled with purple
      }
      
      let purpleCount = 0;
      // Fill from bottom row (row 80) upward
      for (let row = gridSize81 - 1; row >= 0 && purpleCount < 6000; row--) {
        for (let col = 0; col < gridSize81 && purpleCount < 6000; col++) {
          const idx = row * gridSize81 + col;
          // Skip dots in the black areas (except the bottom left 3 dots of 8×8)
          if (!blackIndices.has(idx)) {
            grid81Circles[idx].classList.remove(...COLOR_CLASSES);
            grid81Circles[idx].classList.add('purple');
            purpleCount++;
          }
        }
      }
      speakNumber(6000);
      clickCount81 = 1;
    } else if (clickCount81 === 1) {
      // Second click: Fill the 25×20 rectangle with blue (500 dots)
      // Digit-based coloring: 500 = 5 (hundreds) = blue
      const blackRectangle25x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle25x20Cols = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72];
      
      const colorFor500 = COLOR_MAP[5] || 'blue'; // 5 = blue
      for (let row of blackRectangle25x20Rows) {
        for (let col of blackRectangle25x20Cols) {
          const idx = row * gridSize81 + col;
          grid81Circles[idx].classList.remove(...COLOR_CLASSES);
          grid81Circles[idx].classList.add(colorFor500);
        }
      }
      speakNumber(6500); // 6000 purple + 500 blue
      clickCount81 = 2;
    } else if (clickCount81 === 2) {
      // Third click: Fill 60 dots in the 8×8 grid with purple, leaving 1 black dot in top right corner
      // All 61 black dots move up by one dot distance (like 441's 41 dots movement)
      // Top right corner of 8×8: row 0, col 80 should remain black
      const blackSquare8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const blackSquare8x8Cols = [73, 74, 75, 76, 77, 78, 79, 80];
      
      // Top right corner (row 0, col 80) should remain black
      const remainingBlackIndex = 0 * gridSize81 + 80;
      
      // Find all 61 black dots in the 8×8 rectangle (excluding purple dots)
      const blackDots = [];
      for (let row of blackSquare8x8Rows) {
        for (let col of blackSquare8x8Cols) {
          const idx = row * gridSize81 + col;
          const circle = grid81Circles[idx];
          
          // Check if this dot is black (not purple)
          if (!circle.classList.contains('purple')) {
            blackDots.push({ row: row, col: col, idx: idx });
          }
        }
      }
      
      // Move all 61 dots up by one dot distance (like 441's 41 dots)
      // Hide original circles and create separated circles positioned one dot up
      const separatedCircles = [];
      let topRightSeparatedCircle = null; // Store reference to top right corner separated circle
      
      for (let dot of blackDots) {
        const circle = grid81Circles[dot.idx];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Create a new separated circle positioned one dot up
        const separatedCircle = document.createElement('div');
        separatedCircle.className = 'circle'; // Start black
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = dot.row;
        separatedCircle.dataset.originalCol = dot.col;
        separatedCircle.dataset.originalIdx = dot.idx; // Store original index for easy lookup
        
        // Copy size classes
        circle.classList.forEach(cls => {
          if (cls.startsWith('circle-')) {
            separatedCircle.classList.add(cls);
          }
        });
        
        // Move up by 1 dot distance and slightly to the right (diagonal movement like 441's 41 dots)
        // UP: negative top value = row - 1 (move up by exactly 1 dot distance)
        // RIGHT: positive left value = col + small offset (move right slightly)
        // Use scaled circle size variable for 81×81 grid
        separatedCircle.style.left = `calc(var(--circle-total-6561) * ${dot.col} + 0.3 * var(--circle-total-6561))`;
        separatedCircle.style.top = `calc(var(--circle-total-6561) * ${dot.row} - 1 * var(--circle-total-6561))`;
        separatedCircle.style.transform = 'none';
        separatedCircle.style.margin = '0';
        separatedCircle.style.padding = '0';
        
        // Add to grid container
        grid81.appendChild(separatedCircle);
        separatedCircles.push({ circle: separatedCircle, idx: dot.idx });
        
        // Store reference to top right corner separated circle
        if (dot.idx === remainingBlackIndex) {
          topRightSeparatedCircle = separatedCircle;
        }
      }
      
      // Fill 60 dots with purple (all except the top right corner)
      for (let i = 0; i < separatedCircles.length; i++) {
        const { circle: separatedCircle, idx } = separatedCircles[i];
        if (idx !== remainingBlackIndex) {
          // Fill with purple (60 dots)
          separatedCircle.classList.remove(...COLOR_CLASSES);
          separatedCircle.classList.add('purple');
        }
        // Top right corner (idx === remainingBlackIndex) stays black
      }
      
      // Store reference to top right separated circle for 4th click
      grid81.dataset.topRightSeparatedCircle = topRightSeparatedCircle ? 'true' : 'false';
      if (topRightSeparatedCircle) {
        topRightSeparatedCircle.dataset.isTopRight = 'true';
      }
      
      speakNumber(6560); // 6000 purple + 500 blue + 60 purple
      clickCount81 = 3;
    } else if (clickCount81 === 3) {
      // Fourth click: Fill the top right corner separated circle (row 0, col 80) with red
      // Find the separated circle that corresponds to the top right corner
      const topRightSeparatedCircle = grid81.querySelector('[data-original-row="0"][data-original-col="80"]');
      
      if (topRightSeparatedCircle) {
        topRightSeparatedCircle.classList.remove(...COLOR_CLASSES);
        topRightSeparatedCircle.classList.add('red');
      }
      speakNumber(6561); // All 6561 dots filled
      clickCount81 = 4;
      
      // Show answer
      if (answerDisplay81) {
        answerDisplay81.textContent = '6561';
        answerDisplay81.classList.add('show');
      }
    } else {
      // Reset
      grid81Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red');
      });
      speakNumber(0);
      clickCount81 = 0;
      if (answerDisplay81) {
        answerDisplay81.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid81Section);
  
  // Create 82×82 grid (6724 dots) with special click behavior
  const grid82Section = document.createElement('section');
  grid82Section.className = 'set';
  grid82Section.style.marginBottom = '40px';
  grid82Section.id = 'square-6724';
  
  const h2_82 = document.createElement('h2');
  h2_82.textContent = '82²';
  grid82Section.appendChild(h2_82);
  
  const grid82 = document.createElement('div');
  grid82.className = 'grid-dynamic grid-6724';
  grid82.id = 'square-6724';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid82.style.gridTemplateColumns = 'repeat(82, calc(var(--circle-total) * 13 / 82))';
  grid82.style.gridTemplateRows = 'repeat(82, calc(var(--circle-total) * 13 / 82))';
  grid82.style.width = 'calc(var(--circle-total) * 13)';
  grid82.style.height = 'calc(var(--circle-total) * 13)';
  grid82.style.position = 'relative';
  
  const gridSize82 = 82;
  const totalDots82 = 6724;
  const grid82Circles = [];
  
  // Create all 6724 circles
  for (let i = 0; i < totalDots82; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-6724';
    grid82.appendChild(circle);
    grid82Circles.push(circle);
  }
  
  grid82Section.appendChild(grid82);
  
  // Add answer display
  const answerDisplay82 = document.createElement('div');
  answerDisplay82.className = 'answer-display';
  answerDisplay82.dataset.answer = '6724';
  grid82Section.appendChild(answerDisplay82);
  
  // Click handler for 82×82 grid
  let clickCount82 = 0;
  
  grid82.addEventListener('click', () => {
    if (clickCount82 === 0) {
      // First click: Fill 6000 purple dots from the bottom row upward, leaving:
      // - 6×4 rectangle: rows 0-3, cols 76-81 (24 dots) in top right corner - black
      // - 20×35 rectangle: rows 0-19, cols 41-75 (700 dots) - black, right next to 6×4
      const blackRectangle6x4Rows = [0, 1, 2, 3];
      const blackRectangle6x4Cols = [76, 77, 78, 79, 80, 81];
      const blackRectangle20x35Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x35Cols = [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75];
      const blackIndices = new Set();
      
      // Add 6×4 rectangle indices
      for (let row of blackRectangle6x4Rows) {
        for (let col of blackRectangle6x4Cols) {
          blackIndices.add(row * gridSize82 + col);
        }
      }
      
      // Add 20×35 rectangle indices
      for (let row of blackRectangle20x35Rows) {
        for (let col of blackRectangle20x35Cols) {
          blackIndices.add(row * gridSize82 + col);
        }
      }
      
      let purpleCount = 0;
      // Fill from bottom row (row 81) upward
      for (let row = gridSize82 - 1; row >= 0 && purpleCount < 6000; row--) {
        for (let col = 0; col < gridSize82 && purpleCount < 6000; col++) {
          const idx = row * gridSize82 + col;
          // Skip dots in the black areas
          if (!blackIndices.has(idx)) {
            grid82Circles[idx].classList.remove(...COLOR_CLASSES);
            grid82Circles[idx].classList.add('purple');
            purpleCount++;
          }
        }
      }
      speakNumber(6000);
      clickCount82 = 1;
    } else if (clickCount82 === 1) {
      // Second click: Fill the 20×35 rectangle with 700 brown dots
      // Digit-based coloring: 700 = 7 (hundreds) = brown
      const blackRectangle20x35Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x35Cols = [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75];
      
      const colorFor700 = COLOR_MAP[7] || 'brown'; // 7 = brown
      for (let row of blackRectangle20x35Rows) {
        for (let col of blackRectangle20x35Cols) {
          const idx = row * gridSize82 + col;
          grid82Circles[idx].classList.remove(...COLOR_CLASSES);
          grid82Circles[idx].classList.add(colorFor700);
        }
      }
      speakNumber(6700); // 6000 purple + 700 brown
      clickCount82 = 2;
    } else if (clickCount82 === 2) {
      // Third click: Fill 20 dots in the 6×4 rectangle with orange, leaving a 2×2 square (4 dots) in top right corner - black
      // Digit-based coloring: 20 = 2 (tens) = orange
      const blackRectangle6x4Rows = [0, 1, 2, 3];
      const blackRectangle6x4Cols = [76, 77, 78, 79, 80, 81];
      
      // 2×2 square in top right corner: rows 0-1, cols 80-81 (4 dots) should remain black
      const remainingBlackIndices = new Set([
        0 * gridSize82 + 80, // Row 0, Col 80
        0 * gridSize82 + 81, // Row 0, Col 81
        1 * gridSize82 + 80, // Row 1, Col 80
        1 * gridSize82 + 81  // Row 1, Col 81
      ]);
      
      // Find all black dots in the 6×4 rectangle (excluding the ones that should remain black)
      const dotsToFill = [];
      for (let row of blackRectangle6x4Rows) {
        for (let col of blackRectangle6x4Cols) {
          const idx = row * gridSize82 + col;
          if (!remainingBlackIndices.has(idx)) {
            dotsToFill.push(idx);
          }
        }
      }
      
      // Fill 20 dots with orange (should be exactly 20: 24 total - 4 remaining = 20)
      const colorFor20 = COLOR_MAP[2] || 'orange'; // 2 = orange
      for (let idx of dotsToFill) {
        grid82Circles[idx].classList.remove(...COLOR_CLASSES);
        grid82Circles[idx].classList.add(colorFor20);
      }
      speakNumber(6720); // 6000 purple + 700 brown + 20 orange
      clickCount82 = 3;
    } else if (clickCount82 === 3) {
      // Fourth click: Fill the last 4 black dots (2×2 square) with green
      const greenIndices = [
        0 * gridSize82 + 80, // Row 0, Col 80
        0 * gridSize82 + 81, // Row 0, Col 81
        1 * gridSize82 + 80, // Row 1, Col 80
        1 * gridSize82 + 81  // Row 1, Col 81
      ];
      
      for (let idx of greenIndices) {
        grid82Circles[idx].classList.remove(...COLOR_CLASSES);
        grid82Circles[idx].classList.add('green');
      }
      speakNumber(6724); // All 6724 dots filled
      clickCount82 = 4;
      
      // Show answer
      if (answerDisplay82) {
        answerDisplay82.textContent = '6724';
        answerDisplay82.classList.add('show');
      }
    } else {
      // Reset
      grid82Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red');
      });
      speakNumber(0);
      clickCount82 = 0;
      if (answerDisplay82) {
        answerDisplay82.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid82Section);
  
  // Create 83×83 grid (6889 dots) with special click behavior
  const grid83Section = document.createElement('section');
  grid83Section.className = 'set';
  grid83Section.style.marginBottom = '40px';
  grid83Section.id = 'square-6889';
  
  const h2_83 = document.createElement('h2');
  h2_83.textContent = '83²';
  grid83Section.appendChild(h2_83);
  
  const grid83 = document.createElement('div');
  grid83.className = 'grid-dynamic grid-6889';
  grid83.id = 'square-6889';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid83.style.gridTemplateColumns = 'repeat(83, calc(var(--circle-total) * 13 / 83))';
  grid83.style.gridTemplateRows = 'repeat(83, calc(var(--circle-total) * 13 / 83))';
  grid83.style.width = 'calc(var(--circle-total) * 13)';
  grid83.style.height = 'calc(var(--circle-total) * 13)';
  grid83.style.position = 'relative';
  
  const gridSize83 = 83;
  const totalDots83 = 6889;
  const grid83Circles = [];
  
  // Create all 6889 circles
  for (let i = 0; i < totalDots83; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-6889';
    grid83.appendChild(circle);
    grid83Circles.push(circle);
  }
  
  grid83Section.appendChild(grid83);
  
  // Add answer display
  const answerDisplay83 = document.createElement('div');
  answerDisplay83.className = 'answer-display';
  answerDisplay83.dataset.answer = '6889';
  grid83Section.appendChild(answerDisplay83);
  
  // Click handler for 83×83 grid
  let clickCount83 = 0;
  
  grid83.addEventListener('click', () => {
    if (clickCount83 === 0) {
      // First click: Fill 6000 purple dots from the bottom row upward, leaving:
      // - 9×10 rectangle: rows 0-8, cols 74-83 (9 rows × 10 cols = 90 dots) in top right corner - black
      //   Except: bottom left corner (row 8, col 74) turns purple (part of 6000)
      // - 40×20 rectangle: rows 0-19, cols 34-73 (800 dots) - black, right next to 9×10
      const blackRectangle9x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackRectangle9x10Cols = [74, 75, 76, 77, 78, 79, 80, 81, 82, 83];
      const blackRectangle40x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle40x20Cols = [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73];
      const blackIndices = new Set();
      
      // Add 9×10 rectangle indices (9 rows × 10 cols = 90 dots, but user said "10-1" so maybe 9×9?)
      // Actually, user said "9 by 10-1" which could mean 9×9 = 81, but they also said 89 dots remain
      // Let me use 9×10 = 90 dots total, minus 1 purple = 89 black
      for (let row of blackRectangle9x10Rows) {
        for (let col of blackRectangle9x10Cols) {
          blackIndices.add(row * gridSize83 + col);
        }
      }
      
      // Add 40×20 rectangle indices
      for (let row of blackRectangle40x20Rows) {
        for (let col of blackRectangle40x20Cols) {
          blackIndices.add(row * gridSize83 + col);
        }
      }
      
      // Bottom left corner of 9×10 rectangle (row 8, col 74) should be purple (part of 6000)
      const bottomLeft9x10Idx = 8 * gridSize83 + 74;
      blackIndices.delete(bottomLeft9x10Idx); // Remove from black indices so it gets filled with purple
      
      let purpleCount = 0;
      // Fill from bottom row (row 82) upward
      for (let row = gridSize83 - 1; row >= 0 && purpleCount < 6000; row--) {
        for (let col = 0; col < gridSize83 && purpleCount < 6000; col++) {
          const idx = row * gridSize83 + col;
          // Skip dots in the black areas (except the bottom left of 9×10)
          if (!blackIndices.has(idx)) {
            grid83Circles[idx].classList.remove(...COLOR_CLASSES);
            grid83Circles[idx].classList.add('purple');
            purpleCount++;
          }
        }
      }
      speakNumber(6000);
      clickCount83 = 1;
    } else if (clickCount83 === 1) {
      // Second click: Fill the 40×20 rectangle with pink (800 dots)
      // Digit-based coloring: 800 = 8 (hundreds) = pink
      const blackRectangle40x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle40x20Cols = [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73];
      
      const colorFor800 = COLOR_MAP[8] || 'pink'; // 8 = pink
      for (let row of blackRectangle40x20Rows) {
        for (let col of blackRectangle40x20Cols) {
          const idx = row * gridSize83 + col;
          grid83Circles[idx].classList.remove(...COLOR_CLASSES);
          grid83Circles[idx].classList.add(colorFor800);
        }
      }
      speakNumber(6800); // 6000 purple + 800 pink
      clickCount83 = 2;
    } else if (clickCount83 === 2) {
      // Third click: The 89 dots that aren't colored will move to the right (like 81×81 movement)
      // Fill 80 with pink, leaving a 3×3 square (9 dots) in top right corner - black
      const blackRectangle9x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const blackRectangle9x10Cols = [74, 75, 76, 77, 78, 79, 80, 81, 82, 83];
      
      // 3×3 square in top right corner: rows 0-2, cols 80-82 (9 dots) should remain black
      const remainingBlackIndices = new Set([
        0 * gridSize83 + 80, // Row 0, Col 80
        0 * gridSize83 + 81, // Row 0, Col 81
        0 * gridSize83 + 82, // Row 0, Col 82
        1 * gridSize83 + 80, // Row 1, Col 80
        1 * gridSize83 + 81, // Row 1, Col 81
        1 * gridSize83 + 82, // Row 1, Col 82
        2 * gridSize83 + 80, // Row 2, Col 80
        2 * gridSize83 + 81, // Row 2, Col 81
        2 * gridSize83 + 82  // Row 2, Col 82
      ]);
      
      // Find all black dots in the 9×10 rectangle (excluding purple dots)
      const blackDots = [];
      for (let row of blackRectangle9x10Rows) {
        for (let col of blackRectangle9x10Cols) {
          const idx = row * gridSize83 + col;
          const circle = grid83Circles[idx];
          
          // Check if this dot is black (not purple)
          if (!circle.classList.contains('purple')) {
            blackDots.push({ row: row, col: col, idx: idx });
          }
        }
      }
      
      // Move all 89 dots to the right (like 81×81 movement)
      // Hide original circles and create separated circles positioned to the right
      const separatedCircles = [];
      for (let dot of blackDots) {
        const circle = grid83Circles[dot.idx];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Create a new separated circle positioned to the right
        const separatedCircle = document.createElement('div');
        separatedCircle.className = 'circle'; // Start black
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = dot.row;
        separatedCircle.dataset.originalCol = dot.col;
        separatedCircle.dataset.originalIdx = dot.idx;
        
        // Copy size classes
        circle.classList.forEach(cls => {
          if (cls.startsWith('circle-')) {
            separatedCircle.classList.add(cls);
          }
        });
        
        // Move to the right only (twice as far as before, no up movement)
        // Move right by 0.6 dot diameters (double the previous 0.3)
        // Use scaled circle size variable for 83×83 grid
        separatedCircle.style.left = `calc(var(--circle-total-6889) * ${dot.col} + 0.6 * var(--circle-total-6889))`;
        separatedCircle.style.top = `calc(var(--circle-total-6889) * ${dot.row})`; // No vertical movement
        separatedCircle.style.transform = 'none';
        separatedCircle.style.margin = '0';
        separatedCircle.style.padding = '0';
        
        // Add to grid container
        grid83.appendChild(separatedCircle);
        separatedCircles.push({ circle: separatedCircle, idx: dot.idx });
      }
      
      // Fill 80 dots with pink (all except the 3×3 square in top right)
      for (let i = 0; i < separatedCircles.length; i++) {
        const { circle: separatedCircle, idx } = separatedCircles[i];
        if (!remainingBlackIndices.has(idx)) {
          // Fill with pink (80 dots)
          separatedCircle.classList.remove(...COLOR_CLASSES);
          separatedCircle.classList.add('pink');
        }
        // 3×3 square (9 dots) stays black
      }
      
      speakNumber(6880); // 6000 purple + 800 pink + 80 pink
      clickCount83 = 3;
    } else if (clickCount83 === 3) {
      // Fourth click: Fill the 9 dots (3×3 square) in top right corner with sky blue
      const skyBlueIndices = [
        0 * gridSize83 + 80, // Row 0, Col 80
        0 * gridSize83 + 81, // Row 0, Col 81
        0 * gridSize83 + 82, // Row 0, Col 82
        1 * gridSize83 + 80, // Row 1, Col 80
        1 * gridSize83 + 81, // Row 1, Col 81
        1 * gridSize83 + 82, // Row 1, Col 82
        2 * gridSize83 + 80, // Row 2, Col 80
        2 * gridSize83 + 81, // Row 2, Col 81
        2 * gridSize83 + 82  // Row 2, Col 82
      ];
      
      // Find the separated circles for these indices
      for (let idx of skyBlueIndices) {
        const separatedCircle = grid83.querySelector(`[data-original-row="${Math.floor(idx / gridSize83)}"][data-original-col="${idx % gridSize83}"]`);
        if (separatedCircle) {
          separatedCircle.classList.remove(...COLOR_CLASSES);
          separatedCircle.classList.add('sky');
        }
      }
      speakNumber(6889); // All 6889 dots filled
      clickCount83 = 4;
      
      // Show answer
      if (answerDisplay83) {
        answerDisplay83.textContent = '6889';
        answerDisplay83.classList.add('show');
      }
    } else {
      // Reset
      grid83Circles.forEach(circle => {
        circle.style.visibility = 'visible';
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red');
      });
      // Remove separated circles
      const separatedCircles = grid83.querySelectorAll('[data-original-row]');
      separatedCircles.forEach(sc => sc.remove());
      speakNumber(0);
      clickCount83 = 0;
      if (answerDisplay83) {
        answerDisplay83.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid83Section);
  
  // Create 84×84 grid (7056 dots) with special click behavior
  const grid84Section = document.createElement('section');
  grid84Section.className = 'set';
  grid84Section.style.marginBottom = '40px';
  grid84Section.id = 'square-7056';
  
  const h2_84 = document.createElement('h2');
  h2_84.textContent = '84²';
  grid84Section.appendChild(h2_84);
  
  const grid84 = document.createElement('div');
  grid84.className = 'grid-dynamic grid-7056';
  grid84.id = 'square-7056';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid84.style.gridTemplateColumns = 'repeat(84, calc(var(--circle-total) * 13 / 84))';
  grid84.style.gridTemplateRows = 'repeat(84, calc(var(--circle-total) * 13 / 84))';
  grid84.style.width = 'calc(var(--circle-total) * 13)';
  grid84.style.height = 'calc(var(--circle-total) * 13)';
  grid84.style.position = 'relative';
  
  const gridSize84 = 84;
  const totalDots84 = 7056;
  const grid84Circles = [];
  
  // Create all 7056 circles
  for (let i = 0; i < totalDots84; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-7056';
    grid84.appendChild(circle);
    grid84Circles.push(circle);
  }
  
  grid84Section.appendChild(grid84);
  
  // Add answer display
  const answerDisplay84 = document.createElement('div');
  answerDisplay84.className = 'answer-display';
  answerDisplay84.dataset.answer = '7056';
  grid84Section.appendChild(answerDisplay84);
  
  // Click handler for 84×84 grid
  let clickCount84 = 0;
  
  grid84.addEventListener('click', () => {
    if (clickCount84 === 0) {
      // First click: Fill 7000 brown dots from the bottom row upward, leaving:
      // - 8×7 rectangle: rows 0-6, cols 76-83 (56 dots) in top right corner - black
      // Digit-based coloring: 7000 = 7 (thousands) = brown
      const blackRectangle8x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle8x7Cols = [76, 77, 78, 79, 80, 81, 82, 83];
      const blackIndices = new Set();
      
      // Add 8×7 rectangle indices
      for (let row of blackRectangle8x7Rows) {
        for (let col of blackRectangle8x7Cols) {
          blackIndices.add(row * gridSize84 + col);
        }
      }
      
      let brownCount = 0;
      // Fill from bottom row (row 83) upward
      for (let row = gridSize84 - 1; row >= 0 && brownCount < 7000; row--) {
        for (let col = 0; col < gridSize84 && brownCount < 7000; col++) {
          const idx = row * gridSize84 + col;
          // Skip dots in the black area
          if (!blackIndices.has(idx)) {
            grid84Circles[idx].classList.remove(...COLOR_CLASSES);
            grid84Circles[idx].classList.add('brown');
            brownCount++;
          }
        }
      }
      speakNumber(7000);
      clickCount84 = 1;
    } else if (clickCount84 === 1) {
      // Second click: Fill 50 blue dots in the 8×7 rectangle, leaving 6 black dots in triangle pattern
      // Digit-based coloring: 50 = 5 (tens) = blue
      const blackRectangle8x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const blackRectangle8x7Cols = [76, 77, 78, 79, 80, 81, 82, 83];
      
      // 6 black dots that should remain black (triangle pattern in top right):
      // Row 0: cols 81, 82, 83 (3 dots)
      // Row 1: cols 82, 83 (2 dots)
      // Row 2: col 83 (1 dot)
      const remainingBlackIndices = new Set([
        0 * gridSize84 + 81, // Row 0, Col 81
        0 * gridSize84 + 82, // Row 0, Col 82
        0 * gridSize84 + 83, // Row 0, Col 83
        1 * gridSize84 + 82, // Row 1, Col 82
        1 * gridSize84 + 83, // Row 1, Col 83
        2 * gridSize84 + 83  // Row 2, Col 83
      ]);
      
      // Find all black dots in the 8×7 rectangle (excluding the ones that should remain black)
      const dotsToFill = [];
      for (let row of blackRectangle8x7Rows) {
        for (let col of blackRectangle8x7Cols) {
          const idx = row * gridSize84 + col;
          if (!remainingBlackIndices.has(idx)) {
            dotsToFill.push(idx);
          }
        }
      }
      
      // Fill 50 dots with blue (should be exactly 50: 56 total - 6 remaining = 50)
      const colorFor50 = COLOR_MAP[5] || 'blue'; // 5 = blue
      for (let idx of dotsToFill) {
        grid84Circles[idx].classList.remove(...COLOR_CLASSES);
        grid84Circles[idx].classList.add(colorFor50);
      }
      speakNumber(7050); // 7000 brown + 50 blue
      clickCount84 = 2;
    } else if (clickCount84 === 2) {
      // Third click: Fill the 6 black dots (triangle pattern) with purple
      const purpleIndices = [
        0 * gridSize84 + 81, // Row 0, Col 81
        0 * gridSize84 + 82, // Row 0, Col 82
        0 * gridSize84 + 83, // Row 0, Col 83
        1 * gridSize84 + 82, // Row 1, Col 82
        1 * gridSize84 + 83, // Row 1, Col 83
        2 * gridSize84 + 83  // Row 2, Col 83
      ];
      
      for (let idx of purpleIndices) {
        grid84Circles[idx].classList.remove(...COLOR_CLASSES);
        grid84Circles[idx].classList.add('purple');
      }
      speakNumber(7056); // All 7056 dots filled
      clickCount84 = 3;
      
      // Show answer
      if (answerDisplay84) {
        answerDisplay84.textContent = '7056';
        answerDisplay84.classList.add('show');
      }
    } else {
      // Reset
      grid84Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red');
      });
      speakNumber(0);
      clickCount84 = 0;
      if (answerDisplay84) {
        answerDisplay84.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid84Section);
  
  // Create 85×85 grid (7225 dots) with special click behavior
  const grid85Section = document.createElement('section');
  grid85Section.className = 'set';
  grid85Section.style.marginBottom = '40px';
  grid85Section.id = 'square-7225';
  
  const h2_85 = document.createElement('h2');
  h2_85.textContent = '85²';
  grid85Section.appendChild(h2_85);
  
  const grid85 = document.createElement('div');
  grid85.className = 'grid-dynamic grid-7225';
  grid85.id = 'square-7225';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid85.style.gridTemplateColumns = 'repeat(85, calc(var(--circle-total) * 13 / 85))';
  grid85.style.gridTemplateRows = 'repeat(85, calc(var(--circle-total) * 13 / 85))';
  grid85.style.width = 'calc(var(--circle-total) * 13)';
  grid85.style.height = 'calc(var(--circle-total) * 13)';
  grid85.style.position = 'relative';
  
  const gridSize85 = 85;
  const totalDots85 = 7225;
  const grid85Circles = [];
  
  // Create all 7225 circles
  for (let i = 0; i < totalDots85; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-7225';
    grid85.appendChild(circle);
    grid85Circles.push(circle);
  }
  
  grid85Section.appendChild(grid85);
  
  // Add answer display
  const answerDisplay85 = document.createElement('div');
  answerDisplay85.className = 'answer-display';
  answerDisplay85.dataset.answer = '7225';
  grid85Section.appendChild(answerDisplay85);
  
  // Click handler for 85×85 grid
  let clickCount85 = 0;
  const separatedCircles85 = []; // Track separated circles for movement
  
  grid85.addEventListener('click', () => {
    if (clickCount85 === 0) {
      // First click: Fill 7000 brown dots from the bottom row upward, leaving:
      // - 20×10 rectangle: rows 0-19, cols 70-79 (200 dots) - 5 columns away from right
      // - 5×5 square: rows 0-4, cols 80-84 (25 dots)
      // Digit-based coloring: 7000 = first digit 7 = brown
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x10Cols = [70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      const blackSquare5x5Cols = [80, 81, 82, 83, 84];
      const blackIndices = new Set();
      
      // Add 20×10 rectangle indices
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          blackIndices.add(row * gridSize85 + col);
        }
      }
      
      // Add 5×5 square indices
      for (let row of blackSquare5x5Rows) {
        for (let col of blackSquare5x5Cols) {
          blackIndices.add(row * gridSize85 + col);
        }
      }
      
      let brownCount = 0;
      // Fill from bottom row (row 84) upward
      for (let row = gridSize85 - 1; row >= 0 && brownCount < 7000; row--) {
        for (let col = 0; col < gridSize85 && brownCount < 7000; col++) {
          const idx = row * gridSize85 + col;
          // Skip dots in the black areas
          if (!blackIndices.has(idx)) {
            grid85Circles[idx].classList.remove(...COLOR_CLASSES);
            grid85Circles[idx].classList.add('brown');
            brownCount++;
          }
        }
      }
      speakNumber(7000);
      clickCount85 = 1;
    } else if (clickCount85 === 1) {
      // Second click: Fill 200 orange dots in the 20×10 rectangle
      // Digit-based coloring: 200 = first digit 2 = orange
      const blackRectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x10Cols = [70, 71, 72, 73, 74, 75, 76, 77, 78, 79];
      
      const colorFor200 = COLOR_MAP[2] || 'orange'; // 2 = orange
      for (let row of blackRectangle20x10Rows) {
        for (let col of blackRectangle20x10Cols) {
          const idx = row * gridSize85 + col;
          grid85Circles[idx].classList.remove(...COLOR_CLASSES);
          grid85Circles[idx].classList.add(colorFor200);
        }
      }
      speakNumber(7200); // 7000 brown + 200 orange
      clickCount85 = 2;
    } else if (clickCount85 === 2) {
      // Third click: The 5×5 grid moves right and up, and the first 4 columns turn orange
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      const blackSquare5x5Cols = [80, 81, 82, 83, 84];
      
      // First 4 columns: cols 80-83 (20 dots)
      const orangeCols = [80, 81, 82, 83];
      
      // Find all dots in the 5×5 square
      const square5x5Indices = [];
      for (let row of blackSquare5x5Rows) {
        for (let col of blackSquare5x5Cols) {
          const idx = row * gridSize85 + col;
          square5x5Indices.push({ index: idx, row, col });
        }
      }
      
      // Color the first 4 columns orange and move all 25 dots
      for (const { index, row, col } of square5x5Indices) {
        const circle = grid85Circles[index];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Determine color: first 4 columns are orange, last column stays black
        const isOrange = orangeCols.includes(col);
        
        // Create a separated circle
        const separatedCircle = document.createElement('div');
        separatedCircle.className = isOrange ? 'circle orange' : 'circle';
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = row;
        separatedCircle.dataset.originalCol = col;
        
        // Copy size classes
        circle.classList.forEach(cls => {
          if (cls.startsWith('circle-')) {
            separatedCircle.classList.add(cls);
          }
        });
        
        // Move only to the right (no upward movement)
        // Use scaled circle size variable for 85×85 grid
        separatedCircle.style.left = `calc(var(--circle-total-7225) * ${col} + 0.6 * var(--circle-total-7225))`;
        separatedCircle.style.top = `calc(var(--circle-total-7225) * ${row})`;
        
        separatedCircle.style.display = 'block';
        separatedCircle.style.visibility = 'visible';
        separatedCircle.style.opacity = '1';
        grid85.appendChild(separatedCircle);
        separatedCircles85.push(separatedCircle);
      }
      
      speakNumber(7220); // 7000 brown + 200 orange + 20 orange
      clickCount85 = 3;
    } else if (clickCount85 === 3) {
      // Fourth click: Fill 5 blue dots (the remaining column of the 5×5)
      // The last column (col 84) should turn blue
      // Digit-based coloring: 5 = blue
      const lastColumn = 84;
      const blackSquare5x5Rows = [0, 1, 2, 3, 4];
      
      const colorFor5 = COLOR_MAP[5] || 'blue'; // 5 = blue
      
      // Find the separated circles for the last column
      separatedCircles85.forEach(sc => {
        const scRow = parseInt(sc.dataset.originalRow);
        const scCol = parseInt(sc.dataset.originalCol);
        
        // Check if this is in the last column (col 84)
        if (blackSquare5x5Rows.includes(scRow) && scCol === lastColumn) {
          sc.classList.remove(...COLOR_CLASSES);
          sc.classList.add(colorFor5);
        }
      });
      
      speakNumber(7225); // All 7225 dots filled
      clickCount85 = 4;
      
      // Show answer
      if (answerDisplay85) {
        answerDisplay85.textContent = '7225';
        answerDisplay85.classList.add('show');
      }
    } else {
      // Reset
      // Remove separated circles
      separatedCircles85.forEach(sc => sc.remove());
      separatedCircles85.length = 0;
      
      grid85Circles.forEach(circle => {
        circle.style.visibility = 'visible';
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red');
      });
      speakNumber(0);
      clickCount85 = 0;
      if (answerDisplay85) {
        answerDisplay85.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid85Section);
  
  // Create 86×86 grid (7396 dots) with special click behavior
  const grid86Section = document.createElement('section');
  grid86Section.className = 'set';
  grid86Section.style.marginBottom = '40px';
  grid86Section.id = 'square-7396';
  
  const h2_86 = document.createElement('h2');
  h2_86.textContent = '86²';
  grid86Section.appendChild(h2_86);
  
  const grid86 = document.createElement('div');
  grid86.className = 'grid-dynamic grid-7396';
  grid86.id = 'square-7396';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid86.style.gridTemplateColumns = 'repeat(86, calc(var(--circle-total) * 13 / 86))';
  grid86.style.gridTemplateRows = 'repeat(86, calc(var(--circle-total) * 13 / 86))';
  grid86.style.width = 'calc(var(--circle-total) * 13)';
  grid86.style.height = 'calc(var(--circle-total) * 13)';
  grid86.style.position = 'relative';
  
  const gridSize86 = 86;
  const totalDots86 = 7396;
  const grid86Circles = [];
  
  // Create all 7396 circles
  for (let i = 0; i < totalDots86; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-7396';
    grid86.appendChild(circle);
    grid86Circles.push(circle);
  }
  
  grid86Section.appendChild(grid86);
  
  // Add answer display
  const answerDisplay86 = document.createElement('div');
  answerDisplay86.className = 'answer-display';
  answerDisplay86.dataset.answer = '7396';
  grid86Section.appendChild(answerDisplay86);
  
  // Click handler for 86×86 grid
  let clickCount86 = 0;
  
  grid86.addEventListener('click', () => {
    if (clickCount86 === 0) {
      // First click: Fill 7000 brown dots from the bottom row upward, leaving:
      // - 20×20 rectangle: rows 0-19, cols 66-85 (400 dots) - mostly black
      // - Bottom left corner of 20×20 (rows 18-19, cols 66-67) = 4 brown dots (part of 7000)
      // Digit-based coloring: 7000 = first digit 7 = brown
      const blackRectangle20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x20Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      // Bottom left corner of 20×20 (2×2 square): rows 18-19, cols 66-67 - these will be brown
      const brown2x2Rows = [18, 19];
      const brown2x2Cols = [66, 67];
      const brown2x2Indices = new Set();
      for (let row of brown2x2Rows) {
        for (let col of brown2x2Cols) {
          brown2x2Indices.add(row * gridSize86 + col);
        }
      }
      
      // All indices in the 20×20 rectangle (will be black except the 4 brown)
      const blackIndices = new Set();
      for (let row of blackRectangle20x20Rows) {
        for (let col of blackRectangle20x20Cols) {
          blackIndices.add(row * gridSize86 + col);
        }
      }
      
      let brownCount = 0;
      // Fill from bottom row (row 85) upward
      for (let row = gridSize86 - 1; row >= 0 && brownCount < 7000; row--) {
        for (let col = 0; col < gridSize86 && brownCount < 7000; col++) {
          const idx = row * gridSize86 + col;
          // Skip dots in the black 20×20 area (but include the 4 brown dots)
          if (!blackIndices.has(idx) || brown2x2Indices.has(idx)) {
            grid86Circles[idx].classList.remove(...COLOR_CLASSES);
            grid86Circles[idx].classList.add('brown');
            brownCount++;
          }
        }
      }
      speakNumber(7000);
      clickCount86 = 1;
    } else if (clickCount86 === 1) {
      // Second click: Inside the 20×20, there's a 10×10 square in the top right corner
      // - 10×10 square: rows 0-9, cols 76-85
      // - Bottom left corner of 10×10 (rows 8-9, cols 76-77) = 4 yellow dots
      // - Everything else in the 20×20 that is black (outside the 10×10) gets filled
      const rectangle20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x20Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      const square10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const square10x10Cols = [76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      // Bottom left corner of 10×10: rows 8-9, cols 76-77 (4 yellow dots)
      const yellow2x2Rows = [8, 9];
      const yellow2x2Cols = [76, 77];
      
      // Fill 4 yellow dots
      const colorFor4 = COLOR_MAP[4] || 'green'; // 4 = green, but user said yellow
      for (let row of yellow2x2Rows) {
        for (let col of yellow2x2Cols) {
          const idx = row * gridSize86 + col;
          grid86Circles[idx].classList.remove(...COLOR_CLASSES);
          grid86Circles[idx].classList.add('yellow');
        }
      }
      
      // Fill everything else in the 20×20 that is black (outside the 10×10)
      // But exclude the 4 yellow dots and the 4 brown dots (already filled)
      const square10x10Indices = new Set();
      for (let row of square10x10Rows) {
        for (let col of square10x10Cols) {
          square10x10Indices.add(row * gridSize86 + col);
        }
      }
      
      const yellowIndices = new Set();
      for (let row of yellow2x2Rows) {
        for (let col of yellow2x2Cols) {
          yellowIndices.add(row * gridSize86 + col);
        }
      }
      
      const brown2x2Indices = new Set();
      brown2x2Indices.add(18 * gridSize86 + 66);
      brown2x2Indices.add(18 * gridSize86 + 67);
      brown2x2Indices.add(19 * gridSize86 + 66);
      brown2x2Indices.add(19 * gridSize86 + 67);
      
      // Fill all black dots in 20×20 that are outside the 10×10
      for (let row of rectangle20x20Rows) {
        for (let col of rectangle20x20Cols) {
          const idx = row * gridSize86 + col;
          // Skip if it's in the 10×10 square, or already yellow, or already brown
          if (!square10x10Indices.has(idx) && !yellowIndices.has(idx) && !brown2x2Indices.has(idx)) {
            // Check if it's currently black (not already colored)
            if (!grid86Circles[idx].classList.contains('brown') && 
                !grid86Circles[idx].classList.contains('yellow') &&
                !grid86Circles[idx].classList.contains('orange') &&
                !grid86Circles[idx].classList.contains('green') &&
                !grid86Circles[idx].classList.contains('blue') &&
                !grid86Circles[idx].classList.contains('purple') &&
                !grid86Circles[idx].classList.contains('pink') &&
                !grid86Circles[idx].classList.contains('sky') &&
                !grid86Circles[idx].classList.contains('red')) {
              // Fill with appropriate color - let's use a color based on the count
              // Actually, the user didn't specify what color, so I'll use a neutral color
              // But wait, they said "fill" so maybe they want it filled with a specific color
              // Let me use a color that makes sense - maybe the same as the pattern
              // Actually, I think they want it filled but didn't specify the color
              // Let me check the pattern - they said "everything else inside the 20x20 that is black outside of that 10 by 10" gets filled
              // I'll fill it with a color - let's use a color that makes sense with the pattern
              // Actually, I'll leave it as black for now and see if they specify
              // Wait, they said "will turn yellow on the second click along with everything else inside the 20x20 that is black outside of that 10 by 10"
              // So the "everything else" also turns yellow? Or gets filled with something?
              // Let me re-read: "4 dots will turn yellow on the second click along with everything else inside the 20x20 that is black outside of that 10 by 10"
              // I think "along with" means "in addition to", so the 4 yellow dots turn yellow, and everything else gets filled
              // But with what color? They didn't specify. Let me assume it gets filled with a color that makes sense
              // Actually, maybe they want it all to be the same color? Let me fill it with a color that makes sense
              // I'll fill it with a color based on digit mapping - but I don't know the count
              // Let me count: 20×20 = 400, 10×10 = 100, so outside = 300. But 4 are brown, so 296 black dots
              // 296 = first digit 2 = orange
              grid86Circles[idx].classList.remove(...COLOR_CLASSES);
              grid86Circles[idx].classList.add('yellow');
            }
          }
        }
      }
      
      speakNumber(7300); // 7000 brown + 4 yellow + 296 yellow (approximately)
      clickCount86 = 2;
    } else if (clickCount86 === 2) {
      // Third click: Fill 90 more dots, leaving 6 black dots in triangle pattern:
      // - Top row: 3 black dots (cols 83, 84, 85)
      // - Second row: 2 black dots (cols 84, 85)
      // - Third row: 1 black dot (col 85)
      const square10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const square10x10Cols = [76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      // 6 black dots that should remain black (triangle pattern):
      const remainingBlackIndices = new Set([
        0 * gridSize86 + 83, // Row 0, Col 83
        0 * gridSize86 + 84, // Row 0, Col 84
        0 * gridSize86 + 85, // Row 0, Col 85
        1 * gridSize86 + 84, // Row 1, Col 84
        1 * gridSize86 + 85, // Row 1, Col 85
        2 * gridSize86 + 85  // Row 2, Col 85
      ]);
      
      // Find all black dots in the 10×10 square (excluding the 6 that should remain black)
      const dotsToFill = [];
      for (let row of square10x10Rows) {
        for (let col of square10x10Cols) {
          const idx = row * gridSize86 + col;
          // Skip if it's one of the 6 that should remain black
          if (!remainingBlackIndices.has(idx)) {
            // Check if it's currently black
            if (!grid86Circles[idx].classList.contains('brown') && 
                !grid86Circles[idx].classList.contains('yellow') &&
                !grid86Circles[idx].classList.contains('orange') &&
                !grid86Circles[idx].classList.contains('green') &&
                !grid86Circles[idx].classList.contains('blue') &&
                !grid86Circles[idx].classList.contains('purple') &&
                !grid86Circles[idx].classList.contains('pink') &&
                !grid86Circles[idx].classList.contains('sky') &&
                !grid86Circles[idx].classList.contains('red')) {
              dotsToFill.push(idx);
            }
          }
        }
      }
      
      // Fill 90 dots (should be exactly 90: 100 total - 4 yellow - 6 remaining = 90)
      const colorFor90 = COLOR_MAP[9] || 'sky'; // 9 = sky blue, but 90 = first digit 9 = sky blue
      const dotsToFill90 = dotsToFill.slice(0, 90);
      for (let idx of dotsToFill90) {
        grid86Circles[idx].classList.remove(...COLOR_CLASSES);
        grid86Circles[idx].classList.add(colorFor90);
      }
      
      speakNumber(7390); // 7000 brown + 4 yellow + 296 orange + 90 sky blue (approximately)
      clickCount86 = 3;
    } else if (clickCount86 === 3) {
      // Fourth click: Fill the 6 black dots (triangle pattern) with purple
      const purpleIndices = [
        0 * gridSize86 + 83, // Row 0, Col 83
        0 * gridSize86 + 84, // Row 0, Col 84
        0 * gridSize86 + 85, // Row 0, Col 85
        1 * gridSize86 + 84, // Row 1, Col 84
        1 * gridSize86 + 85, // Row 1, Col 85
        2 * gridSize86 + 85  // Row 2, Col 85
      ];
      
      for (let idx of purpleIndices) {
        grid86Circles[idx].classList.remove(...COLOR_CLASSES);
        grid86Circles[idx].classList.add('purple');
      }
      speakNumber(7396); // All 7396 dots filled
      clickCount86 = 4;
      
      // Show answer
      if (answerDisplay86) {
        answerDisplay86.textContent = '7396';
        answerDisplay86.classList.add('show');
      }
    } else {
      // Reset
      grid86Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount86 = 0;
      if (answerDisplay86) {
        answerDisplay86.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid86Section);
  
  // Create 87×87 grid (7569 dots) with special click behavior
  const grid87Section = document.createElement('section');
  grid87Section.className = 'set';
  grid87Section.style.marginBottom = '40px';
  grid87Section.id = 'square-7569';
  
  const h2_87 = document.createElement('h2');
  h2_87.textContent = '87²';
  grid87Section.appendChild(h2_87);
  
  const grid87 = document.createElement('div');
  grid87.className = 'grid-dynamic grid-7569';
  grid87.id = 'square-7569';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid87.style.gridTemplateColumns = 'repeat(87, calc(var(--circle-total) * 13 / 87))';
  grid87.style.gridTemplateRows = 'repeat(87, calc(var(--circle-total) * 13 / 87))';
  grid87.style.width = 'calc(var(--circle-total) * 13)';
  grid87.style.height = 'calc(var(--circle-total) * 13)';
  grid87.style.position = 'relative';
  
  const gridSize87 = 87;
  const totalDots87 = 7569;
  const grid87Circles = [];
  
  // Create all 7569 circles
  for (let i = 0; i < totalDots87; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-7569';
    grid87.appendChild(circle);
    grid87Circles.push(circle);
  }
  
  grid87Section.appendChild(grid87);
  
  // Add answer display
  const answerDisplay87 = document.createElement('div');
  answerDisplay87.className = 'answer-display';
  answerDisplay87.dataset.answer = '7569';
  grid87Section.appendChild(answerDisplay87);
  
  // Click handler for 87×87 grid
  let clickCount87 = 0;
  
  grid87.addEventListener('click', () => {
    if (clickCount87 === 0) {
      // First click: Fill 7000 brown dots from the bottom row upward, leaving:
      // - 13×13 square: rows 0-12, cols 74-86 (169 dots) in top right corner
      // - 20×20 rectangle: rows 0-19, cols 54-73 (400 dots) to the left of the square
      // Digit-based coloring: 7000 = first digit 7 = brown
      const blackSquare13x13Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
      const blackSquare13x13Cols = [74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86];
      const blackRectangle20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const blackRectangle20x20Cols = [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73];
      const blackIndices = new Set();
      
      // Add 13×13 square indices
      for (let row of blackSquare13x13Rows) {
        for (let col of blackSquare13x13Cols) {
          blackIndices.add(row * gridSize87 + col);
        }
      }
      
      // Add 20×20 rectangle indices
      for (let row of blackRectangle20x20Rows) {
        for (let col of blackRectangle20x20Cols) {
          blackIndices.add(row * gridSize87 + col);
        }
      }
      
      let brownCount = 0;
      // Fill from bottom row (row 86) upward
      for (let row = gridSize87 - 1; row >= 0 && brownCount < 7000; row--) {
        for (let col = 0; col < gridSize87 && brownCount < 7000; col++) {
          const idx = row * gridSize87 + col;
          // Skip dots in the black area
          if (!blackIndices.has(idx)) {
            grid87Circles[idx].classList.remove(...COLOR_CLASSES);
            grid87Circles[idx].classList.add('brown');
            brownCount++;
          }
        }
      }
      speakNumber(7000);
      clickCount87 = 1;
    } else if (clickCount87 === 1) {
      // Second click: Fill 500 blue dots total:
      // - 400 dots in the 20×20 rectangle
      // - 100 dots in the 13×13 square (outside the 7×10 rectangle)
      const rectangle20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x20Cols = [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73];
      
      // Fill all 400 dots in the 20×20 rectangle with blue
      const colorFor500 = COLOR_MAP[5] || 'blue'; // 5 = blue
      for (let row of rectangle20x20Rows) {
        for (let col of rectangle20x20Cols) {
          const idx = row * gridSize87 + col;
          grid87Circles[idx].classList.remove(...COLOR_CLASSES);
          grid87Circles[idx].classList.add(colorFor500);
        }
      }
      
      // Fill 100 dots in the 13×13 square that are outside the 7×10 rectangle
      // The 13×13 square: rows 0-12, cols 74-86
      // The 7×10 rectangle: rows 0-6, cols 77-86
      // So we need to fill dots in:
      // - Rows 0-6, cols 74-76 (3 columns × 7 rows = 21 dots)
      // - Rows 7-12, cols 74-86 (13 columns × 6 rows = 78 dots)
      // Total = 99 dots, but user said 100, so we'll fill 100 dots
      const square13x13Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
      const square13x13Cols = [74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86];
      const rectangle7x10Rows = [0, 1, 2, 3, 4, 5, 6];
      const rectangle7x10Cols = [77, 78, 79, 80, 81, 82, 83, 84, 85, 86];
      
      // Create set of indices in the 7×10 rectangle
      const rectangle7x10Indices = new Set();
      for (let row of rectangle7x10Rows) {
        for (let col of rectangle7x10Cols) {
          rectangle7x10Indices.add(row * gridSize87 + col);
        }
      }
      
      // Find all black dots in the 13×13 square that are outside the 7×10 rectangle
      const dotsToFill = [];
      for (let row of square13x13Rows) {
        for (let col of square13x13Cols) {
          const idx = row * gridSize87 + col;
          // Skip if it's in the 7×10 rectangle
          if (!rectangle7x10Indices.has(idx)) {
            // Check if it's currently black
            if (!grid87Circles[idx].classList.contains('brown') && 
                !grid87Circles[idx].classList.contains('blue') &&
                !grid87Circles[idx].classList.contains('purple') &&
                !grid87Circles[idx].classList.contains('green') &&
                !grid87Circles[idx].classList.contains('orange') &&
                !grid87Circles[idx].classList.contains('pink') &&
                !grid87Circles[idx].classList.contains('sky') &&
                !grid87Circles[idx].classList.contains('red') &&
                !grid87Circles[idx].classList.contains('yellow')) {
              dotsToFill.push(idx);
            }
          }
        }
      }
      
      // Fill 99 dots with blue (from outside the 7×10)
      // Plus 1 dot (bottom left corner of 7×10) = 100 dots total from 13×13 square
      const dotsToFill99 = dotsToFill.slice(0, 99);
      for (let idx of dotsToFill99) {
        grid87Circles[idx].classList.remove(...COLOR_CLASSES);
        grid87Circles[idx].classList.add(colorFor500);
      }
      
      // Also fill the bottom left corner of the 7×10 rectangle (row 6, col 77) with blue
      // This dot is part of the 7×10 but should be blue on the second click
      const bottomLeft7x10Index = 6 * gridSize87 + 77;
      grid87Circles[bottomLeft7x10Index].classList.remove(...COLOR_CLASSES);
      grid87Circles[bottomLeft7x10Index].classList.add(colorFor500);
      
      speakNumber(7500); // 7000 brown + 500 blue
      clickCount87 = 2;
    } else if (clickCount87 === 2) {
      // Third click: Fill 60 dots in the 7×10 rectangle with purple, leaving:
      // - Bottom left corner (row 6, col 77) stays blue
      // - Top right 3×3 (rows 0-2, cols 84-86) stays black
      const rectangle7x10Rows = [0, 1, 2, 3, 4, 5, 6];
      const rectangle7x10Cols = [77, 78, 79, 80, 81, 82, 83, 84, 85, 86];
      
      // Bottom left corner: row 6, col 77 (blue)
      const blueDotIndex = 6 * gridSize87 + 77;
      
      // Top right 3×3: rows 0-2, cols 84-86 (9 dots that stay black)
      const topRight3x3Indices = new Set([
        0 * gridSize87 + 84, 0 * gridSize87 + 85, 0 * gridSize87 + 86,
        1 * gridSize87 + 84, 1 * gridSize87 + 85, 1 * gridSize87 + 86,
        2 * gridSize87 + 84, 2 * gridSize87 + 85, 2 * gridSize87 + 86
      ]);
      
      // Find all black dots in the 7×10 rectangle (excluding blue dot and top right 3×3)
      const dotsToFill = [];
      for (let row of rectangle7x10Rows) {
        for (let col of rectangle7x10Cols) {
          const idx = row * gridSize87 + col;
          // Skip if it's the blue dot or in the top right 3×3
          if (idx !== blueDotIndex && !topRight3x3Indices.has(idx)) {
            // Check if it's currently black
            if (!grid87Circles[idx].classList.contains('brown') && 
                !grid87Circles[idx].classList.contains('blue') &&
                !grid87Circles[idx].classList.contains('purple') &&
                !grid87Circles[idx].classList.contains('green') &&
                !grid87Circles[idx].classList.contains('orange') &&
                !grid87Circles[idx].classList.contains('pink') &&
                !grid87Circles[idx].classList.contains('sky') &&
                !grid87Circles[idx].classList.contains('red') &&
                !grid87Circles[idx].classList.contains('yellow')) {
              dotsToFill.push(idx);
            }
          }
        }
      }
      
      // Fill 60 dots with purple
      const colorFor60 = COLOR_MAP[6] || 'purple'; // 60 = first digit 6 = purple
      const dotsToFill60 = dotsToFill.slice(0, 60);
      for (let idx of dotsToFill60) {
        grid87Circles[idx].classList.remove(...COLOR_CLASSES);
        grid87Circles[idx].classList.add(colorFor60);
      }
      
      speakNumber(7560); // 7000 + 500 + 60
      clickCount87 = 3;
    } else if (clickCount87 === 3) {
      // Fourth click: Fill the top right 3×3 (9 dots) with sky blue
      const topRight3x3Indices = [
        0 * gridSize87 + 84, 0 * gridSize87 + 85, 0 * gridSize87 + 86,
        1 * gridSize87 + 84, 1 * gridSize87 + 85, 1 * gridSize87 + 86,
        2 * gridSize87 + 84, 2 * gridSize87 + 85, 2 * gridSize87 + 86
      ];
      
      const colorFor9 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      for (let idx of topRight3x3Indices) {
        grid87Circles[idx].classList.remove(...COLOR_CLASSES);
        grid87Circles[idx].classList.add(colorFor9);
      }
      
      speakNumber(7569); // All 7569 dots filled
      clickCount87 = 4;
      
      // Show answer
      if (answerDisplay87) {
        answerDisplay87.textContent = '7569';
        answerDisplay87.classList.add('show');
      }
    } else {
      // Reset
      grid87Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount87 = 0;
      if (answerDisplay87) {
        answerDisplay87.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid87Section);
  
  // Create 88×88 grid (7744 dots) with special click behavior
  const grid88Section = document.createElement('section');
  grid88Section.className = 'set';
  grid88Section.style.marginBottom = '40px';
  grid88Section.id = 'square-7744';
  
  const h2_88 = document.createElement('h2');
  h2_88.textContent = '88²';
  grid88Section.appendChild(h2_88);
  
  const grid88 = document.createElement('div');
  grid88.className = 'grid-dynamic grid-7744';
  grid88.id = 'square-7744';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid88.style.gridTemplateColumns = 'repeat(88, calc(var(--circle-total) * 13 / 88))';
  grid88.style.gridTemplateRows = 'repeat(88, calc(var(--circle-total) * 13 / 88))';
  grid88.style.width = 'calc(var(--circle-total) * 13)';
  grid88.style.height = 'calc(var(--circle-total) * 13)';
  grid88.style.position = 'relative';
  
  const gridSize88 = 88;
  const totalDots88 = 7744;
  const grid88Circles = [];
  
  // Create all 7744 circles
  for (let i = 0; i < totalDots88; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-7744';
    grid88.appendChild(circle);
    grid88Circles.push(circle);
  }
  
  grid88Section.appendChild(grid88);
  
  // Add answer display
  const answerDisplay88 = document.createElement('div');
  answerDisplay88.className = 'answer-display';
  answerDisplay88.dataset.answer = '7744';
  grid88Section.appendChild(answerDisplay88);
  
  // Click handler for 88×88 grid
  let clickCount88 = 0;
  
  grid88.addEventListener('click', () => {
    if (clickCount88 === 0) {
      // First click: Fill 7000 brown dots from the bottom row upward, leaving:
      // - 2×2 square: rows 0-1, cols 86-87 (4 dots) in top right corner
      // - 4×10 rectangle: rows 0-3, cols 76-85 (40 dots) next to the 2×2
      // - 20×35 rectangle: rows 0-19, cols 41-75 (700 dots) next to the 4×10
      // Total remaining: 744 black dots
      // Digit-based coloring: 7000 = first digit 7 = brown
      const colorFor7000 = COLOR_MAP[7] || 'brown'; // 7 = brown
      
      // Define the black regions that should remain black
      const square2x2Rows = [0, 1];
      const square2x2Cols = [86, 87];
      const rectangle4x10Rows = [0, 1, 2, 3];
      const rectangle4x10Cols = [76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      const rectangle20x35Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x35Cols = [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75];
      
      const blackIndices = new Set();
      
      // Add 2×2 square indices
      for (let row of square2x2Rows) {
        for (let col of square2x2Cols) {
          blackIndices.add(row * gridSize88 + col);
        }
      }
      
      // Add 4×10 rectangle indices
      for (let row of rectangle4x10Rows) {
        for (let col of rectangle4x10Cols) {
          blackIndices.add(row * gridSize88 + col);
        }
      }
      
      // Add 20×35 rectangle indices
      for (let row of rectangle20x35Rows) {
        for (let col of rectangle20x35Cols) {
          blackIndices.add(row * gridSize88 + col);
        }
      }
      
      // Fill all dots brown except the black regions
      let brownCount = 0;
      for (let i = 0; i < totalDots88; i++) {
        if (!blackIndices.has(i)) {
          grid88Circles[i].classList.remove(...COLOR_CLASSES);
          grid88Circles[i].classList.add(colorFor7000);
          brownCount++;
        }
      }
      
      speakNumber(7000);
      clickCount88 = 1;
      
      // Show answer
      const answerDisplay88 = grid88Section.querySelector('.answer-display');
      if (answerDisplay88) {
        answerDisplay88.textContent = '7744';
        answerDisplay88.classList.add('show');
      }
    } else if (clickCount88 === 1) {
      // Second click: Move the 20×35 rectangle UP (one dot distance)
      const rectangle20x35Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x35Cols = [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75];
      
      // Find all black dots in the 20×35 rectangle
      const blackDots20x35 = [];
      for (let row of rectangle20x35Rows) {
        for (let col of rectangle20x35Cols) {
          const idx = row * gridSize88 + col;
          const circle = grid88Circles[idx];
          // Check if this dot is black (not brown)
          if (!circle.classList.contains('brown')) {
            blackDots20x35.push({ row: row, col: col, idx: idx });
          }
        }
      }
      
      // Move all dots up by half a dot distance and fill them brown
      // Hide original circles and create separated circles positioned half a dot up
      const colorFor700 = COLOR_MAP[7] || 'brown'; // 7 = brown
      
      for (let dot of blackDots20x35) {
        const circle = grid88Circles[dot.idx];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Create a new separated circle positioned half a dot up and fill it brown
        const separatedCircle = document.createElement('div');
        separatedCircle.className = 'circle circle-7744';
        separatedCircle.classList.add(colorFor700); // Fill brown
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = dot.row;
        separatedCircle.dataset.originalCol = dot.col;
        separatedCircle.dataset.originalIdx = dot.idx;
        
        // Position half a dot distance up (subtract half a dot diameter from top)
        // Use scaled circle size variable for 88×88 grid
        separatedCircle.style.top = `calc(var(--circle-total-7744) * ${dot.row} - var(--circle-total-7744) * 0.5)`;
        separatedCircle.style.left = `calc(var(--circle-total-7744) * ${dot.col})`;
        
        grid88.appendChild(separatedCircle);
      }
      
      speakNumber(7700); // 7000 + 700 = 7700 brown dots
      clickCount88 = 2;
    } else if (clickCount88 === 2) {
      // Third click: Fill the 4×10 rectangle with green (40 dots)
      // The moved 20×35 rectangle is already brown from the second click
      const rectangle4x10Rows = [0, 1, 2, 3];
      const rectangle4x10Cols = [76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      const colorFor40 = COLOR_MAP[4] || 'green'; // 4 = green
      
      // Fill the 4×10 rectangle with green
      for (let row of rectangle4x10Rows) {
        for (let col of rectangle4x10Cols) {
          const idx = row * gridSize88 + col;
          grid88Circles[idx].classList.remove(...COLOR_CLASSES);
          grid88Circles[idx].classList.add(colorFor40);
        }
      }
      
      speakNumber(7740); // 7000 + 700 + 40 = 7740 dots filled
      clickCount88 = 3;
    } else if (clickCount88 === 3) {
      // Fourth click: Move the 2×2 square to the RIGHT and fill it green (4 dots)
      const square2x2Rows = [0, 1];
      const square2x2Cols = [86, 87];
      
      const colorFor4 = COLOR_MAP[4] || 'green'; // 4 = green
      
      // Move the 2×2 square to the RIGHT and fill it green
      const blackDots2x2 = [];
      for (let row of square2x2Rows) {
        for (let col of square2x2Cols) {
          const idx = row * gridSize88 + col;
          const circle = grid88Circles[idx];
          // Check if this dot is black (not brown or green)
          if (!circle.classList.contains('brown') && !circle.classList.contains('green')) {
            blackDots2x2.push({ row: row, col: col, idx: idx });
          }
        }
      }
      
      // Move all 4 dots to the right (one dot distance) and fill green
      for (let dot of blackDots2x2) {
        const circle = grid88Circles[dot.idx];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Create a new separated circle positioned one dot to the right
        const separatedCircle = document.createElement('div');
        separatedCircle.className = 'circle circle-7744';
        separatedCircle.classList.add(colorFor4); // Fill green
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = dot.row;
        separatedCircle.dataset.originalCol = dot.col;
        separatedCircle.dataset.originalIdx = dot.idx;
        
        // Position half a dot distance to the right (add half a dot diameter to left)
        // Use scaled circle size variable for 88×88 grid
        separatedCircle.style.top = `calc(var(--circle-total-7744) * ${dot.row})`;
        separatedCircle.style.left = `calc(var(--circle-total-7744) * ${dot.col} + var(--circle-total-7744) * 0.5)`;
        
        grid88.appendChild(separatedCircle);
      }
      
      speakNumber(7744); // All 7744 dots filled
      clickCount88 = 4;
      
      // Show answer
      const answerDisplay88 = grid88Section.querySelector('.answer-display');
      if (answerDisplay88) {
        answerDisplay88.textContent = '7744';
        answerDisplay88.classList.add('show');
      }
    } else {
      // Reset
      // Remove all separated circles
      const allSeparated = grid88.querySelectorAll('[data-original-row][data-original-col]');
      allSeparated.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      
      // Reset visibility and colors
      grid88Circles.forEach(circle => {
        circle.style.visibility = '';
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount88 = 0;
      const answerDisplay88 = grid88Section.querySelector('.answer-display');
      if (answerDisplay88) {
        answerDisplay88.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid88Section);
  
  // Create 89×89 grid (7921 dots) with special click behavior
  const grid89Section = document.createElement('section');
  grid89Section.className = 'set';
  grid89Section.style.marginBottom = '40px';
  grid89Section.id = 'square-7921';
  
  const h2_89 = document.createElement('h2');
  h2_89.textContent = '89²';
  grid89Section.appendChild(h2_89);
  
  const grid89 = document.createElement('div');
  grid89.className = 'grid-dynamic grid-7921';
  grid89.id = 'square-7921';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid89.style.gridTemplateColumns = 'repeat(89, calc(var(--circle-total) * 13 / 89))';
  grid89.style.gridTemplateRows = 'repeat(89, calc(var(--circle-total) * 13 / 89))';
  grid89.style.width = 'calc(var(--circle-total) * 13)';
  grid89.style.height = 'calc(var(--circle-total) * 13)';
  grid89.style.position = 'relative';
  
  const gridSize89 = 89;
  const totalDots89 = 7921;
  const grid89Circles = [];
  
  // Create all 7921 circles
  for (let i = 0; i < totalDots89; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-7921';
    grid89.appendChild(circle);
    grid89Circles.push(circle);
  }
  
  grid89Section.appendChild(grid89);
  
  // Add answer display
  const answerDisplay89 = document.createElement('div');
  answerDisplay89.className = 'answer-display';
  answerDisplay89.dataset.answer = '7921';
  grid89Section.appendChild(answerDisplay89);
  
  // Click handler for 89×89 grid
  let clickCount89 = 0;
  
  grid89.addEventListener('click', () => {
    if (clickCount89 === 0) {
      // First click: Fill 7000 brown dots from the bottom row upward, leaving:
      // - 7×3 rectangle: rows 0-6, cols 86-88 (21 dots) in top right corner
      // - 30×30 rectangle: rows 0-29, cols 56-85 (900 dots) to the left of the 7×3
      // Total remaining: 921 black dots
      // Digit-based coloring: 7000 = first digit 7 = brown
      const colorFor7000 = COLOR_MAP[7] || 'brown'; // 7 = brown
      
      // Define the black regions that should remain black
      const rectangle7x3Rows = [0, 1, 2, 3, 4, 5, 6];
      const rectangle7x3Cols = [86, 87, 88];
      const rectangle30x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29];
      const rectangle30x30Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      const blackIndices = new Set();
      
      // Add 7×3 rectangle indices
      for (let row of rectangle7x3Rows) {
        for (let col of rectangle7x3Cols) {
          blackIndices.add(row * gridSize89 + col);
        }
      }
      
      // Add 30×30 rectangle indices
      for (let row of rectangle30x30Rows) {
        for (let col of rectangle30x30Cols) {
          blackIndices.add(row * gridSize89 + col);
        }
      }
      
      // Fill all dots brown except the black regions
      let brownCount = 0;
      for (let i = 0; i < totalDots89; i++) {
        if (!blackIndices.has(i)) {
          grid89Circles[i].classList.remove(...COLOR_CLASSES);
          grid89Circles[i].classList.add(colorFor7000);
          brownCount++;
        }
      }
      
      speakNumber(7000);
      clickCount89 = 1;
      
      // Show answer
      const answerDisplay89 = grid89Section.querySelector('.answer-display');
      if (answerDisplay89) {
        answerDisplay89.textContent = '7921';
        answerDisplay89.classList.add('show');
      }
    } else if (clickCount89 === 1) {
      // Second click: Fill the 30×30 rectangle with sky blue (900 dots)
      // Digit-based coloring: 900 = first digit 9 = sky blue
      const rectangle30x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29];
      const rectangle30x30Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      const colorFor900 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      for (let row of rectangle30x30Rows) {
        for (let col of rectangle30x30Cols) {
          const idx = row * gridSize89 + col;
          grid89Circles[idx].classList.remove(...COLOR_CLASSES);
          grid89Circles[idx].classList.add(colorFor900);
        }
      }
      
      speakNumber(7900); // 7000 + 900 = 7900 dots filled
      clickCount89 = 2;
    } else if (clickCount89 === 2) {
      // Third click: Fill 20 dots in the 7×3 rectangle with orange, leaving the top right corner dot black
      // Digit-based coloring: 20 = first digit 2 = orange
      const rectangle7x3Rows = [0, 1, 2, 3, 4, 5, 6];
      const rectangle7x3Cols = [86, 87, 88];
      
      const colorFor20 = COLOR_MAP[2] || 'orange'; // 2 = orange
      
      // Top right corner: row 0, col 88 should remain black
      const topRightIndex = 0 * gridSize89 + 88;
      
      // Fill all dots in the 7×3 rectangle except the top right corner
      for (let row of rectangle7x3Rows) {
        for (let col of rectangle7x3Cols) {
          const idx = row * gridSize89 + col;
          if (idx !== topRightIndex) {
            grid89Circles[idx].classList.remove(...COLOR_CLASSES);
            grid89Circles[idx].classList.add(colorFor20);
          }
        }
      }
      
      speakNumber(7920); // 7000 + 900 + 20 = 7920 dots filled
      clickCount89 = 3;
    } else if (clickCount89 === 3) {
      // Fourth click: Fill the last dot (top right corner) with red
      // Digit-based coloring: 1 = red
      const topRightIndex = 0 * gridSize89 + 88;
      const colorFor1 = COLOR_MAP[1] || 'red'; // 1 = red
      
      grid89Circles[topRightIndex].classList.remove(...COLOR_CLASSES);
      grid89Circles[topRightIndex].classList.add(colorFor1);
      
      speakNumber(7921); // All 7921 dots filled
      clickCount89 = 4;
      
      // Show answer
      const answerDisplay89 = grid89Section.querySelector('.answer-display');
      if (answerDisplay89) {
        answerDisplay89.textContent = '7921';
        answerDisplay89.classList.add('show');
      }
    } else {
      // Reset
      grid89Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount89 = 0;
      const answerDisplay89 = grid89Section.querySelector('.answer-display');
      if (answerDisplay89) {
        answerDisplay89.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid89Section);
  
  // Create 90×90 grid (8100 dots) with special click behavior
  const grid90Section = document.createElement('section');
  grid90Section.className = 'set';
  grid90Section.style.marginBottom = '40px';
  grid90Section.id = 'square-8100';
  
  const h2_90 = document.createElement('h2');
  h2_90.textContent = '90²';
  grid90Section.appendChild(h2_90);
  
  const grid90 = document.createElement('div');
  grid90.className = 'grid-dynamic grid-8100';
  grid90.id = 'square-8100';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid90.style.gridTemplateColumns = 'repeat(90, calc(var(--circle-total) * 13 / 90))';
  grid90.style.gridTemplateRows = 'repeat(90, calc(var(--circle-total) * 13 / 90))';
  grid90.style.width = 'calc(var(--circle-total) * 13)';
  grid90.style.height = 'calc(var(--circle-total) * 13)';
  grid90.style.position = 'relative';
  
  const gridSize90 = 90;
  const totalDots90 = 8100;
  const grid90Circles = [];
  
  // Create all 8100 circles
  for (let i = 0; i < totalDots90; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-8100';
    grid90.appendChild(circle);
    grid90Circles.push(circle);
  }
  
  grid90Section.appendChild(grid90);
  
  // Add answer display
  const answerDisplay90 = document.createElement('div');
  answerDisplay90.className = 'answer-display';
  answerDisplay90.dataset.answer = '8100';
  grid90Section.appendChild(answerDisplay90);
  
  // Click handler for 90×90 grid
  let clickCount90 = 0;
  
  grid90.addEventListener('click', () => {
    if (clickCount90 === 0) {
      // First click: Fill 8000 pink dots from the bottom row upward, leaving:
      // - 10×10 square: rows 0-9, cols 80-89 (100 dots) in top right corner
      // Total remaining: 100 black dots
      // Digit-based coloring: 8000 = first digit 8 = pink
      const colorFor8000 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      // Define the black region that should remain black
      const square10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const square10x10Cols = [80, 81, 82, 83, 84, 85, 86, 87, 88, 89];
      
      const blackIndices = new Set();
      
      // Add 10×10 square indices
      for (let row of square10x10Rows) {
        for (let col of square10x10Cols) {
          blackIndices.add(row * gridSize90 + col);
        }
      }
      
      // Fill all dots pink except the black region
      let pinkCount = 0;
      for (let i = 0; i < totalDots90; i++) {
        if (!blackIndices.has(i)) {
          grid90Circles[i].classList.remove(...COLOR_CLASSES);
          grid90Circles[i].classList.add(colorFor8000);
          pinkCount++;
        }
      }
      
      speakNumber(8000);
      clickCount90 = 1;
      
      // Show answer
      const answerDisplay90 = grid90Section.querySelector('.answer-display');
      if (answerDisplay90) {
        answerDisplay90.textContent = '8100';
        answerDisplay90.classList.add('show');
      }
    } else if (clickCount90 === 1) {
      // Second click: Fill the 10×10 square with red (100 dots)
      // Digit-based coloring: 100 = first digit 1 = red
      const square10x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const square10x10Cols = [80, 81, 82, 83, 84, 85, 86, 87, 88, 89];
      
      const colorFor100 = COLOR_MAP[1] || 'red'; // 1 = red
      
      for (let row of square10x10Rows) {
        for (let col of square10x10Cols) {
          const idx = row * gridSize90 + col;
          grid90Circles[idx].classList.remove(...COLOR_CLASSES);
          grid90Circles[idx].classList.add(colorFor100);
        }
      }
      
      speakNumber(8100); // All 8100 dots filled
      clickCount90 = 2;
      
      // Show answer
      const answerDisplay90 = grid90Section.querySelector('.answer-display');
      if (answerDisplay90) {
        answerDisplay90.textContent = '8100';
        answerDisplay90.classList.add('show');
      }
    } else {
      // Reset
      grid90Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount90 = 0;
      const answerDisplay90 = grid90Section.querySelector('.answer-display');
      if (answerDisplay90) {
        answerDisplay90.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid90Section);
  
  // Create 91×91 grid (8281 dots) with special click behavior
  const grid91Section = document.createElement('section');
  grid91Section.className = 'set';
  grid91Section.style.marginBottom = '40px';
  grid91Section.id = 'square-8281';
  
  const h2_91 = document.createElement('h2');
  h2_91.textContent = '91²';
  grid91Section.appendChild(h2_91);
  
  const grid91 = document.createElement('div');
  grid91.className = 'grid-dynamic grid-8281';
  grid91.id = 'square-8281';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid91.style.gridTemplateColumns = 'repeat(91, calc(var(--circle-total) * 13 / 91))';
  grid91.style.gridTemplateRows = 'repeat(91, calc(var(--circle-total) * 13 / 91))';
  grid91.style.width = 'calc(var(--circle-total) * 13)';
  grid91.style.height = 'calc(var(--circle-total) * 13)';
  grid91.style.position = 'relative';
  
  const gridSize91 = 91;
  const totalDots91 = 8281;
  const grid91Circles = [];
  
  // Create all 8281 circles
  for (let i = 0; i < totalDots91; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-8281';
    grid91.appendChild(circle);
    grid91Circles.push(circle);
  }
  
  grid91Section.appendChild(grid91);
  
  // Add answer display
  const answerDisplay91 = document.createElement('div');
  answerDisplay91.className = 'answer-display';
  answerDisplay91.dataset.answer = '8281';
  grid91Section.appendChild(answerDisplay91);
  
  // Click handler for 91×91 grid
  let clickCount91 = 0;
  
  grid91.addEventListener('click', () => {
    if (clickCount91 === 0) {
      // First click: Fill 8000 pink dots from the bottom row upward, leaving:
      // - 9×9 square: rows 0-8, cols 82-90 (81 dots) in top right corner
      // - 20×10 rectangle: rows 0-19, cols 72-81 (200 dots) to the left of the 9×9
      // Total remaining: 281 black dots
      // Digit-based coloring: 8000 = first digit 8 = pink
      const colorFor8000 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      // Define the black regions that should remain black
      const square9x9Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const square9x9Cols = [82, 83, 84, 85, 86, 87, 88, 89, 90];
      const rectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x10Cols = [72, 73, 74, 75, 76, 77, 78, 79, 80, 81];
      
      const blackIndices = new Set();
      
      // Add 9×9 square indices
      for (let row of square9x9Rows) {
        for (let col of square9x9Cols) {
          blackIndices.add(row * gridSize91 + col);
        }
      }
      
      // Add 20×10 rectangle indices
      for (let row of rectangle20x10Rows) {
        for (let col of rectangle20x10Cols) {
          blackIndices.add(row * gridSize91 + col);
        }
      }
      
      // Fill all dots pink except the black regions
      let pinkCount = 0;
      for (let i = 0; i < totalDots91; i++) {
        if (!blackIndices.has(i)) {
          grid91Circles[i].classList.remove(...COLOR_CLASSES);
          grid91Circles[i].classList.add(colorFor8000);
          pinkCount++;
        }
      }
      
      speakNumber(8000);
      clickCount91 = 1;
      
      // Show answer
      const answerDisplay91 = grid91Section.querySelector('.answer-display');
      if (answerDisplay91) {
        answerDisplay91.textContent = '8281';
        answerDisplay91.classList.add('show');
      }
    } else if (clickCount91 === 1) {
      // Second click: Fill the 20×10 rectangle with orange (200 dots)
      // Digit-based coloring: 200 = first digit 2 = orange
      const rectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x10Cols = [72, 73, 74, 75, 76, 77, 78, 79, 80, 81];
      
      const colorFor200 = COLOR_MAP[2] || 'orange'; // 2 = orange
      
      for (let row of rectangle20x10Rows) {
        for (let col of rectangle20x10Cols) {
          const idx = row * gridSize91 + col;
          grid91Circles[idx].classList.remove(...COLOR_CLASSES);
          grid91Circles[idx].classList.add(colorFor200);
        }
      }
      
      speakNumber(8200); // 8000 + 200 = 8200 dots filled
      clickCount91 = 2;
    } else if (clickCount91 === 2) {
      // Third click: Move the 9×9 square up by half a dot distance
      // Fill 80 dots pink, leaving the top right corner dot black
      const square9x9Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      const square9x9Cols = [82, 83, 84, 85, 86, 87, 88, 89, 90];
      
      // Top right corner: row 0, col 90 should remain black
      const topRightIndex = 0 * gridSize91 + 90;
      
      // Find all black dots in the 9×9 square
      const blackDots9x9 = [];
      for (let row of square9x9Rows) {
        for (let col of square9x9Cols) {
          const idx = row * gridSize91 + col;
          const circle = grid91Circles[idx];
          // Check if this dot is black (not pink or orange)
          if (!circle.classList.contains('pink') && !circle.classList.contains('orange')) {
            blackDots9x9.push({ row: row, col: col, idx: idx });
          }
        }
      }
      
      const colorFor80 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      // Move all dots up by half a dot distance
      // Hide original circles and create separated circles
      let pinkFilled = 0;
      for (let dot of blackDots9x9) {
        const circle = grid91Circles[dot.idx];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Create a new separated circle positioned half a dot up
        const separatedCircle = document.createElement('div');
        separatedCircle.className = 'circle circle-8281';
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = dot.row;
        separatedCircle.dataset.originalCol = dot.col;
        separatedCircle.dataset.originalIdx = dot.idx;
        
        // Position half a dot distance up (no rightward movement)
        // Use scaled circle size variable for 91×91 grid
        separatedCircle.style.top = `calc(var(--circle-total-8281) * ${dot.row} - var(--circle-total-8281) * 0.5)`;
        separatedCircle.style.left = `calc(var(--circle-total-8281) * ${dot.col})`;
        
        // Fill with pink except for the top right corner
        if (dot.idx !== topRightIndex && pinkFilled < 80) {
          separatedCircle.classList.add(colorFor80);
          pinkFilled++;
        }
        
        grid91.appendChild(separatedCircle);
      }
      
      speakNumber(8280); // 8000 + 200 + 80 = 8280 dots filled
      clickCount91 = 3;
    } else if (clickCount91 === 3) {
      // Fourth click: Fill the top right corner separated circle with red
      // Digit-based coloring: 1 = red
      const topRightIndex = 0 * gridSize91 + 90;
      const colorFor1 = COLOR_MAP[1] || 'red'; // 1 = red
      
      // Find the separated circle that corresponds to the top right corner
      const topRightSeparatedCircle = grid91.querySelector(`[data-original-row="0"][data-original-col="90"]`);
      
      if (topRightSeparatedCircle) {
        topRightSeparatedCircle.classList.remove(...COLOR_CLASSES);
        topRightSeparatedCircle.classList.add(colorFor1);
      }
      
      speakNumber(8281); // All 8281 dots filled
      clickCount91 = 4;
      
      // Show answer
      const answerDisplay91 = grid91Section.querySelector('.answer-display');
      if (answerDisplay91) {
        answerDisplay91.textContent = '8281';
        answerDisplay91.classList.add('show');
      }
    } else {
      // Reset
      // Remove all separated circles
      const allSeparated = grid91.querySelectorAll('[data-original-row][data-original-col]');
      allSeparated.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      
      // Reset visibility and colors
      grid91Circles.forEach(circle => {
        circle.style.visibility = '';
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount91 = 0;
      const answerDisplay91 = grid91Section.querySelector('.answer-display');
      if (answerDisplay91) {
        answerDisplay91.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid91Section);
  
  // Create 92×92 grid (8464 dots) with special click behavior
  const grid92Section = document.createElement('section');
  grid92Section.className = 'set';
  grid92Section.style.marginBottom = '40px';
  grid92Section.id = 'square-8464';
  
  const h2_92 = document.createElement('h2');
  h2_92.textContent = '92²';
  grid92Section.appendChild(h2_92);
  
  const grid92 = document.createElement('div');
  grid92.className = 'grid-dynamic grid-8464';
  grid92.id = 'square-8464';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid92.style.gridTemplateColumns = 'repeat(92, calc(var(--circle-total) * 13 / 92))';
  grid92.style.gridTemplateRows = 'repeat(92, calc(var(--circle-total) * 13 / 92))';
  grid92.style.width = 'calc(var(--circle-total) * 13)';
  grid92.style.height = 'calc(var(--circle-total) * 13)';
  grid92.style.position = 'relative';
  
  const gridSize92 = 92;
  const totalDots92 = 8464;
  const grid92Circles = [];
  
  // Create all 8464 circles
  for (let i = 0; i < totalDots92; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-8464';
    grid92.appendChild(circle);
    grid92Circles.push(circle);
  }
  
  grid92Section.appendChild(grid92);
  
  // Add answer display
  const answerDisplay92 = document.createElement('div');
  answerDisplay92.className = 'answer-display';
  answerDisplay92.dataset.answer = '8464';
  grid92Section.appendChild(answerDisplay92);
  
  // Click handler for 92×92 grid
  let clickCount92 = 0;
  
  grid92.addEventListener('click', () => {
    if (clickCount92 === 0) {
      // First click: Fill 8000 pink dots from the bottom row upward, leaving:
      // - 8×8 square: rows 0-7, cols 84-91 (64 dots) in top right corner
      // - 20×20 square: rows 0-19, cols 64-83 (400 dots) to the left of the 8×8
      // Total remaining: 464 black dots
      // Digit-based coloring: 8000 = first digit 8 = pink
      const colorFor8000 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      // Define the black regions that should remain black
      const square8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const square8x8Cols = [84, 85, 86, 87, 88, 89, 90, 91];
      const square20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const square20x20Cols = [64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83];
      
      const blackIndices = new Set();
      
      // Add 8×8 square indices
      for (let row of square8x8Rows) {
        for (let col of square8x8Cols) {
          blackIndices.add(row * gridSize92 + col);
        }
      }
      
      // Add 20×20 square indices
      for (let row of square20x20Rows) {
        for (let col of square20x20Cols) {
          blackIndices.add(row * gridSize92 + col);
        }
      }
      
      // Fill all dots pink except the black regions
      let pinkCount = 0;
      for (let i = 0; i < totalDots92; i++) {
        if (!blackIndices.has(i)) {
          grid92Circles[i].classList.remove(...COLOR_CLASSES);
          grid92Circles[i].classList.add(colorFor8000);
          pinkCount++;
        }
      }
      
      speakNumber(8000);
      clickCount92 = 1;
      
      // Show answer
      const answerDisplay92 = grid92Section.querySelector('.answer-display');
      if (answerDisplay92) {
        answerDisplay92.textContent = '8464';
        answerDisplay92.classList.add('show');
      }
    } else if (clickCount92 === 1) {
      // Second click: Fill the 20×20 square with green (400 dots)
      // Digit-based coloring: 400 = first digit 4 = green
      const square20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const square20x20Cols = [64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83];
      
      const colorFor400 = COLOR_MAP[4] || 'green'; // 4 = green
      
      for (let row of square20x20Rows) {
        for (let col of square20x20Cols) {
          const idx = row * gridSize92 + col;
          grid92Circles[idx].classList.remove(...COLOR_CLASSES);
          grid92Circles[idx].classList.add(colorFor400);
        }
      }
      
      speakNumber(8400); // 8000 + 400 = 8400 dots filled
      clickCount92 = 2;
    } else if (clickCount92 === 2) {
      // Third click: Fill 60 dots in the 8×8 square with purple, leaving a 2×2 square (4 dots) in the top right corner
      // Digit-based coloring: 60 = first digit 6 = purple
      const square8x8Rows = [0, 1, 2, 3, 4, 5, 6, 7];
      const square8x8Cols = [84, 85, 86, 87, 88, 89, 90, 91];
      
      const colorFor60 = COLOR_MAP[6] || 'purple'; // 6 = purple
      
      // Top right 2×2 square: rows 0-1, cols 90-91 (4 dots) should remain black
      const topRight2x2Indices = new Set([
        0 * gridSize92 + 90, 0 * gridSize92 + 91,
        1 * gridSize92 + 90, 1 * gridSize92 + 91
      ]);
      
      // Fill all dots in the 8×8 square except the top right 2×2
      let purpleFilled = 0;
      for (let row of square8x8Rows) {
        for (let col of square8x8Cols) {
          const idx = row * gridSize92 + col;
          if (!topRight2x2Indices.has(idx) && purpleFilled < 60) {
            grid92Circles[idx].classList.remove(...COLOR_CLASSES);
            grid92Circles[idx].classList.add(colorFor60);
            purpleFilled++;
          }
        }
      }
      
      speakNumber(8460); // 8000 + 400 + 60 = 8460 dots filled
      clickCount92 = 3;
    } else if (clickCount92 === 3) {
      // Fourth click: Fill the 2×2 square (4 dots) in the top right corner with green
      // Digit-based coloring: 4 = green
      const topRight2x2Rows = [0, 1];
      const topRight2x2Cols = [90, 91];
      
      const colorFor4 = COLOR_MAP[4] || 'green'; // 4 = green
      
      for (let row of topRight2x2Rows) {
        for (let col of topRight2x2Cols) {
          const idx = row * gridSize92 + col;
          grid92Circles[idx].classList.remove(...COLOR_CLASSES);
          grid92Circles[idx].classList.add(colorFor4);
        }
      }
      
      speakNumber(8464); // All 8464 dots filled
      clickCount92 = 4;
      
      // Show answer
      const answerDisplay92 = grid92Section.querySelector('.answer-display');
      if (answerDisplay92) {
        answerDisplay92.textContent = '8464';
        answerDisplay92.classList.add('show');
      }
    } else {
      // Reset
      grid92Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount92 = 0;
      const answerDisplay92 = grid92Section.querySelector('.answer-display');
      if (answerDisplay92) {
        answerDisplay92.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid92Section);
  
  // Create 93×93 grid (8649 dots) with special click behavior
  const grid93Section = document.createElement('section');
  grid93Section.className = 'set';
  grid93Section.style.marginBottom = '40px';
  grid93Section.id = 'square-8649';
  
  const h2_93 = document.createElement('h2');
  h2_93.textContent = '93²';
  grid93Section.appendChild(h2_93);
  
  const grid93 = document.createElement('div');
  grid93.className = 'grid-dynamic grid-8649';
  grid93.id = 'square-8649';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid93.style.gridTemplateColumns = 'repeat(93, calc(var(--circle-total) * 13 / 93))';
  grid93.style.gridTemplateRows = 'repeat(93, calc(var(--circle-total) * 13 / 93))';
  grid93.style.width = 'calc(var(--circle-total) * 13)';
  grid93.style.height = 'calc(var(--circle-total) * 13)';
  grid93.style.position = 'relative';
  
  const gridSize93 = 93;
  const totalDots93 = 8649;
  const grid93Circles = [];
  
  // Create all 8649 circles
  for (let i = 0; i < totalDots93; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-8649';
    grid93.appendChild(circle);
    grid93Circles.push(circle);
  }
  
  grid93Section.appendChild(grid93);
  
  // Add answer display
  const answerDisplay93 = document.createElement('div');
  answerDisplay93.className = 'answer-display';
  answerDisplay93.dataset.answer = '8649';
  grid93Section.appendChild(answerDisplay93);
  
  // Click handler for 93×93 grid
  let clickCount93 = 0;
  
  grid93.addEventListener('click', () => {
    if (clickCount93 === 0) {
      // First click: Fill 8000 pink dots from the bottom row upward, leaving:
      // - 7×7 square: rows 0-6, cols 86-92 (49 dots) in top right corner
      // - 20×30 rectangle: rows 0-19, cols 56-85 (600 dots) to the left of the 7×7
      // Total remaining: 649 black dots
      // Digit-based coloring: 8000 = first digit 8 = pink
      const colorFor8000 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      // Define the black regions that should remain black
      const square7x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const square7x7Cols = [86, 87, 88, 89, 90, 91, 92];
      const rectangle20x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x30Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      const blackIndices = new Set();
      
      // Add 7×7 square indices
      for (let row of square7x7Rows) {
        for (let col of square7x7Cols) {
          blackIndices.add(row * gridSize93 + col);
        }
      }
      
      // Add 20×30 rectangle indices
      for (let row of rectangle20x30Rows) {
        for (let col of rectangle20x30Cols) {
          blackIndices.add(row * gridSize93 + col);
        }
      }
      
      // Fill all dots pink except the black regions
      let pinkCount = 0;
      for (let i = 0; i < totalDots93; i++) {
        if (!blackIndices.has(i)) {
          grid93Circles[i].classList.remove(...COLOR_CLASSES);
          grid93Circles[i].classList.add(colorFor8000);
          pinkCount++;
        }
      }
      
      speakNumber(8000);
      clickCount93 = 1;
      
      // Show answer
      const answerDisplay93 = grid93Section.querySelector('.answer-display');
      if (answerDisplay93) {
        answerDisplay93.textContent = '8649';
        answerDisplay93.classList.add('show');
      }
    } else if (clickCount93 === 1) {
      // Second click: Fill the 20×30 rectangle with purple (600 dots)
      // Digit-based coloring: 600 = first digit 6 = purple
      const rectangle20x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x30Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85];
      
      const colorFor600 = COLOR_MAP[6] || 'purple'; // 6 = purple
      
      for (let row of rectangle20x30Rows) {
        for (let col of rectangle20x30Cols) {
          const idx = row * gridSize93 + col;
          grid93Circles[idx].classList.remove(...COLOR_CLASSES);
          grid93Circles[idx].classList.add(colorFor600);
        }
      }
      
      speakNumber(8600); // 8000 + 600 = 8600 dots filled
      clickCount93 = 2;
    } else if (clickCount93 === 2) {
      // Third click: Fill 40 dots in the 7×7 square with green, leaving a 3×3 square (9 dots) in the top right corner
      // Digit-based coloring: 40 = first digit 4 = green
      const square7x7Rows = [0, 1, 2, 3, 4, 5, 6];
      const square7x7Cols = [86, 87, 88, 89, 90, 91, 92];
      
      const colorFor40 = COLOR_MAP[4] || 'green'; // 4 = green
      
      // Top right 3×3 square: rows 0-2, cols 90-92 (9 dots) should remain black
      const topRight3x3Indices = new Set([
        0 * gridSize93 + 90, 0 * gridSize93 + 91, 0 * gridSize93 + 92,
        1 * gridSize93 + 90, 1 * gridSize93 + 91, 1 * gridSize93 + 92,
        2 * gridSize93 + 90, 2 * gridSize93 + 91, 2 * gridSize93 + 92
      ]);
      
      // Fill all dots in the 7×7 square except the top right 3×3
      let greenFilled = 0;
      for (let row of square7x7Rows) {
        for (let col of square7x7Cols) {
          const idx = row * gridSize93 + col;
          if (!topRight3x3Indices.has(idx) && greenFilled < 40) {
            grid93Circles[idx].classList.remove(...COLOR_CLASSES);
            grid93Circles[idx].classList.add(colorFor40);
            greenFilled++;
          }
        }
      }
      
      speakNumber(8640); // 8000 + 600 + 40 = 8640 dots filled
      clickCount93 = 3;
    } else if (clickCount93 === 3) {
      // Fourth click: Fill the 3×3 square (9 dots) in the top right corner with sky blue
      // Digit-based coloring: 9 = sky blue
      const topRight3x3Rows = [0, 1, 2];
      const topRight3x3Cols = [90, 91, 92];
      
      const colorFor9 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      for (let row of topRight3x3Rows) {
        for (let col of topRight3x3Cols) {
          const idx = row * gridSize93 + col;
          grid93Circles[idx].classList.remove(...COLOR_CLASSES);
          grid93Circles[idx].classList.add(colorFor9);
        }
      }
      
      speakNumber(8649); // All 8649 dots filled
      clickCount93 = 4;
      
      // Show answer
      const answerDisplay93 = grid93Section.querySelector('.answer-display');
      if (answerDisplay93) {
        answerDisplay93.textContent = '8649';
        answerDisplay93.classList.add('show');
      }
    } else {
      // Reset
      grid93Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount93 = 0;
      const answerDisplay93 = grid93Section.querySelector('.answer-display');
      if (answerDisplay93) {
        answerDisplay93.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid93Section);
  
  // Create 94×94 grid (8836 dots) with special click behavior
  const grid94Section = document.createElement('section');
  grid94Section.className = 'set';
  grid94Section.style.marginBottom = '40px';
  grid94Section.id = 'square-8836';
  
  const h2_94 = document.createElement('h2');
  h2_94.textContent = '94²';
  grid94Section.appendChild(h2_94);
  
  const grid94 = document.createElement('div');
  grid94.className = 'grid-dynamic grid-8836';
  grid94.id = 'square-8836';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid94.style.gridTemplateColumns = 'repeat(94, calc(var(--circle-total) * 13 / 94))';
  grid94.style.gridTemplateRows = 'repeat(94, calc(var(--circle-total) * 13 / 94))';
  grid94.style.width = 'calc(var(--circle-total) * 13)';
  grid94.style.height = 'calc(var(--circle-total) * 13)';
  grid94.style.position = 'relative';
  
  const gridSize94 = 94;
  const totalDots94 = 8836;
  const grid94Circles = [];
  
  // Create all 8836 circles
  for (let i = 0; i < totalDots94; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-8836';
    grid94.appendChild(circle);
    grid94Circles.push(circle);
  }
  
  grid94Section.appendChild(grid94);
  
  // Add answer display
  const answerDisplay94 = document.createElement('div');
  answerDisplay94.className = 'answer-display';
  answerDisplay94.dataset.answer = '8836';
  grid94Section.appendChild(answerDisplay94);
  
  // Click handler for 94×94 grid
  let clickCount94 = 0;
  
  grid94.addEventListener('click', () => {
    if (clickCount94 === 0) {
      // First click: Fill 8000 pink dots from the bottom row upward, leaving:
      // - 6×6 square: rows 0-5, cols 88-93 (36 dots) in top right corner
      // - 25×32 rectangle: rows 0-24, cols 56-87 (800 dots) to the left of the 6×6
      // Total remaining: 836 black dots
      // Digit-based coloring: 8000 = first digit 8 = pink
      const colorFor8000 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      // Define the black regions that should remain black
      const square6x6Rows = [0, 1, 2, 3, 4, 5];
      const square6x6Cols = [88, 89, 90, 91, 92, 93];
      const rectangle25x32Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
      const rectangle25x32Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87];
      
      const blackIndices = new Set();
      
      // Add 6×6 square indices
      for (let row of square6x6Rows) {
        for (let col of square6x6Cols) {
          blackIndices.add(row * gridSize94 + col);
        }
      }
      
      // Add 25×32 rectangle indices
      for (let row of rectangle25x32Rows) {
        for (let col of rectangle25x32Cols) {
          blackIndices.add(row * gridSize94 + col);
        }
      }
      
      // Fill all dots pink except the black regions
      let pinkCount = 0;
      for (let i = 0; i < totalDots94; i++) {
        if (!blackIndices.has(i)) {
          grid94Circles[i].classList.remove(...COLOR_CLASSES);
          grid94Circles[i].classList.add(colorFor8000);
          pinkCount++;
        }
      }
      
      speakNumber(8000);
      clickCount94 = 1;
      
      // Show answer
      const answerDisplay94 = grid94Section.querySelector('.answer-display');
      if (answerDisplay94) {
        answerDisplay94.textContent = '8836';
        answerDisplay94.classList.add('show');
      }
    } else if (clickCount94 === 1) {
      // Second click: Move the 25×32 rectangle up and fill it with pink (800 dots)
      // Digit-based coloring: 800 = first digit 8 = pink
      const rectangle25x32Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
      const rectangle25x32Cols = [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87];
      
      const colorFor800 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      // Find all black dots in the 25×32 rectangle
      const blackDots25x32 = [];
      for (let row of rectangle25x32Rows) {
        for (let col of rectangle25x32Cols) {
          const idx = row * gridSize94 + col;
          const circle = grid94Circles[idx];
          // Check if this dot is black (not pink)
          if (!circle.classList.contains('pink')) {
            blackDots25x32.push({ row: row, col: col, idx: idx });
          }
        }
      }
      
      // Move all dots up by half a dot distance and fill them pink
      for (let dot of blackDots25x32) {
        const circle = grid94Circles[dot.idx];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Create a new separated circle positioned half a dot up and fill it pink
        const separatedCircle = document.createElement('div');
        separatedCircle.className = 'circle circle-8836';
        separatedCircle.classList.add(colorFor800); // Fill pink
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = dot.row;
        separatedCircle.dataset.originalCol = dot.col;
        separatedCircle.dataset.originalIdx = dot.idx;
        
        // Position half a dot distance up (no rightward movement)
        // Use scaled circle size variable for 94×94 grid
        separatedCircle.style.top = `calc(var(--circle-total-8836) * ${dot.row} - var(--circle-total-8836) * 0.5)`;
        separatedCircle.style.left = `calc(var(--circle-total-8836) * ${dot.col})`;
        
        grid94.appendChild(separatedCircle);
      }
      
      speakNumber(8800); // 8000 + 800 = 8800 dots filled
      clickCount94 = 2;
    } else if (clickCount94 === 2) {
      // Third click: Fill 30 dots in the 6×6 square with orange, leaving:
      // - Top row: 3 black dots on the right (cols 91-93)
      // - Second row: 2 black dots on the right (cols 92-93)
      // - Third row: 1 black dot on the right (col 93)
      // Total: 6 black dots remaining
      // Digit-based coloring: 30 = first digit 3 = orange
      const square6x6Rows = [0, 1, 2, 3, 4, 5];
      const square6x6Cols = [88, 89, 90, 91, 92, 93];
      
      const colorFor30 = COLOR_MAP[3] || 'orange'; // 3 = orange
      
      // Triangle pattern in top right corner (6 dots)
      const triangleIndices = new Set([
        0 * gridSize94 + 91, 0 * gridSize94 + 92, 0 * gridSize94 + 93, // Top row: 3 dots
        1 * gridSize94 + 92, 1 * gridSize94 + 93, // Second row: 2 dots
        2 * gridSize94 + 93  // Third row: 1 dot
      ]);
      
      // Fill all dots in the 6×6 square except the triangle pattern
      let orangeFilled = 0;
      for (let row of square6x6Rows) {
        for (let col of square6x6Cols) {
          const idx = row * gridSize94 + col;
          if (!triangleIndices.has(idx) && orangeFilled < 30) {
            grid94Circles[idx].classList.remove(...COLOR_CLASSES);
            grid94Circles[idx].classList.add(colorFor30);
            orangeFilled++;
          }
        }
      }
      
      speakNumber(8830); // 8000 + 800 + 30 = 8830 dots filled
      clickCount94 = 3;
    } else if (clickCount94 === 3) {
      // Fourth click: Fill the 6 black dots (triangle pattern) with purple
      // Digit-based coloring: 6 = purple
      const triangleIndices = [
        0 * gridSize94 + 91, 0 * gridSize94 + 92, 0 * gridSize94 + 93, // Top row: 3 dots
        1 * gridSize94 + 92, 1 * gridSize94 + 93, // Second row: 2 dots
        2 * gridSize94 + 93  // Third row: 1 dot
      ];
      
      const colorFor6 = COLOR_MAP[6] || 'purple'; // 6 = purple
      
      for (let idx of triangleIndices) {
        grid94Circles[idx].classList.remove(...COLOR_CLASSES);
        grid94Circles[idx].classList.add(colorFor6);
      }
      
      speakNumber(8836); // All 8836 dots filled
      clickCount94 = 4;
      
      // Show answer
      const answerDisplay94 = grid94Section.querySelector('.answer-display');
      if (answerDisplay94) {
        answerDisplay94.textContent = '8836';
        answerDisplay94.classList.add('show');
      }
    } else {
      // Reset
      // Remove all separated circles
      const allSeparated = grid94.querySelectorAll('[data-original-row][data-original-col]');
      allSeparated.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      
      // Reset visibility and colors
      grid94Circles.forEach(circle => {
        circle.style.visibility = '';
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount94 = 0;
      const answerDisplay94 = grid94Section.querySelector('.answer-display');
      if (answerDisplay94) {
        answerDisplay94.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid94Section);
  
  // Create 95×95 grid (9025 dots) with special click behavior
  const grid95Section = document.createElement('section');
  grid95Section.className = 'set';
  grid95Section.style.marginBottom = '40px';
  grid95Section.id = 'square-9025';
  
  const h2_95 = document.createElement('h2');
  h2_95.textContent = '95²';
  grid95Section.appendChild(h2_95);
  
  const grid95 = document.createElement('div');
  grid95.className = 'grid-dynamic grid-9025';
  grid95.id = 'square-9025';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid95.style.gridTemplateColumns = 'repeat(95, calc(var(--circle-total) * 13 / 95))';
  grid95.style.gridTemplateRows = 'repeat(95, calc(var(--circle-total) * 13 / 95))';
  grid95.style.width = 'calc(var(--circle-total) * 13)';
  grid95.style.height = 'calc(var(--circle-total) * 13)';
  grid95.style.position = 'relative';
  
  const gridSize95 = 95;
  const totalDots95 = 9025;
  const grid95Circles = [];
  
  // Create all 9025 circles
  for (let i = 0; i < totalDots95; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-9025';
    grid95.appendChild(circle);
    grid95Circles.push(circle);
  }
  
  grid95Section.appendChild(grid95);
  
  // Add answer display
  const answerDisplay95 = document.createElement('div');
  answerDisplay95.className = 'answer-display';
  answerDisplay95.dataset.answer = '9025';
  grid95Section.appendChild(answerDisplay95);
  
  // Click handler for 95×95 grid
  let clickCount95 = 0;
  
  grid95.addEventListener('click', () => {
    if (clickCount95 === 0) {
      // First click: Fill 9000 sky blue dots from the bottom row upward, leaving:
      // - 5×5 square: rows 0-4, cols 90-94 (25 dots) in top right corner
      // Total remaining: 25 black dots
      // Digit-based coloring: 9000 = first digit 9 = sky blue
      const colorFor9000 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      // Define the black region that should remain black
      const square5x5Rows = [0, 1, 2, 3, 4];
      const square5x5Cols = [90, 91, 92, 93, 94];
      
      const blackIndices = new Set();
      
      // Add 5×5 square indices
      for (let row of square5x5Rows) {
        for (let col of square5x5Cols) {
          blackIndices.add(row * gridSize95 + col);
        }
      }
      
      // Fill all dots sky blue except the black region
      let skyCount = 0;
      for (let i = 0; i < totalDots95; i++) {
        if (!blackIndices.has(i)) {
          grid95Circles[i].classList.remove(...COLOR_CLASSES);
          grid95Circles[i].classList.add(colorFor9000);
          skyCount++;
        }
      }
      
      speakNumber(9000);
      clickCount95 = 1;
      
      // Show answer
      const answerDisplay95 = grid95Section.querySelector('.answer-display');
      if (answerDisplay95) {
        answerDisplay95.textContent = '9025';
        answerDisplay95.classList.add('show');
      }
    } else if (clickCount95 === 1) {
      // Second click: Fill 20 dots in the 5×5 square with orange, leaving the last column (5 dots) black
      // Digit-based coloring: 20 = first digit 2 = orange
      const square5x5Rows = [0, 1, 2, 3, 4];
      const square5x5Cols = [90, 91, 92, 93, 94];
      
      const colorFor20 = COLOR_MAP[2] || 'orange'; // 2 = orange
      
      // Last column: col 94 should remain black
      const lastColumnCol = 94;
      
      // Fill all dots in the 5×5 square except the last column
      for (let row of square5x5Rows) {
        for (let col of square5x5Cols) {
          if (col !== lastColumnCol) {
            const idx = row * gridSize95 + col;
            grid95Circles[idx].classList.remove(...COLOR_CLASSES);
            grid95Circles[idx].classList.add(colorFor20);
          }
        }
      }
      
      speakNumber(9020); // 9000 + 20 = 9020 dots filled
      clickCount95 = 2;
    } else if (clickCount95 === 2) {
      // Third click: Fill the last 5 black dots (last column) with blue
      // Digit-based coloring: 5 = blue
      const square5x5Rows = [0, 1, 2, 3, 4];
      const lastColumnCol = 94;
      
      const colorFor5 = COLOR_MAP[5] || 'blue'; // 5 = blue
      
      // Fill the last column (5 dots)
      for (let row of square5x5Rows) {
        const idx = row * gridSize95 + lastColumnCol;
        grid95Circles[idx].classList.remove(...COLOR_CLASSES);
        grid95Circles[idx].classList.add(colorFor5);
      }
      
      speakNumber(9025); // All 9025 dots filled
      clickCount95 = 3;
      
      // Show answer
      const answerDisplay95 = grid95Section.querySelector('.answer-display');
      if (answerDisplay95) {
        answerDisplay95.textContent = '9025';
        answerDisplay95.classList.add('show');
      }
    } else {
      // Reset
      grid95Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount95 = 0;
      const answerDisplay95 = grid95Section.querySelector('.answer-display');
      if (answerDisplay95) {
        answerDisplay95.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid95Section);
  
  // Create 96×96 grid (9216 dots) with special click behavior
  const grid96Section = document.createElement('section');
  grid96Section.className = 'set';
  grid96Section.style.marginBottom = '40px';
  grid96Section.id = 'square-9216';
  
  const h2_96 = document.createElement('h2');
  h2_96.textContent = '96²';
  grid96Section.appendChild(h2_96);
  
  const grid96 = document.createElement('div');
  grid96.className = 'grid-dynamic grid-9216';
  grid96.id = 'square-9216';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid96.style.gridTemplateColumns = 'repeat(96, calc(var(--circle-total) * 13 / 96))';
  grid96.style.gridTemplateRows = 'repeat(96, calc(var(--circle-total) * 13 / 96))';
  grid96.style.width = 'calc(var(--circle-total) * 13)';
  grid96.style.height = 'calc(var(--circle-total) * 13)';
  grid96.style.position = 'relative';
  
  const gridSize96 = 96;
  const totalDots96 = 9216;
  const grid96Circles = [];
  
  // Create all 9216 circles
  for (let i = 0; i < totalDots96; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-9216';
    grid96.appendChild(circle);
    grid96Circles.push(circle);
  }
  
  grid96Section.appendChild(grid96);
  
  // Add answer display
  const answerDisplay96 = document.createElement('div');
  answerDisplay96.className = 'answer-display';
  answerDisplay96.dataset.answer = '9216';
  grid96Section.appendChild(answerDisplay96);
  
  // Click handler for 96×96 grid
  let clickCount96 = 0;
  
  grid96.addEventListener('click', () => {
    if (clickCount96 === 0) {
      // First click: Fill 9000 sky blue dots from the bottom row upward, leaving:
      // - 4×4 square: rows 0-3, cols 92-95 (16 dots) in top right corner
      // - 20×10 rectangle: rows 0-19, cols 82-91 (200 dots) to the left of the 4×4
      // Total remaining: 216 black dots
      // Digit-based coloring: 9000 = first digit 9 = sky blue
      const colorFor9000 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      // Define the black regions that should remain black
      const square4x4Rows = [0, 1, 2, 3];
      const square4x4Cols = [92, 93, 94, 95];
      const rectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x10Cols = [82, 83, 84, 85, 86, 87, 88, 89, 90, 91];
      
      const blackIndices = new Set();
      
      // Add 4×4 square indices
      for (let row of square4x4Rows) {
        for (let col of square4x4Cols) {
          blackIndices.add(row * gridSize96 + col);
        }
      }
      
      // Add 20×10 rectangle indices
      for (let row of rectangle20x10Rows) {
        for (let col of rectangle20x10Cols) {
          blackIndices.add(row * gridSize96 + col);
        }
      }
      
      // Fill all dots sky blue except the black regions
      let skyCount = 0;
      for (let i = 0; i < totalDots96; i++) {
        if (!blackIndices.has(i)) {
          grid96Circles[i].classList.remove(...COLOR_CLASSES);
          grid96Circles[i].classList.add(colorFor9000);
          skyCount++;
        }
      }
      
      speakNumber(9000);
      clickCount96 = 1;
      
      // Show answer
      const answerDisplay96 = grid96Section.querySelector('.answer-display');
      if (answerDisplay96) {
        answerDisplay96.textContent = '9216';
        answerDisplay96.classList.add('show');
      }
    } else if (clickCount96 === 1) {
      // Second click: Fill the 20×10 rectangle with orange (200 dots)
      // Digit-based coloring: 200 = first digit 2 = orange
      const rectangle20x10Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x10Cols = [82, 83, 84, 85, 86, 87, 88, 89, 90, 91];
      
      const colorFor200 = COLOR_MAP[2] || 'orange'; // 2 = orange
      
      for (let row of rectangle20x10Rows) {
        for (let col of rectangle20x10Cols) {
          const idx = row * gridSize96 + col;
          grid96Circles[idx].classList.remove(...COLOR_CLASSES);
          grid96Circles[idx].classList.add(colorFor200);
        }
      }
      
      speakNumber(9200); // 9000 + 200 = 9200 dots filled
      clickCount96 = 2;
    } else if (clickCount96 === 2) {
      // Third click: Fill 10 dots in the 4×4 square with red, leaving 6 dots in triangle pattern black
      // Digit-based coloring: 10 = first digit 1 = red
      const square4x4Rows = [0, 1, 2, 3];
      const square4x4Cols = [92, 93, 94, 95];
      
      const colorFor10 = COLOR_MAP[1] || 'red'; // 1 = red
      
      // Triangle pattern in top right corner of 4×4 square (6 dots):
      // Row 0: cols 93, 94, 95 (3 dots)
      // Row 1: cols 94, 95 (2 dots)
      // Row 2: col 95 (1 dot)
      const triangleIndices = new Set([
        0 * gridSize96 + 93, 0 * gridSize96 + 94, 0 * gridSize96 + 95, // Top row: 3 dots
        1 * gridSize96 + 94, 1 * gridSize96 + 95, // Second row: 2 dots
        2 * gridSize96 + 95  // Third row: 1 dot
      ]);
      
      // Fill 10 dots with red (excluding the triangle pattern)
      let redFilled = 0;
      for (let row of square4x4Rows) {
        for (let col of square4x4Cols) {
          const idx = row * gridSize96 + col;
          if (!triangleIndices.has(idx) && redFilled < 10) {
            grid96Circles[idx].classList.remove(...COLOR_CLASSES);
            grid96Circles[idx].classList.add(colorFor10);
            redFilled++;
          }
        }
      }
      
      speakNumber(9210); // 9000 + 200 + 10 = 9210 dots filled
      clickCount96 = 3;
    } else if (clickCount96 === 3) {
      // Fourth click: Fill the 6 dots in triangle pattern with purple
      // Digit-based coloring: 6 = purple
      const colorFor6 = COLOR_MAP[6] || 'purple'; // 6 = purple
      
      // Triangle pattern in top right corner of 4×4 square (6 dots):
      const triangleIndices = [
        0 * gridSize96 + 93, 0 * gridSize96 + 94, 0 * gridSize96 + 95, // Top row: 3 dots
        1 * gridSize96 + 94, 1 * gridSize96 + 95, // Second row: 2 dots
        2 * gridSize96 + 95  // Third row: 1 dot
      ];
      
      // Fill the 6 dots in triangle pattern with purple
      for (let idx of triangleIndices) {
        grid96Circles[idx].classList.remove(...COLOR_CLASSES);
        grid96Circles[idx].classList.add(colorFor6);
      }
      
      speakNumber(9216); // All 9216 dots filled
      clickCount96 = 4;
      
      // Show answer
      const answerDisplay96 = grid96Section.querySelector('.answer-display');
      if (answerDisplay96) {
        answerDisplay96.textContent = '9216';
        answerDisplay96.classList.add('show');
      }
    } else {
      // Reset
      grid96Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount96 = 0;
      const answerDisplay96 = grid96Section.querySelector('.answer-display');
      if (answerDisplay96) {
        answerDisplay96.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid96Section);
  
  // Create 97×97 grid (9409 dots) with special click behavior
  const grid97Section = document.createElement('section');
  grid97Section.className = 'set';
  grid97Section.style.marginBottom = '40px';
  grid97Section.id = 'square-9409';
  
  const h2_97 = document.createElement('h2');
  h2_97.textContent = '97²';
  grid97Section.appendChild(h2_97);
  
  const grid97 = document.createElement('div');
  grid97.className = 'grid-dynamic grid-9409';
  grid97.id = 'square-9409';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid97.style.gridTemplateColumns = 'repeat(97, calc(var(--circle-total) * 13 / 97))';
  grid97.style.gridTemplateRows = 'repeat(97, calc(var(--circle-total) * 13 / 97))';
  grid97.style.width = 'calc(var(--circle-total) * 13)';
  grid97.style.height = 'calc(var(--circle-total) * 13)';
  grid97.style.position = 'relative';
  
  const gridSize97 = 97;
  const totalDots97 = 9409;
  const grid97Circles = [];
  
  // Create all 9409 circles
  for (let i = 0; i < totalDots97; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-9409';
    grid97.appendChild(circle);
    grid97Circles.push(circle);
  }
  
  grid97Section.appendChild(grid97);
  
  // Add answer display
  const answerDisplay97 = document.createElement('div');
  answerDisplay97.className = 'answer-display';
  answerDisplay97.dataset.answer = '9409';
  grid97Section.appendChild(answerDisplay97);
  
  // Click handler for 97×97 grid
  let clickCount97 = 0;
  
  grid97.addEventListener('click', () => {
    if (clickCount97 === 0) {
      // First click: Fill 9000 sky blue dots from the bottom row upward, leaving:
      // - 3×3 square: rows 0-2, cols 94-96 (9 dots) in top right corner
      // - 20×20 square: rows 0-19, cols 74-93 (400 dots) to the left of the 3×3
      // Total remaining: 409 black dots
      // Digit-based coloring: 9000 = first digit 9 = sky blue
      const colorFor9000 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      // Define the black regions that should remain black
      const square3x3Rows = [0, 1, 2];
      const square3x3Cols = [94, 95, 96];
      const square20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const square20x20Cols = [74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93];
      
      const blackIndices = new Set();
      
      // Add 3×3 square indices
      for (let row of square3x3Rows) {
        for (let col of square3x3Cols) {
          blackIndices.add(row * gridSize97 + col);
        }
      }
      
      // Add 20×20 square indices
      for (let row of square20x20Rows) {
        for (let col of square20x20Cols) {
          blackIndices.add(row * gridSize97 + col);
        }
      }
      
      // Fill all dots sky blue except the black regions
      let skyCount = 0;
      for (let i = 0; i < totalDots97; i++) {
        if (!blackIndices.has(i)) {
          grid97Circles[i].classList.remove(...COLOR_CLASSES);
          grid97Circles[i].classList.add(colorFor9000);
          skyCount++;
        }
      }
      
      speakNumber(9000);
      clickCount97 = 1;
      
      // Show answer
      const answerDisplay97 = grid97Section.querySelector('.answer-display');
      if (answerDisplay97) {
        answerDisplay97.textContent = '9409';
        answerDisplay97.classList.add('show');
      }
    } else if (clickCount97 === 1) {
      // Second click: Fill the 20×20 square with green (400 dots)
      // Digit-based coloring: 400 = first digit 4 = green
      const square20x20Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const square20x20Cols = [74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93];
      
      const colorFor400 = COLOR_MAP[4] || 'green'; // 4 = green
      
      for (let row of square20x20Rows) {
        for (let col of square20x20Cols) {
          const idx = row * gridSize97 + col;
          grid97Circles[idx].classList.remove(...COLOR_CLASSES);
          grid97Circles[idx].classList.add(colorFor400);
        }
      }
      
      speakNumber(9400); // 9000 + 400 = 9400 dots filled
      clickCount97 = 2;
    } else if (clickCount97 === 2) {
      // Third click: Move the 3×3 square up and fill it with sky blue
      // Digit-based coloring: 9 = sky blue
      const square3x3Rows = [0, 1, 2];
      const square3x3Cols = [94, 95, 96];
      
      const colorFor9 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      // Find all black dots in the 3×3 square
      const blackDots3x3 = [];
      for (let row of square3x3Rows) {
        for (let col of square3x3Cols) {
          const idx = row * gridSize97 + col;
          const circle = grid97Circles[idx];
          // Check if this dot is black (not sky blue or green)
          if (!circle.classList.contains('sky') && !circle.classList.contains('green')) {
            blackDots3x3.push({ row: row, col: col, idx: idx });
          }
        }
      }
      
      // Move all dots up by half a dot distance and fill them sky blue
      for (let dot of blackDots3x3) {
        const circle = grid97Circles[dot.idx];
        
        // Hide the original circle
        circle.style.visibility = 'hidden';
        
        // Create a new separated circle positioned half a dot up and fill it sky blue
        const separatedCircle = document.createElement('div');
        separatedCircle.className = 'circle circle-9409';
        separatedCircle.classList.add(colorFor9); // Fill sky blue
        separatedCircle.style.position = 'absolute';
        separatedCircle.style.zIndex = '5';
        separatedCircle.dataset.originalRow = dot.row;
        separatedCircle.dataset.originalCol = dot.col;
        separatedCircle.dataset.originalIdx = dot.idx;
        
        // Position half a dot distance up (no rightward movement)
        // Use scaled circle size variable for 97×97 grid
        separatedCircle.style.top = `calc(var(--circle-total-9409) * ${dot.row} - var(--circle-total-9409) * 0.5)`;
        separatedCircle.style.left = `calc(var(--circle-total-9409) * ${dot.col})`;
        
        grid97.appendChild(separatedCircle);
      }
      
      speakNumber(9409); // All 9409 dots filled
      clickCount97 = 3;
      
      // Show answer
      const answerDisplay97 = grid97Section.querySelector('.answer-display');
      if (answerDisplay97) {
        answerDisplay97.textContent = '9409';
        answerDisplay97.classList.add('show');
      }
    } else {
      // Reset
      // Remove all separated circles
      const allSeparated = grid97.querySelectorAll('[data-original-row][data-original-col]');
      allSeparated.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      
      // Reset visibility and colors
      grid97Circles.forEach(circle => {
        circle.style.visibility = '';
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount97 = 0;
      const answerDisplay97 = grid97Section.querySelector('.answer-display');
      if (answerDisplay97) {
        answerDisplay97.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid97Section);
  
  // Create 98×98 grid (9604 dots) with special click behavior
  const grid98Section = document.createElement('section');
  grid98Section.className = 'set';
  grid98Section.style.marginBottom = '40px';
  grid98Section.id = 'square-9604';
  
  const h2_98 = document.createElement('h2');
  h2_98.textContent = '98²';
  grid98Section.appendChild(h2_98);
  
  const grid98 = document.createElement('div');
  grid98.className = 'grid-dynamic grid-9604';
  grid98.id = 'square-9604';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid98.style.gridTemplateColumns = 'repeat(98, calc(var(--circle-total) * 13 / 98))';
  grid98.style.gridTemplateRows = 'repeat(98, calc(var(--circle-total) * 13 / 98))';
  grid98.style.width = 'calc(var(--circle-total) * 13)';
  grid98.style.height = 'calc(var(--circle-total) * 13)';
  grid98.style.position = 'relative';
  
  const gridSize98 = 98;
  const totalDots98 = 9604;
  const grid98Circles = [];
  
  // Create all 9604 circles with numbers
  for (let i = 0; i < totalDots98; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-9604';
    
    // Calculate dot number (right to left, row by row)
    const row = Math.floor(i / gridSize98);
    const col = i % gridSize98;
    const dotNumber = row * gridSize98 + (gridSize98 - col);
    
    // Create and add number span
    const numberSpan = document.createElement('span');
    numberSpan.className = 'circle-number';
    numberSpan.textContent = dotNumber.toString();
    circle.appendChild(numberSpan);
    circle.dataset.dotNumber = dotNumber.toString();
    
    grid98.appendChild(circle);
    grid98Circles.push(circle);
  }
  
  grid98Section.appendChild(grid98);
  
  // Add answer display
  const answerDisplay98 = document.createElement('div');
  answerDisplay98.className = 'answer-display';
  answerDisplay98.dataset.answer = '9604';
  grid98Section.appendChild(answerDisplay98);
  
  // Click handler for 98×98 grid
  let clickCount98 = 0;
  
  grid98.addEventListener('click', () => {
    if (clickCount98 === 0) {
      // First click: Fill 9000 sky blue dots from the bottom row upward, leaving:
      // - 2×2 square: rows 0-1, cols 96-97 (4 dots) in top right corner
      // - 20×30 rectangle: rows 0-19, cols 66-95 (600 dots) to the left of the 2×2
      // Total remaining: 604 black dots
      // Digit-based coloring: 9000 = first digit 9 = sky blue
      const colorFor9000 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      // Define the black regions that should remain black
      const square2x2Rows = [0, 1];
      const square2x2Cols = [96, 97];
      const rectangle20x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x30Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95];
      
      const blackIndices = new Set();
      
      // Add 2×2 square indices
      for (let row of square2x2Rows) {
        for (let col of square2x2Cols) {
          blackIndices.add(row * gridSize98 + col);
        }
      }
      
      // Add 20×30 rectangle indices
      for (let row of rectangle20x30Rows) {
        for (let col of rectangle20x30Cols) {
          blackIndices.add(row * gridSize98 + col);
        }
      }
      
      // Fill all dots sky blue except the black regions
      let skyCount = 0;
      for (let i = 0; i < totalDots98; i++) {
        if (!blackIndices.has(i)) {
          grid98Circles[i].classList.remove(...COLOR_CLASSES);
          grid98Circles[i].classList.add(colorFor9000);
          skyCount++;
        }
      }
      
      speakNumber(9000);
      clickCount98 = 1;
      
      // Show answer
      const answerDisplay98 = grid98Section.querySelector('.answer-display');
      if (answerDisplay98) {
        answerDisplay98.textContent = '9604';
        answerDisplay98.classList.add('show');
      }
    } else if (clickCount98 === 1) {
      // Second click: Fill the 20×30 rectangle with purple (600 dots)
      // Digit-based coloring: 600 = first digit 6 = purple
      const rectangle20x30Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
      const rectangle20x30Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95];
      
      const colorFor600 = COLOR_MAP[6] || 'purple'; // 6 = purple
      
      for (let row of rectangle20x30Rows) {
        for (let col of rectangle20x30Cols) {
          const idx = row * gridSize98 + col;
          grid98Circles[idx].classList.remove(...COLOR_CLASSES);
          grid98Circles[idx].classList.add(colorFor600);
        }
      }
      
      speakNumber(9600); // 9000 + 600 = 9600 dots filled
      clickCount98 = 2;
    } else if (clickCount98 === 2) {
      // Third click: Fill the 2×2 square (4 dots) in the top right corner with green
      // Digit-based coloring: 4 = green
      const square2x2Rows = [0, 1];
      const square2x2Cols = [96, 97];
      
      const colorFor4 = COLOR_MAP[4] || 'green'; // 4 = green
      
      for (let row of square2x2Rows) {
        for (let col of square2x2Cols) {
          const idx = row * gridSize98 + col;
          grid98Circles[idx].classList.remove(...COLOR_CLASSES);
          grid98Circles[idx].classList.add(colorFor4);
        }
      }
      
      speakNumber(9604); // All 9604 dots filled
      clickCount98 = 3;
      
      // Show answer
      const answerDisplay98 = grid98Section.querySelector('.answer-display');
      if (answerDisplay98) {
        answerDisplay98.textContent = '9604';
        answerDisplay98.classList.add('show');
      }
    } else {
      // Reset
      grid98Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount98 = 0;
      const answerDisplay98 = grid98Section.querySelector('.answer-display');
      if (answerDisplay98) {
        answerDisplay98.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid98Section);
  
  // Create 99×99 grid (9801 dots) with special click behavior
  const grid99Section = document.createElement('section');
  grid99Section.className = 'set';
  grid99Section.style.marginBottom = '40px';
  grid99Section.id = 'square-9801';
  
  const h2_99 = document.createElement('h2');
  h2_99.textContent = '99²';
  grid99Section.appendChild(h2_99);
  
  const grid99 = document.createElement('div');
  grid99.className = 'grid-dynamic grid-9801';
  grid99.id = 'square-9801';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid99.style.gridTemplateColumns = 'repeat(99, calc(var(--circle-total) * 13 / 99))';
  grid99.style.gridTemplateRows = 'repeat(99, calc(var(--circle-total) * 13 / 99))';
  grid99.style.width = 'calc(var(--circle-total) * 13)';
  grid99.style.height = 'calc(var(--circle-total) * 13)';
  grid99.style.position = 'relative';
  
  const gridSize99 = 99;
  const totalDots99 = 9801;
  const grid99Circles = [];
  
  // Create all 9801 circles with numbers
  for (let i = 0; i < totalDots99; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-9801';
    
    // Calculate dot number (right to left, row by row)
    const row = Math.floor(i / gridSize99);
    const col = i % gridSize99;
    const dotNumber = row * gridSize99 + (gridSize99 - col);
    
    // Create and add number span
    const numberSpan = document.createElement('span');
    numberSpan.className = 'circle-number';
    numberSpan.textContent = dotNumber.toString();
    circle.appendChild(numberSpan);
    circle.dataset.dotNumber = dotNumber.toString();
    
    grid99.appendChild(circle);
    grid99Circles.push(circle);
  }
  
  grid99Section.appendChild(grid99);
  
  // Add answer display
  const answerDisplay99 = document.createElement('div');
  answerDisplay99.className = 'answer-display';
  answerDisplay99.dataset.answer = '9801';
  grid99Section.appendChild(answerDisplay99);
  
  // Click handler for 99×99 grid
  let clickCount99 = 0;
  
  grid99.addEventListener('click', () => {
    if (clickCount99 === 0) {
      // First click: Fill 9000 sky blue dots from the bottom row upward, leaving:
      // - 1 dot: row 0, col 98 (1 dot) in top right corner
      // - 25×32 rectangle: rows 0-24, cols 66-97 (800 dots) to the left of the single dot
      // Total remaining: 801 black dots
      // Digit-based coloring: 9000 = first digit 9 = sky blue
      const colorFor9000 = COLOR_MAP[9] || 'sky'; // 9 = sky blue
      
      // Define the black regions that should remain black
      const topRightDotIndex = 0 * gridSize99 + 98; // Row 0, col 98
      const rectangle25x32Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
      const rectangle25x32Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97];
      
      const blackIndices = new Set();
      
      // Add top right dot index
      blackIndices.add(topRightDotIndex);
      
      // Add 25×32 rectangle indices
      for (let row of rectangle25x32Rows) {
        for (let col of rectangle25x32Cols) {
          blackIndices.add(row * gridSize99 + col);
        }
      }
      
      // Fill all dots sky blue except the black regions
      let skyCount = 0;
      for (let i = 0; i < totalDots99; i++) {
        if (!blackIndices.has(i)) {
          grid99Circles[i].classList.remove(...COLOR_CLASSES);
          grid99Circles[i].classList.add(colorFor9000);
          skyCount++;
        }
      }
      
      speakNumber(9000);
      clickCount99 = 1;
      
      // Show answer
      const answerDisplay99 = grid99Section.querySelector('.answer-display');
      if (answerDisplay99) {
        answerDisplay99.textContent = '9801';
        answerDisplay99.classList.add('show');
      }
    } else if (clickCount99 === 1) {
      // Second click: Fill the 25×32 rectangle with pink (800 dots)
      // Digit-based coloring: 800 = first digit 8 = pink
      const rectangle25x32Rows = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
      const rectangle25x32Cols = [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97];
      
      const colorFor800 = COLOR_MAP[8] || 'pink'; // 8 = pink
      
      for (let row of rectangle25x32Rows) {
        for (let col of rectangle25x32Cols) {
          const idx = row * gridSize99 + col;
          grid99Circles[idx].classList.remove(...COLOR_CLASSES);
          grid99Circles[idx].classList.add(colorFor800);
        }
      }
      
      speakNumber(9800); // 9000 + 800 = 9800 dots filled
      clickCount99 = 2;
    } else if (clickCount99 === 2) {
      // Third click: Fill the 1 dot in the top right corner with red
      // Digit-based coloring: 1 = red
      const topRightDotIndex = 0 * gridSize99 + 98; // Row 0, col 98
      const colorFor1 = COLOR_MAP[1] || 'red'; // 1 = red
      
      grid99Circles[topRightDotIndex].classList.remove(...COLOR_CLASSES);
      grid99Circles[topRightDotIndex].classList.add(colorFor1);
      
      speakNumber(9801); // All 9801 dots filled
      clickCount99 = 3;
      
      // Show answer
      const answerDisplay99 = grid99Section.querySelector('.answer-display');
      if (answerDisplay99) {
        answerDisplay99.textContent = '9801';
        answerDisplay99.classList.add('show');
      }
    } else {
      // Reset
      grid99Circles.forEach(circle => {
        circle.classList.remove(...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow');
      });
      speakNumber(0);
      clickCount99 = 0;
      const answerDisplay99 = grid99Section.querySelector('.answer-display');
      if (answerDisplay99) {
        answerDisplay99.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid99Section);
  
  // Create 100×100 grid (100² = 10000 dots) with special click behavior
  // 100 squared equals 10,000 total dots
  const grid100Section = document.createElement('section');
  grid100Section.className = 'set';
  grid100Section.style.marginBottom = '40px';
  grid100Section.id = 'square-10000';
  
  const h2_100 = document.createElement('h2');
  h2_100.textContent = '100²';
  grid100Section.appendChild(h2_100);
  
  const grid100 = document.createElement('div');
  grid100.className = 'grid-dynamic grid-10000';
  grid100.id = 'square-10000';
  // Scale down to same size as 13×13 grid (like other large squares)
  grid100.style.gridTemplateColumns = 'repeat(100, calc(var(--circle-total) * 13 / 100))';
  grid100.style.gridTemplateRows = 'repeat(100, calc(var(--circle-total) * 13 / 100))';
  grid100.style.width = 'calc(var(--circle-total) * 13)';
  grid100.style.height = 'calc(var(--circle-total) * 13)';
  grid100.style.position = 'relative';
  
  const gridSize100 = 100;
  const totalDots100 = 10000;
  const grid100Circles = [];
  
  // Create all 10000 circles with numbers
  for (let i = 0; i < totalDots100; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle circle-10000';
    
    // Calculate dot number (right to left, row by row)
    const row = Math.floor(i / gridSize100);
    const col = i % gridSize100;
    const dotNumber = row * gridSize100 + (gridSize100 - col);
    
    // Create and add number span
    const numberSpan = document.createElement('span');
    numberSpan.className = 'circle-number';
    numberSpan.textContent = dotNumber.toString();
    circle.appendChild(numberSpan);
    circle.dataset.dotNumber = dotNumber.toString();
    
    grid100.appendChild(circle);
    grid100Circles.push(circle);
  }
  
  grid100Section.appendChild(grid100);
  
  // Add answer display
  const answerDisplay100 = document.createElement('div');
  answerDisplay100.className = 'answer-display';
  answerDisplay100.dataset.answer = '10000';
  grid100Section.appendChild(answerDisplay100);
  
  // Click handler for 100×100 grid
  let clickCount100 = 0;
  
  grid100.addEventListener('click', () => {
    if (clickCount100 === 0) {
      // First click: Fill all 10000 dots with red
      // Digit-based coloring: 10000 = first digit 1 = red
      const colorFor10000 = COLOR_MAP[1] || 'red'; // 1 = red
      
      // Use optimized batch update for faster rendering
      fastFillPattern(grid100, gridSize100, { type: 'all' }, colorFor10000);
      
      speakNumber(10000);
      clickCount100 = 1;
      
      // Show answer
      const answerDisplay100 = grid100Section.querySelector('.answer-display');
      if (answerDisplay100) {
        answerDisplay100.textContent = '10000';
        answerDisplay100.classList.add('show');
      }
    } else {
      // Reset - use optimized batch update
      const allIndices = grid100Circles.map((_, i) => i);
      batchUpdateCircles(grid100Circles, allIndices, null, [...COLOR_CLASSES, 'blue', 'green', 'sky', 'purple', 'orange', 'brown', 'pink', 'red', 'yellow']);
      speakNumber(0);
      clickCount100 = 0;
      const answerDisplay100 = grid100Section.querySelector('.answer-display');
      if (answerDisplay100) {
        answerDisplay100.classList.remove('show');
      }
    }
  });
  
  moreSquaresContainer.appendChild(grid100Section);
  
  // With column-reverse, we need to reverse squares 53-100 so they appear sequentially
  // Squares 6-36 and 40-52 are already in reverse order, but 53-100 are in normal order
  const allSections = Array.from(moreSquaresContainer.querySelectorAll('section.set'));
  const squares53to100 = [];
  
  // Collect squares 53-100 by checking h2 text content (more reliable than dataset.square)
  for (let n = 53; n <= 100; n++) {
    const section = allSections.find(s => {
      const h2 = s.querySelector('h2');
      return h2 && h2.textContent === `${n}²`;
    });
    if (section) {
      squares53to100.push(section);
    }
  }
  
  // DON'T reverse squares 53-100 - keep them as is
  // We want 6² to be LAST in moreSquares DOM so it appears FIRST in moreSquares visually (right after 5²)
  // So we need to reverse ALL squares 6-100 so 6² is last
  // Collect all squares 6-100
  const allSquares6to100 = Array.from(moreSquaresContainer.querySelectorAll('section.set')).filter(section => {
    const h2 = section.querySelector('h2');
    if (!h2) return false;
    const match = h2.textContent.match(/^(\d+)²$/);
    if (!match) return false;
    const num = parseInt(match[1]);
    return num >= 6 && num <= 100;
  });
  
  // Sort by number
  allSquares6to100.sort((a, b) => {
    const aNum = parseInt(a.querySelector('h2').textContent.match(/^(\d+)²$/)[1]);
    const bNum = parseInt(b.querySelector('h2').textContent.match(/^(\d+)²$/)[1]);
    return aNum - bNum; // 6, 7, ..., 100
  });
  
  // Remove all and re-append in REVERSE order (100, 99, ..., 6) so 6² is last
  console.log('Found squares 6-100:', allSquares6to100.length, 'squares');
  if (allSquares6to100.length > 0) {
    allSquares6to100.reverse().forEach(section => {
      if (section && section.parentNode) {
        section.remove();
        moreSquaresContainer.appendChild(section);
      }
    });
  }
  
  // Verify all squares are present
  const finalSquares = Array.from(moreSquaresContainer.querySelectorAll('section.set')).map(s => {
    const h2 = s.querySelector('h2');
    return h2 ? h2.textContent : 'unknown';
  });
  console.log('Final squares in moreSquares:', finalSquares.slice(0, 10), '...', finalSquares.slice(-10));
  
  // CRITICAL: Clean up answer displays AFTER all squares are generated
  // Use setTimeout to ensure this runs after all squares are created
  setTimeout(() => {
    try {
      // Remove duplicate answer displays first
      const allSections = document.querySelectorAll('section.set');
      allSections.forEach(section => {
        try {
          const answerDisplays = section.querySelectorAll('.answer-display');
          // If there are multiple, remove all but the first one
          if (answerDisplays.length > 1) {
            for (let i = 1; i < answerDisplays.length; i++) {
              answerDisplays[i].remove();
            }
          }
        } catch (e) {
          // Silently continue if there's an error
        }
      });
      
      // Ensure ALL answer displays are completely hidden and removed from view
      // First, move any answer displays that are in sections to hidden containers
      const allSections2 = document.querySelectorAll('section.set');
      allSections2.forEach(section => {
        try {
          const answerDisplay = section.querySelector('.answer-display');
          if (answerDisplay && answerDisplay.parentNode === section) {
            // Move to hidden container
            section.removeChild(answerDisplay);
            const hiddenContainer = section._hiddenContainer || document.createElement('div');
            hiddenContainer.style.cssText = 'display: none !important; position: absolute !important; left: -9999px !important; top: -9999px !important; visibility: hidden !important;';
            hiddenContainer.appendChild(answerDisplay);
            if (!hiddenContainer.parentNode) {
              document.body.appendChild(hiddenContainer);
            }
            section._hiddenContainer = hiddenContainer;
            section._answerDisplay = answerDisplay;
          }
        } catch (e) {
          // Silently continue if there's an error
        }
      });
      
      const allAnswerDisplays = document.querySelectorAll('.answer-display');
      allAnswerDisplays.forEach(display => {
        try {
          // Remove show class
          display.classList.remove('show');
          // Clear all content
          display.textContent = '';
          display.innerHTML = '';
          // Force hide with inline styles that override everything
          display.setAttribute('style', 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: absolute !important; left: -9999px !important; top: -9999px !important; height: 0 !important; width: 0 !important; overflow: hidden !important; margin: 0 !important; padding: 0 !important; font-size: 0 !important; line-height: 0 !important; pointer-events: none !important; color: transparent !important; z-index: -9999 !important;');
          // Ensure parent is hidden container, not section
          if (display.parentNode && display.parentNode.classList && display.parentNode.classList.contains('set')) {
            const section = display.parentNode;
            section.removeChild(display);
            const hiddenContainer = section._hiddenContainer || document.createElement('div');
            hiddenContainer.style.cssText = 'display: none !important; position: absolute !important; left: -9999px !important; top: -9999px !important; visibility: hidden !important;';
            hiddenContainer.appendChild(display);
            if (!hiddenContainer.parentNode) {
              document.body.appendChild(hiddenContainer);
            }
            section._hiddenContainer = hiddenContainer;
          }
          
          // Prevent show class from being added unless explicitly allowed
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          // Check if show class was added
          if (display.classList.contains('show') && !display.dataset.allowShow) {
            // Remove show class if not explicitly allowed
            display.classList.remove('show');
            display.setAttribute('style', 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: absolute !important; left: -9999px !important; top: -9999px !important; height: 0 !important; width: 0 !important; overflow: hidden !important; margin: 0 !important; padding: 0 !important; font-size: 0 !important; line-height: 0 !important; pointer-events: none !important; color: transparent !important;');
          }
        }
        if (mutation.type === 'childList' || mutation.type === 'characterData') {
          // If textContent is set and show class is not present, clear it
          if (!display.classList.contains('show') && display.textContent.trim() !== '') {
            display.textContent = '';
            display.innerHTML = '';
            display.setAttribute('style', 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: absolute !important; left: -9999px !important; top: -9999px !important; height: 0 !important; width: 0 !important; overflow: hidden !important; margin: 0 !important; padding: 0 !important; font-size: 0 !important; line-height: 0 !important; pointer-events: none !important; color: transparent !important;');
          }
        }
      });
    });
    observer.observe(display, {
      attributes: true,
      attributeFilter: ['class'],
      childList: true,
      characterData: true,
      subtree: true
    });
    
    // Also check periodically to ensure it stays hidden
    setInterval(() => {
      if (!display.dataset.allowShow && (display.classList.contains('show') || display.textContent.trim() !== '')) {
        display.classList.remove('show');
        display.textContent = '';
        display.innerHTML = '';
        display.style.display = 'none';
        display.style.visibility = 'hidden';
        display.style.opacity = '0';
        display.style.position = 'absolute';
        display.style.left = '-9999px';
        display.style.top = '-9999px';
      }
    }, 100);
        } catch (e) {
          // Silently continue if there's an error
        }
      });
    } catch (e) {
      // Silently continue if there's an error - don't break script execution
      console.error('Error in answer display cleanup:', e);
    }
  }, 100); // Run after a short delay to ensure all squares are generated
  
  // Now that moreSquares is BEFORE 5² in DOM, with column-reverse:
  // Visual order: [5², moreSquares content]
  // To get [5², 6², 7², ..., 36²], we need 6² to be LAST in moreSquares DOM
  // (so it appears FIRST in moreSquares visually, right after 5²)
  
  // With column-reverse, sections are visually reversed (100² at top, 1² at bottom)
  // Now all squares 6-100 are in reverse DOM order, so they appear sequentially (6 to 100)
  // Navigation is at visual bottom (first in DOM with column-reverse)
  // Scroll to bottom on load to show 1² first, then scrolling down reveals larger numbers moving up
  setTimeout(() => {
    // Scroll to very bottom to start at 1²
    window.scrollTo({
      top: document.documentElement.scrollHeight,
      behavior: 'instant'
    });
    // Double-check all answer displays are still hidden after scroll
    document.querySelectorAll('.answer-display').forEach(display => {
      if (!display.classList.contains('show')) {
        display.style.display = 'none';
        display.style.visibility = 'hidden';
        display.style.opacity = '0';
        display.textContent = '';
      }
    });
  }, 300);
  
  // Debug: Log everything after appending
  setTimeout(() => {
    console.log('=== AFTER APPENDING 39² SECTION ===');
    const headingAfter = second39Section.querySelector('h2');
    const gridAfter = second39Section.querySelector('#square-1521-2');
    console.log('Heading after append:', headingAfter);
    console.log('Heading offsetHeight after:', headingAfter?.offsetHeight);
    console.log('Heading offsetWidth after:', headingAfter?.offsetWidth);
    console.log('Heading offsetTop after:', headingAfter?.offsetTop);
    console.log('Heading computed display after:', headingAfter ? window.getComputedStyle(headingAfter).display : 'N/A');
    console.log('Grid offsetTop after:', gridAfter?.offsetTop);
    console.log('Section offsetHeight:', second39Section.offsetHeight);
    console.log('Section offsetTop:', second39Section.offsetTop);
    console.log('Section parent:', second39Section.parentElement);
    console.log('Section is in DOM:', document.body.contains(second39Section));
    
    // Check if heading is visible
    if (headingAfter) {
      const rect = headingAfter.getBoundingClientRect();
      console.log('Heading bounding rect:', rect);
      console.log('Heading is visible:', rect.width > 0 && rect.height > 0);
    }
  }, 100);
}

// Sections are kept in normal order (1² first, then 2², 3²... up to 100²)
// Page starts at top showing 1², and as you scroll down you see larger numbers

// Navigation is already positioned correctly via CSS (order: -1 in column-reverse layout)
</script>

<!-- html2pdf.js library for PDF generation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

<script>
async function downloadPDF() {
  // Show loading message
  const originalText = event.target.textContent;
  event.target.textContent = "⏳ Generating PDF...";
  event.target.disabled = true;
  
  try {
    // Get the main content area (exclude navigation)
    const element = document.body;
    const opt = {
      margin: [10, 10, 10, 10],
      filename: 'math-squares.pdf',
      image: { type: 'jpeg', quality: 0.98 },
      html2canvas: { 
        scale: 2,
        useCORS: true,
        backgroundColor: '#ffffff',
        ignoreElements: (el) => {
          // Exclude navigation and controls from PDF
          return el.classList.contains('game-navigation') || 
                 el.classList.contains('controls');
        },
        onclone: (clonedDoc) => {
          // Change text color to black for PDF
          clonedDoc.body.style.backgroundColor = '#ffffff';
          clonedDoc.body.style.color = '#000000';
          const allElements = clonedDoc.querySelectorAll('*');
          allElements.forEach(el => {
            const style = window.getComputedStyle(el);
            if (style.color === 'rgb(255, 255, 255)' || style.color === 'white') {
              el.style.color = '#000000';
            }
          });
        }
      },
      jsPDF: { 
        unit: 'mm', 
        format: 'a4', 
        orientation: 'portrait' 
      }
    };
    
    // Generate and download PDF
    await html2pdf().set(opt).from(element).save();
    
    // Restore button
    event.target.textContent = originalText;
    event.target.disabled = false;
  } catch (error) {
    console.error('Error generating PDF:', error);
    alert('Error generating PDF. Please try again.');
    event.target.textContent = originalText;
    event.target.disabled = false;
  }
}

// Squares Game 2: Type answers in order
let currentSquareIndex = 0;
let startTime = null;
let attemptedSquares = new Set(); // Track which squares have been attempted
const squares = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401, 2500, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 3600, 3721, 3844, 3969, 4096, 4225, 4356, 4489, 4624, 4761, 4900, 5041, 5184, 5329, 5476, 5625, 5776, 5929, 6084, 6241, 6400, 6561, 6724, 6889, 7056, 7225, 7396, 7569, 7744, 7921, 8100, 8281, 8464, 8649, 8836, 9025, 9216, 9409, 9604, 9801, 10000];

function updateNextSquareHint() {
  const hintElement = document.getElementById('nextSquareHint');
  if (currentSquareIndex < squares.length) {
    const nextSquare = squares[currentSquareIndex];
    const base = Math.sqrt(nextSquare);
    // Only show hint if this square hasn't been attempted yet
    if (!attemptedSquares.has(nextSquare)) {
      hintElement.textContent = `Next: ${base}² = ?`;
    } else {
      // Show the answer after attempt
      hintElement.textContent = `Next: ${base}² = ${nextSquare}`;
    }
  } else {
    hintElement.textContent = 'All squares completed!';
  }
  
  // Highlight the current square
  highlightCurrentSquare();
}

function highlightCurrentSquare() {
  // Remove current-square class from all sections
  document.querySelectorAll('.set').forEach(section => {
    section.classList.remove('current-square');
  });
  
  // Add current-square class to the current square
  if (currentSquareIndex < squares.length) {
    const currentSquare = squares[currentSquareIndex];
    const section = document.querySelector(`section[data-square="${currentSquare}"]`);
    if (section) {
      section.classList.add('current-square');
      // Scroll to it if not visible
      const rect = section.getBoundingClientRect();
      if (rect.top < 0 || rect.bottom > window.innerHeight) {
        section.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  }
}

// Copy the breakDownNumber function from squares-opposite.html
function breakDownNumber(num) {
  const str = num.toString();
  const components = [];
  
  if (str.length === 2) {
    // Two-digit: tens and ones
    const tens = parseInt(str[0]) * 10;
    const ones = parseInt(str[1]);
    components.push(tens, ones);
  } else if (str.length === 3) {
    // Three-digit: hundreds, tens, ones
    const hundreds = parseInt(str[0]) * 100;
    const tens = parseInt(str[1]) * 10;
    const ones = parseInt(str[2]);
    components.push(hundreds, tens, ones);
  } else if (str.length === 4) {
    // Four-digit: thousands, hundreds, tens, ones
    const thousands = parseInt(str[0]) * 1000;
    const remainder = parseInt(str.substring(1));
    if (remainder < 100) {
      // If remainder is 2-digit, treat as tens and ones
      const tens = Math.floor(remainder / 10) * 10;
      const ones = remainder % 10;
      components.push(thousands, tens, ones);
    } else {
      // If remainder is 3-digit, treat as hundreds, tens, ones
      const hundreds = Math.floor(remainder / 100) * 100;
      const tens = Math.floor((remainder % 100) / 10) * 10;
      const ones = remainder % 10;
      components.push(thousands, hundreds, tens, ones);
    }
  }
  
  return components;
}

// Color mapping based on first digit (same as squares-opposite.html)
const COLOR_MAP = {
  1: "red", 2: "orange", 3: "yellow", 4: "green", 5: "blue",
  6: "purple", 7: "brown", 8: "pink", 9: "sky", 10: "red-final"
};

function getColorForComponent(componentValue) {
  const componentStr = componentValue.toString();
  const firstDigit = parseInt(componentStr[0]);
  const colorKey = firstDigit || 10;
  return COLOR_MAP[colorKey] || "red";
}

function fillSquareWithCorrectColors(squareValue) {
  const section = document.querySelector(`section[data-square="${squareValue}"]`);
  if (!section) return;
  
  // Get components using the same logic as squares-opposite.html
  let components = breakDownNumber(squareValue);
  
  // Apply special cases from squares-opposite.html
  if (squareValue === 900) {
    components = [900];
  } else if (squareValue === 1225) {
    components = [1000, 200, 20, 5];
  } else if (squareValue === 1600) {
    components = [1000, 600];
  } else if (squareValue === 1681) {
    components = [1000, 600, 80, 1];
  } else if (squareValue === 1764) {
    components = [1000, 700, 60, 4];
  } else if (squareValue === 1849) {
    components = [1000, 800, 40, 9];
  } else if (squareValue === 1936) {
    components = [1000, 900, 30, 6];
  } else if (squareValue === 2025) {
    components = [2000, 20, 5];
  } else if (squareValue === 2116) {
    components = [2000, 100, 10, 6];
  } else if (squareValue === 2209) {
    components = [2000, 200, 9];
  } else if (squareValue === 2304) {
    components = [2000, 300, 4];
  } else if (squareValue === 2401) {
    components = [2000, 400, 1];
  } else if (squareValue === 2601) {
    components = [2000, 600, 1];
  } else if (squareValue === 2704) {
    components = [2000, 700, 4];
  } else if (squareValue === 1296) {
    components = [1000, 0, 90, 6];
  }
  
  const circles = Array.from(section.querySelectorAll('.circle'));
  const gridSize = Math.sqrt(squareValue);
  
  // Reset all circles first
  circles.forEach(circle => {
    circle.classList.remove('red', 'orange', 'yellow', 'green', 'blue', 'purple', 'brown', 'pink', 'sky', 'red-final');
  });
  
  // Fill each component with its appropriate color
  let filledCount = 0;
  components.forEach((componentValue, componentIndex) => {
    if (componentValue === 0) return; // Skip zero components
    
    const color = getColorForComponent(componentValue);
    const circlesToFill = Math.min(componentValue, circles.length - filledCount);
    
    // Fill circles for this component
    for (let i = filledCount; i < filledCount + circlesToFill && i < circles.length; i++) {
      circles[i].classList.add(color);
    }
    
    filledCount += circlesToFill;
  });
}

function fillSquareProgressively(squareValue, typedNumber) {
  const section = document.querySelector(`section[data-square="${squareValue}"]`);
  if (!section) return;
  
  const circles = Array.from(section.querySelectorAll('.circle'));
  const totalCircles = circles.length;
  
  // Calculate how many circles to fill based on typed number
  const fillRatio = Math.min(typedNumber / squareValue, 1);
  const circlesToFill = Math.floor(totalCircles * fillRatio);
  
  // Get components to determine colors
  let components = breakDownNumber(squareValue);
  
  // Apply special cases
  if (squareValue === 900) {
    components = [900];
  } else if (squareValue === 1225) {
    components = [1000, 200, 20, 5];
  } else if (squareValue === 1600) {
    components = [1000, 600];
  } else if (squareValue === 1681) {
    components = [1000, 600, 80, 1];
  } else if (squareValue === 1764) {
    components = [1000, 700, 60, 4];
  } else if (squareValue === 1849) {
    components = [1000, 800, 40, 9];
  } else if (squareValue === 1936) {
    components = [1000, 900, 30, 6];
  } else if (squareValue === 2025) {
    components = [2000, 20, 5];
  } else if (squareValue === 2116) {
    components = [2000, 100, 10, 6];
  } else if (squareValue === 2209) {
    components = [2000, 200, 9];
  } else if (squareValue === 2304) {
    components = [2000, 300, 4];
  } else if (squareValue === 2401) {
    components = [2000, 400, 1];
  } else if (squareValue === 2601) {
    components = [2000, 600, 1];
  } else if (squareValue === 2704) {
    components = [2000, 700, 4];
  } else if (squareValue === 1296) {
    components = [1000, 0, 90, 6];
  }
  
  // Reset all circles first
  circles.forEach(circle => {
    circle.classList.remove('red', 'orange', 'yellow', 'green', 'blue', 'purple', 'brown', 'pink', 'sky', 'red-final');
  });
  
  // Fill progressively with correct colors
  let filledCount = 0;
  components.forEach((componentValue, componentIndex) => {
    if (componentValue === 0) return; // Skip zero components
    
    const color = getColorForComponent(componentValue);
    const componentCirclesToFill = Math.min(componentValue, circles.length - filledCount);
    const remainingToFill = circlesToFill - filledCount;
    
    if (remainingToFill <= 0) return;
    
    // Fill circles for this component (up to the typed amount)
    const toFill = Math.min(componentCirclesToFill, remainingToFill);
    for (let i = filledCount; i < filledCount + toFill && i < circles.length; i++) {
      circles[i].classList.add(color);
    }
    
    filledCount += componentCirclesToFill;
    if (filledCount >= circlesToFill) return;
  });
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 100);
  if (mins > 0) {
    return `${mins}m ${secs}s`;
  }
  return `${secs}.${ms.toString().padStart(2, '0')}s`;
}

function createConfetti() {
  const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
  for (let i = 0; i < 50; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'celebration-confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDelay = Math.random() * 3 + 's';
    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
    document.querySelector('.celebration-overlay').appendChild(confetti);
  }
}

function showCelebration() {
  const overlay = document.createElement('div');
  overlay.className = 'celebration-overlay show';
  
  const endTime = Date.now();
  const elapsedSeconds = (endTime - startTime) / 1000;
  
  overlay.innerHTML = `
    <div class="celebration-content">
      <div class="celebration-title">🎉 CONGRATULATIONS! 🎉</div>
      <div class="celebration-message">You completed all ${squares.length} squares!</div>
      <div class="celebration-time">Time: ${formatTime(elapsedSeconds)}</div>
      <div class="celebration-message">Amazing work! 🌟</div>
      <button id="closeCelebration" style="margin-top: 30px; padding: 15px 30px; font-size: 24px; border: 2px solid #fff; border-radius: 8px; background: transparent; color: #fff; cursor: pointer;">Close</button>
    </div>
  `;
  
  document.body.appendChild(overlay);
  createConfetti();
  
  document.getElementById('closeCelebration').addEventListener('click', () => {
    overlay.remove();
  });
}

function scrollToSquare(squareValue, isCorrect) {
  // Find the section with matching data-square attribute
  const section = document.querySelector(`section[data-square="${squareValue}"]`);
  if (section) {
    // Mark as attempted and add correct/incorrect class
    section.classList.add('attempted');
    if (isCorrect) {
      section.classList.add('correct');
      section.classList.remove('incorrect');
    } else {
      section.classList.add('incorrect');
      section.classList.remove('correct');
    }
    
    // Scroll to the section smoothly
    section.scrollIntoView({ 
      behavior: 'smooth', 
      block: 'center',
      inline: 'center'
    });
  }
}

function checkAnswer() {
  const input = document.getElementById('answerInput');
  const answer = parseInt(input.value);
  
  if (isNaN(answer) || answer < 1) {
    input.classList.add('incorrect');
    setTimeout(() => {
      input.classList.remove('incorrect');
    }, 1000);
    return;
  }
  
  if (currentSquareIndex >= squares.length) {
    showCelebration();
    input.value = '';
    return;
  }
  
  const expectedSquare = squares[currentSquareIndex];
  
  // Fill square progressively as they type (before checking answer)
  fillSquareProgressively(expectedSquare, answer);
  
  // Mark this square as attempted
  attemptedSquares.add(expectedSquare);
  
  if (answer === expectedSquare) {
    // Correct answer! Fill the square with the correct colors from squares-opposite.html
    fillSquareWithCorrectColors(expectedSquare);
    
    input.classList.add('correct');
    input.value = '';
    
    // Scroll to the square with correct styling
    scrollToSquare(expectedSquare, true);
    
    // Move to next square
    currentSquareIndex++;
    updateNextSquareHint();
    
    // Check if all squares are completed
    if (currentSquareIndex >= squares.length) {
      setTimeout(() => {
        showCelebration();
      }, 500);
    }
    
    // Remove correct class after a delay
    setTimeout(() => {
      input.classList.remove('correct');
      input.focus();
    }, 1000);
  } else {
    // Incorrect answer - show red flash, then reset
    const section = document.querySelector(`section[data-square="${expectedSquare}"]`);
    if (section) {
      const circles = section.querySelectorAll('.circle');
      // Flash all red briefly
      circles.forEach(circle => {
        circle.classList.add('red');
      });
    }
    
    // Scroll to show which square they were trying
    scrollToSquare(expectedSquare, false);
    
    input.classList.add('incorrect');
    setTimeout(() => {
      // Reset the square to black after showing error
      if (section) {
        const circles = section.querySelectorAll('.circle');
        circles.forEach(circle => {
          circle.classList.remove('red', 'orange', 'yellow', 'green', 'blue', 'purple', 'brown', 'pink', 'sky', 'red-final');
        });
      }
      input.classList.remove('incorrect');
      input.value = '';
      input.focus();
    }, 1500);
  }
}

// Initialize the game
document.addEventListener('DOMContentLoaded', () => {
  const input = document.getElementById('answerInput');
  const submitButton = document.getElementById('submitAnswer');
  
  // Start timer on first answer attempt
  let timerStarted = false;
  
  updateNextSquareHint();
  
  // Focus on input when page loads
  setTimeout(() => {
    input.focus();
  }, 100);
  
  // Submit on button click
  submitButton.addEventListener('click', () => {
    if (!timerStarted) {
      startTime = Date.now();
      timerStarted = true;
    }
    checkAnswer();
  });
  
  // Submit on Enter key
  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      if (!timerStarted) {
        startTime = Date.now();
        timerStarted = true;
      }
      checkAnswer();
    }
  });
  
  // Clear input classes when typing and fill square progressively
  input.addEventListener('input', (e) => {
    input.classList.remove('correct', 'incorrect');
    
    // Fill square progressively as they type
    const typedValue = parseInt(e.target.value);
    if (!isNaN(typedValue) && typedValue > 0 && currentSquareIndex < squares.length) {
      const currentSquare = squares[currentSquareIndex];
      fillSquareProgressively(currentSquare, typedValue);
    }
  });
  
  // Highlight current square on page load
  highlightCurrentSquare();
});
</script>

</body>
</html>

