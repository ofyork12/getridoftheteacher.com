 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Squares Game</title>
  <style>
    :root {
      --circle-size: clamp(30px, 6vw, 60px); /* Smaller for up to 625 dots */
      --circle-border: clamp(3px, 0.6vw, 6px);
      --circle-total: calc(var(--circle-size) + var(--circle-border) * 2);
      --section-gap: clamp(30px, 6vw, 60px);
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--section-gap);
      padding: 40px 12px 120px;
      overflow-y: auto;
      -webkit-tap-highlight-color: transparent;
    }
    .game-navigation {
      display: flex;
      gap: 40px;
      margin: 30px 0;
      justify-content: center;
      flex-wrap: wrap;
    }
    .game-nav-button {
      padding: 36px 72px;
      font-size: 46.08px;
      font-weight: bold;
      background: transparent;
      color: #fff;
      border: 5.76px solid #fff;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }
    .game-nav-button:hover {
      background: #fff;
      color: #000;
    }
    .game-nav-button.active {
      background: #fff;
      color: #000;
    }
    .set {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 100%;
      text-align: center;
    }
    .set > :last-child {
      margin: 0 auto;
    }
    .set h2 {
      margin: 0;
      font-size: 84px;
      font-weight: 700;
      letter-spacing: 6px;
      text-transform: uppercase;
    }
    .set {
      margin-bottom: 40px;
    }
    .answer-display {
      margin-top: 15px;
      font-size: 72px;
      font-weight: bold;
      min-height: 90px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .answer-display.show {
      opacity: 1;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      margin-bottom: 40px;
      justify-content: center;
    }
    .lang-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    .controls button {
      padding: 45px 90px;
      border: 7.2px solid #fff;
      border-radius: 999px;
      background: transparent;
      color: #fff;
      font-size: 57.6px;
      cursor: pointer;
      transition: background 0.3s ease, color 0.3s ease;
    }
    .controls button.active {
      background: #fff;
      color: #000;
    }
    .controls button.dual {
      font-size: 46.8px;
      padding: 36px 72px;
      opacity: 0.85;
      border-style: dashed;
    }
    .circle {
      width: var(--circle-total);
      height: var(--circle-total);
      border-radius: 50%;
      background: #222;
      border: var(--circle-border) solid #fff;
      cursor: pointer;
      transition: background 0.25s ease;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }
    .circle:focus-visible,
    .circle:focus,
    .circle:active {
      outline: none;
    }
    .circle.red { background: #ff0000; }
    .circle.orange { background: #ff6200; }
    .circle.yellow { background: #ffe600; }
    .circle.green { background: #00a12c; }
    .circle.blue { background: #0030ff; }
    .circle.purple { background: #6a1b9a; }
    .circle.brown { background: #7a3b00; }
    .circle.pink { background: #ff3fa6; }
    .circle.sky { background: #38c7ff; }
    .circle.red-final { background: #ff0000; }
    
    /* 26×26 through 30×30 grids with numbers - larger circles */
    .grid-676, .grid-729, .grid-784, .grid-841, .grid-900 {
      --circle-size-large: clamp(40px, 8vw, 80px);
      --circle-total-large: calc(var(--circle-size-large) + var(--circle-border) * 2);
    }
    .grid-676 {
      grid-template-columns: repeat(26, var(--circle-total-large)) !important;
      grid-template-rows: repeat(26, var(--circle-total-large)) !important;
      width: calc(var(--circle-total-large) * 26) !important;
      height: calc(var(--circle-total-large) * 26) !important;
    }
    .grid-729 {
      grid-template-columns: repeat(27, var(--circle-total-large)) !important;
      grid-template-rows: repeat(27, var(--circle-total-large)) !important;
      width: calc(var(--circle-total-large) * 27) !important;
      height: calc(var(--circle-total-large) * 27) !important;
    }
    .grid-784 {
      grid-template-columns: repeat(28, var(--circle-total-large)) !important;
      grid-template-rows: repeat(28, var(--circle-total-large)) !important;
      width: calc(var(--circle-total-large) * 28) !important;
      height: calc(var(--circle-total-large) * 28) !important;
    }
    .grid-841 {
      grid-template-columns: repeat(29, var(--circle-total-large)) !important;
      grid-template-rows: repeat(29, var(--circle-total-large)) !important;
      width: calc(var(--circle-total-large) * 29) !important;
      height: calc(var(--circle-total-large) * 29) !important;
    }
    .grid-900 {
      grid-template-columns: repeat(30, var(--circle-total-large)) !important;
      grid-template-rows: repeat(30, var(--circle-total-large)) !important;
      width: calc(var(--circle-total-large) * 30) !important;
      height: calc(var(--circle-total-large) * 30) !important;
    }
    /* Grids 34×34 through 50×50 - make them bigger */
    .grid-1156, .grid-1225, .grid-1296, .grid-1369, .grid-1444, .grid-1521, .grid-1600,
    .grid-1681, .grid-1764, .grid-1849, .grid-1936, .grid-2025, .grid-2116, .grid-2209,
    .grid-2304, .grid-2401, .grid-2500 {
      --circle-size-large: clamp(35px, 7vw, 70px);
      --circle-total-large: calc(var(--circle-size-large) + var(--circle-border) * 2);
    }
    /* 1156, 1225, and squares 36×36 through 50×50 use regular size like square 33 (1089) */
    .grid-1156 {
      grid-template-columns: repeat(34, var(--circle-total)) !important;
      grid-template-rows: repeat(34, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 34) !important;
    }
    .grid-1225 {
      grid-template-columns: repeat(35, var(--circle-total)) !important;
      grid-template-rows: repeat(35, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 35) !important;
    }
    .grid-1296 {
      grid-template-columns: repeat(36, var(--circle-total)) !important;
      grid-template-rows: repeat(36, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 36) !important;
    }
    .grid-1369 {
      grid-template-columns: repeat(37, var(--circle-total)) !important;
      grid-template-rows: repeat(37, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 37) !important;
    }
    .grid-1444 {
      grid-template-columns: repeat(38, var(--circle-total)) !important;
      grid-template-rows: repeat(38, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 38) !important;
    }
    .grid-1521 {
      grid-template-columns: repeat(39, var(--circle-total)) !important;
      grid-template-rows: repeat(39, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 39) !important;
    }
    .grid-1600 {
      grid-template-columns: repeat(40, var(--circle-total)) !important;
      grid-template-rows: repeat(40, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 40) !important;
    }
    .grid-1681 {
      grid-template-columns: repeat(41, var(--circle-total)) !important;
      grid-template-rows: repeat(41, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 41) !important;
    }
    .grid-1764 {
      grid-template-columns: repeat(42, var(--circle-total)) !important;
      grid-template-rows: repeat(42, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 42) !important;
    }
    .grid-1849 {
      grid-template-columns: repeat(43, var(--circle-total)) !important;
      grid-template-rows: repeat(43, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 43) !important;
    }
    .grid-1936 {
      grid-template-columns: repeat(44, var(--circle-total)) !important;
      grid-template-rows: repeat(44, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 44) !important;
    }
    .grid-2025 {
      grid-template-columns: repeat(45, var(--circle-total)) !important;
      grid-template-rows: repeat(45, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 45) !important;
    }
    .grid-2116 {
      grid-template-columns: repeat(46, var(--circle-total)) !important;
      grid-template-rows: repeat(46, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 46) !important;
    }
    .grid-2209 {
      grid-template-columns: repeat(47, var(--circle-total)) !important;
      grid-template-rows: repeat(47, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 47) !important;
    }
    .grid-2304 {
      grid-template-columns: repeat(48, var(--circle-total)) !important;
      grid-template-rows: repeat(48, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 48) !important;
    }
    .grid-2401 {
      grid-template-columns: repeat(49, var(--circle-total)) !important;
      grid-template-rows: repeat(49, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 49) !important;
    }
    .grid-2500 {
      grid-template-columns: repeat(50, var(--circle-total)) !important;
      grid-template-rows: repeat(50, var(--circle-total)) !important;
      width: calc(var(--circle-total) * 50) !important;
    }
    .circle-676, .circle-729, .circle-784, .circle-841, .circle-900 {
      width: var(--circle-total-large) !important;
      height: var(--circle-total-large) !important;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    /* Circle sizes for grids 34×34 through 50×50 */
    /* 1156, 1225 use regular size like square 33 (1089) */
    /* 1296 (36×36) uses larger size for readability */
    .circle-1156, .circle-1225 {
      width: var(--circle-total) !important;
      height: var(--circle-total) !important;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .circle-1296 {
      width: var(--circle-total) !important;
      height: var(--circle-total) !important;
    }
    .circle-1369, .circle-1444, .circle-1521, .circle-1600,
    .circle-1681, .circle-1764, .circle-1849, .circle-1936, .circle-2025, .circle-2116, .circle-2209,
    .circle-2304, .circle-2401, .circle-2500 {
      width: var(--circle-total) !important;
      height: var(--circle-total) !important;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    /* Number styling for 26×26 through 30×30 grids */
    .circle-number {
      font-size: clamp(10px, 2vw, 20px);
      font-weight: bold;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8), -1px -1px 2px rgba(0, 0, 0, 0.8);
      pointer-events: none;
      user-select: none;
      z-index: 1;
      line-height: 1;
    }
    /* Larger numbers for squares 37×37 and above */
    .circle-1369 .circle-number,
    .circle-1444 .circle-number,
    .circle-1521 .circle-number,
    .circle-1600 .circle-number,
    .circle-1681 .circle-number,
    .circle-1764 .circle-number,
    .circle-1849 .circle-number,
    .circle-1936 .circle-number,
    .circle-2025 .circle-number,
    .circle-2116 .circle-number,
    .circle-2209 .circle-number,
    .circle-2304 .circle-number,
    .circle-2401 .circle-number,
    .circle-2500 .circle-number {
      font-size: clamp(16px, 3vw, 32px);
      font-weight: bold;
    }
    .circle.red .circle-number,
    .circle.orange .circle-number,
    .circle.yellow .circle-number,
    .circle.green .circle-number,
    .circle.blue .circle-number,
    .circle.purple .circle-number,
    .circle.brown .circle-number,
    .circle.pink .circle-number,
    .circle.sky .circle-number,
    .circle.red-final .circle-number {
      color: #fff;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9), -1px -1px 3px rgba(0, 0, 0, 0.9);
    }

    /* Single circle */
    .single-circle {
      width: var(--circle-total);
      height: var(--circle-total);
    }

    /* 2x2 grid (4 circles) */
    .grid-two {
      display: grid;
      grid-template-columns: repeat(2, var(--circle-total));
      grid-template-rows: repeat(2, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 2);
      height: calc(var(--circle-total) * 2);
    }
    .grid-two .circle {
      position: static;
    }

    /* 3x3 grid (9 circles) */
    .grid-three {
      display: grid;
      grid-template-columns: repeat(3, var(--circle-total));
      grid-template-rows: repeat(3, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 3);
      height: calc(var(--circle-total) * 3);
    }
    .grid-three .circle {
      position: static;
    }

    /* 4x4 grid (16 circles) */
    .grid-four {
      display: grid;
      grid-template-columns: repeat(4, var(--circle-total));
      grid-template-rows: repeat(4, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 4);
      height: calc(var(--circle-total) * 4);
    }
    .grid-four .circle {
      position: static;
    }

    /* 5x5 grid (25 circles) */
    .grid-five {
      display: grid;
      grid-template-columns: repeat(5, var(--circle-total));
      grid-template-rows: repeat(5, var(--circle-total));
      gap: 0;
      width: calc(var(--circle-total) * 5);
      height: calc(var(--circle-total) * 5);
    }
    .grid-five .circle {
      position: static;
    }

    /* Dynamic grid classes for larger squares */
    .grid-dynamic {
      display: grid;
      gap: 0;
      cursor: pointer;
    }
    .grid-dynamic .circle {
      position: static;
    }
  </style>
</head>
<body>

  <div class="game-navigation">
    <a href="index.html" class="game-nav-button">← Go Back</a>
    <a href="bigger-smaller.html" class="game-nav-button">Bigger/Smaller</a>
    <a href="squares.html" class="game-nav-button active">Squares</a>
  </div>

  <div class="controls" role="group" aria-label="Language selector">
    <div class="lang-group">
      <button data-lang="en" class="active">English</button>
      <button class="dual" data-mode="sound">Sound</button>
    </div>
    <div class="lang-group">
      <button data-lang="vi">Tiếng Việt</button>
      <button class="dual" data-dual="vi">Tiếng Việt + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="zh">中文</button>
      <button class="dual" data-dual="zh">中文 + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="ko">한국어</button>
      <button class="dual" data-dual="ko">한국어 + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="es">Español</button>
      <button class="dual" data-dual="es">Español + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="fr">Français</button>
      <button class="dual" data-dual="fr">Français + English</button>
    </div>
    <div class="lang-group">
      <button data-lang="hi">हिन्दी</button>
      <button class="dual" data-dual="hi">हिन्दी + English</button>
    </div>
  </div>

  <section class="set" data-square="1" data-base="1">
    <h2>1²</h2>
    <div class="single-circle">
      <div class="circle" id="one"></div>
    </div>
    <div class="answer-display" data-answer="1"></div>
  </section>

  <section class="set" data-square="4" data-base="2">
    <h2>2²</h2>
    <div class="grid-two" id="four">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="4"></div>
  </section>

  <section class="set" data-square="9" data-base="3">
    <h2>3²</h2>
    <div class="grid-three" id="nine">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="9"></div>
  </section>

  <section class="set" data-square="16" data-base="4">
    <h2>4²</h2>
    <div class="grid-four" id="sixteen">
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
      <div class="circle"></div>
    </div>
    <div class="answer-display" data-answer="16"></div>
  </section>

  <section class="set" data-square="25" data-base="5">
    <h2>5²</h2>
    <div class="grid-five" id="square-25"></div>
    <div class="answer-display" data-answer="25"></div>
  </section>

  <div id="moreSquares"></div>

<script>
const COLOR_CLASSES = ["orange","yellow","green","blue","purple","brown","pink","sky","red-final"];
// Generate number words up to 625
const basic = {
  en: ["zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"],
  zh: ["零","一","二","三","四","五","六","七","八","九","十","十一","十二","十三","十四","十五","十六","十七","十八","十九","二十"],
  es: ["cero","uno","dos","tres","cuatro","cinco","seis","siete","ocho","nueve","diez","once","doce","trece","catorce","quince","dieciséis","diecisiete","dieciocho","diecinueve","veinte"],
  fr: ["zéro","un","deux","trois","quatre","cinq","six","sept","huit","neuf","dix","onze","douze","treize","quatorze","quinze","seize","dix-sept","dix-huit","dix-neuf","vingt"],
  hi: ["शून्य","एक","दो","तीन","चार","पांच","छह","सात","आठ","नौ","दस","ग्यारह","बारह","तेरह","चौदह","पंद्रह","सोलह","सत्रह","अठारह","उन्नीस","बीस"],
  ko: ["영","일","이","삼","사","오","육","칠","팔","구","십","십일","십이","십삼","십사","십오","십육","십칠","십팔","십구","이십"],
  vi: ["không","một","hai","ba","bốn","năm","sáu","bảy","tám","chín","mười","mười một","mười hai","mười ba","mười bốn","mười lăm","mười sáu","mười bảy","mười tám","mười chín","hai mươi"]
};

// Helper function to generate Chinese number words
function generateChineseNumber(num) {
  if (num <= 20) {
    return basic.zh[num] || num.toString();
  }
  
  if (num < 100) {
    const tens = Math.floor(num / 10);
    const ones = num % 10;
    if (tens === 1) {
      return "十" + (ones > 0 ? basic.zh[ones] : "");
    } else {
      return basic.zh[tens] + "十" + (ones > 0 ? basic.zh[ones] : "");
    }
  }
  
  if (num < 1000) {
    const hundreds = Math.floor(num / 100);
    const remainder = num % 100;
    const hundredsWord = basic.zh[hundreds] + "百";
    
    if (remainder === 0) {
      return hundredsWord;
    } else if (remainder < 10) {
      return hundredsWord + "零" + basic.zh[remainder];
    } else {
      return hundredsWord + generateChineseNumber(remainder);
    }
  }
  
  if (num < 10000) {
    const thousands = Math.floor(num / 1000);
    const remainder = num % 1000;
    const thousandsWord = basic.zh[thousands] + "千";
    
    if (remainder === 0) {
      return thousandsWord;
    } else if (remainder < 100) {
      return thousandsWord + "零" + generateChineseNumber(remainder);
    } else {
      return thousandsWord + generateChineseNumber(remainder);
    }
  }
  
  // For numbers >= 10000, use simple format
  return num.toString();
}

// Helper function to generate Vietnamese number words
function generateVietnameseNumber(num) {
  if (num <= 20) {
    return basic.vi[num] || num.toString();
  }
  
  if (num < 100) {
    const tens = Math.floor(num / 10);
    const ones = num % 10;
    let tensWord;
    
    if (tens === 2) {
      tensWord = "hai mươi";
    } else if (tens === 3) {
      tensWord = "ba mươi";
    } else if (tens === 4) {
      tensWord = "bốn mươi";
    } else if (tens === 5) {
      tensWord = "năm mươi";
    } else if (tens === 6) {
      tensWord = "sáu mươi";
    } else if (tens === 7) {
      tensWord = "bảy mươi";
    } else if (tens === 8) {
      tensWord = "tám mươi";
    } else if (tens === 9) {
      tensWord = "chín mươi";
    } else {
      tensWord = basic.vi[tens] + " mươi";
    }
    
    if (ones === 0) {
      return tensWord;
    } else if (ones === 1) {
      return tensWord + " mốt";
    } else if (ones === 5) {
      return tensWord + " lăm";
    } else {
      return tensWord + " " + basic.vi[ones];
    }
  }
  
  if (num < 1000) {
    const hundreds = Math.floor(num / 100);
    const remainder = num % 100;
    const hundredsWord = hundreds === 1 ? "một trăm" : (basic.vi[hundreds] + " trăm");
    
    if (remainder === 0) {
      return hundredsWord;
    } else if (remainder < 10) {
      return hundredsWord + " lẻ " + basic.vi[remainder];
    } else {
      return hundredsWord + " " + generateVietnameseNumber(remainder);
    }
  }
  
  // For numbers >= 1000, use simple format
  return num.toString();
}

function generateNumberWords(max) {
  const words = { en: [], zh: [], es: [], fr: [], hi: [], ko: [], vi: [] };
  
  for (let i = 0; i <= max && i <= 20; i++) {
    Object.keys(words).forEach(lang => {
      words[lang].push(basic[lang][i] || i.toString());
    });
  }
  
  // For numbers > 20, generate proper words
  for (let i = 21; i <= max; i++) {
    words.en.push(i.toString());
    words.zh.push(generateChineseNumber(i));
    words.es.push(i.toString());
    words.fr.push(i.toString());
    words.hi.push(i.toString());
    words.ko.push(i.toString());
    
    // Generate Vietnamese number words properly
    words.vi.push(generateVietnameseNumber(i));
  }
  
  return words;
}

// Helper function to generate Vietnamese number words
// Generate up to 2500 to support all grids including 50×50
const NUMBER_WORDS = generateNumberWords(2500);
const LANGUAGE_HINTS = {
  en: "English",
  zh: "zh-CN",
  es: "es",
  fr: "fr",
  hi: "hi",
  ko: "ko-KR",
  vi: "vi-VN"
};
let currentLang = "en";
let preferredVoice = null;
let englishVoice = null;
const dualLang = new Set();
let lastSpokenCount = 0;

function pickVoice(langCode) {
  if (!("speechSynthesis" in window)) return null;
  const voices = window.speechSynthesis.getVoices();
  if (!voices.length) return null;

  const langHint = LANGUAGE_HINTS[langCode] || langCode;
  
  // For Chinese, try to find a good Chinese voice
  if (langCode === "zh") {
    // Try to find Chinese voices, prefer zh-CN
    const chineseVoices = voices.filter(v => 
      v.lang && (v.lang.startsWith("zh-CN") || v.lang.startsWith("zh") || v.lang.includes("Chinese"))
    );
    if (chineseVoices.length > 0) {
      // Prefer zh-CN voices
      const cnVoice = chineseVoices.find(v => v.lang.startsWith("zh-CN"));
      if (cnVoice) return cnVoice;
      return chineseVoices[0];
    }
  }
  
  // For Vietnamese, try to find a good Vietnamese voice
  if (langCode === "vi") {
    const vietnameseVoices = voices.filter(v => 
      v.lang && (v.lang.startsWith("vi-VN") || v.lang.startsWith("vi") || v.lang.includes("Vietnamese"))
    );
    if (vietnameseVoices.length > 0) {
      // Prefer vi-VN voices
      const vnVoice = vietnameseVoices.find(v => v.lang.startsWith("vi-VN"));
      if (vnVoice) return vnVoice;
      return vietnameseVoices[0];
    }
  }
  
  const langGroup = voices.filter(v => v.lang && v.lang.startsWith(langHint));
  if (langGroup.length) return langGroup[0];

  const fallbacks = [
    "Microsoft Aria Online (Natural) - English (United States)",
    "Google US English",
    "Google UK English Female",
    "Microsoft Zira Desktop - English (United States)"
  ];

  for (const name of fallbacks) {
    const voice = voices.find(v => v.name === name);
    if (voice) return voice;
  }
  return voices.find(v => v.lang && v.lang.startsWith("en")) || voices[0];
}

function initVoices(lang = currentLang) {
  preferredVoice = pickVoice(lang);
  englishVoice = pickVoice("en");
}

if ("speechSynthesis" in window) {
  window.speechSynthesis.onvoiceschanged = initVoices;
  initVoices();
}

// Sound toggle state
let soundEnabled = true;

function speakNumber(count) {
  // Don't speak if sound is disabled
  if (!soundEnabled) return;
  
  const words = NUMBER_WORDS[currentLang] || NUMBER_WORDS.en;
  if (count < 0 || count >= words.length) return;
  if (!("speechSynthesis" in window)) return;
  lastSpokenCount = count;
  
  // Re-initialize voice for current language to ensure it's correct
  preferredVoice = pickVoice(currentLang);
  
  window.speechSynthesis.cancel();
  window.speechSynthesis.resume();
  const utterance = new SpeechSynthesisUtterance(words[count]);
  utterance.rate = 1.15;
  utterance.pitch = 1;
  utterance.volume = 0.5; // 50% volume
  utterance.lang = LANGUAGE_HINTS[currentLang] || currentLang;
  if (preferredVoice) {
    utterance.voice = preferredVoice;
  } else {
    // If no voice found, at least set the language hint
    utterance.lang = LANGUAGE_HINTS[currentLang] || currentLang;
  }
  
  const isDual = dualLang.has(currentLang);
  const isEnglish = currentLang === 'en';
  
  requestAnimationFrame(() => {
    if (isEnglish) {
      // English only - say it once
      window.speechSynthesis.speak(utterance);
    } else if (isDual) {
      // Dual mode: native first, then English
      utterance.onend = () => {
        const englishWord = NUMBER_WORDS.en[count];
        const follow = new SpeechSynthesisUtterance(englishWord);
        follow.rate = 1.15;
        follow.pitch = 1;
        follow.volume = 0.5; // 50% volume
        follow.lang = LANGUAGE_HINTS.en || "en";
        if (englishVoice) follow.voice = englishVoice;
        window.speechSynthesis.speak(follow);
      };
      window.speechSynthesis.speak(utterance);
    } else {
      // Native only
      window.speechSynthesis.speak(utterance);
    }
  });
}

function setupGroup(selector, palette) {
  const circles = Array.from(document.querySelectorAll(selector));
  const section = circles[0].closest('.set');
  const answerDisplay = section ? section.querySelector('.answer-display') : null;
  let clickCount = 0;

  function refreshColors() {
    circles.forEach(circle => circle.classList.remove(...COLOR_CLASSES));
    const active = circles.filter(circle => circle.classList.contains("red"));
    const color = palette[active.length];

    if (color) {
      active.forEach(circle => circle.classList.add(color));
    }
    return active.length;
  }

  circles.forEach(circle => {
    circle.addEventListener("click", () => {
      const wasActive = circle.classList.contains("red");
      circle.classList.toggle("red");
      const count = refreshColors();
      speakNumber(count);
      
      if (answerDisplay && count > 0 && !wasActive) {
        clickCount++;
        // Check if all dots are filled (count equals the total number of dots in this section)
        const section = circles[0].closest('.set');
        const totalDots = circles.length;
        if (count >= totalDots) {
          const answer = answerDisplay.dataset.answer;
          answerDisplay.textContent = answer;
          answerDisplay.classList.add('show');
        }
      } else if (answerDisplay && count === 0) {
        clickCount = 0;
        answerDisplay.textContent = '';
        answerDisplay.classList.remove('show');
      }
    });
  });
}

// NUMBER 1 – single circle with voice feedback
const single = document.getElementById("one");
const section1 = single.closest('.set');
const answerDisplay1 = section1.querySelector('.answer-display');
single.addEventListener("click", function() {
  this.classList.toggle("red");
  const count = this.classList.contains("red") ? 1 : 0;
  speakNumber(count);
  
  if (count > 0) {
    // All dots are filled (1 dot), show the answer
    answerDisplay1.textContent = '1';
    answerDisplay1.classList.add('show');
  } else {
    answerDisplay1.textContent = '';
    answerDisplay1.classList.remove('show');
  }
});

// Language controls
const buttons = Array.from(document.querySelectorAll(".controls button[data-lang]"));
const dualButtons = Array.from(document.querySelectorAll(".controls button[data-dual]"));

function selectLanguage(lang, useDual, silent = false) {
  const isNewSelection = currentLang !== lang || useDual !== dualLang.has(lang);
  currentLang = lang;
  initVoices(lang);
  dualLang.clear();
  if (useDual && lang !== "en") {
    dualLang.add(lang);
  }
  
  // Turn off sound button when selecting a language
  const soundToggle = document.querySelector('.controls button[data-mode="sound"]');
  if (soundToggle) {
    soundToggle.classList.remove("active");
    // If sound was disabled, re-enable it when selecting a language
    if (!soundEnabled) {
      soundEnabled = true;
      soundToggle.textContent = "Sound";
      soundToggle.classList.add("dual");
    }
  }
  
  // Turn off all language buttons first
  buttons.forEach(btn => {
    btn.classList.remove("active");
  });
  dualButtons.forEach(btn => {
    btn.classList.remove("active");
  });
  
  // Then turn on only the selected language button
  buttons.forEach(btn => {
    const active = btn.dataset.lang === lang && !useDual;
    btn.classList.toggle("active", active);
  });

  dualButtons.forEach(btn => {
    const active = btn.dataset.dual === lang && useDual;
    btn.classList.toggle("active", active);
  });

  if (!silent && isNewSelection) {
    speakNumber(lastSpokenCount);
  }
}

buttons.forEach(btn => {
  btn.addEventListener("click", () => {
    selectLanguage(btn.dataset.lang, false);
  });
});

dualButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    selectLanguage(btn.dataset.dual, true);
  });
});

selectLanguage("en", false, true);

// Sound toggle button
const soundToggle = document.querySelector('.controls button[data-mode="sound"]');
if (soundToggle) {
  soundToggle.addEventListener("click", () => {
    if (soundEnabled) {
      // Disable sound and say "no sound"
      soundEnabled = false;
      soundToggle.textContent = "No Sound";
      soundToggle.classList.add("active");
      soundToggle.classList.remove("dual"); // Remove dual class to match font size
      
      // Turn off ALL language buttons
      buttons.forEach(btn => {
        btn.classList.remove("active");
      });
      dualButtons.forEach(btn => {
        btn.classList.remove("active");
      });
      
      // Say "no sound" or "no voice" before disabling
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance("no sound");
        utterance.rate = 1.15;
        utterance.pitch = 1;
        utterance.volume = 0.5;
        if (preferredVoice) utterance.voice = preferredVoice;
        window.speechSynthesis.speak(utterance);
      }
    } else {
      // Enable sound
      soundEnabled = true;
      soundToggle.textContent = "Sound";
      soundToggle.classList.remove("active");
      soundToggle.classList.add("dual"); // Restore dual class
      
      // Turn on English button (default)
      const englishButton = document.querySelector('.controls button[data-lang="en"]');
      if (englishButton) {
        englishButton.classList.add("active");
      }
    }
  });
}

// Square 4 (2²): One click fills all 4 dots green
const fourGrid = document.getElementById("four");
const fourCircles = Array.from(document.querySelectorAll("#four .circle"));
const section4 = fourCircles[0].closest('.set');
const answerDisplay4 = section4.querySelector('.answer-display');
let fourClickCount = 0;
fourGrid.addEventListener("click", () => {
  if (fourClickCount === 0) {
    // First click: fill all 4 dots green
    fourCircles.forEach(c => {
      c.classList.remove(...COLOR_CLASSES);
      c.classList.add("green");
    });
    fourClickCount = 1;
    speakNumber(4);
    if (answerDisplay4) {
      answerDisplay4.textContent = '4';
      answerDisplay4.classList.add('show');
    }
  } else {
    // Reset
    fourCircles.forEach(c => {
      c.classList.remove("green", ...COLOR_CLASSES);
    });
    fourClickCount = 0;
    if (answerDisplay4) {
      answerDisplay4.textContent = '';
      answerDisplay4.classList.remove('show');
    }
    speakNumber(0);
  }
});

// Square 9 (3²): One click fills all 9 dots sky blue
const nineGrid = document.getElementById("nine");
const nineCircles = Array.from(document.querySelectorAll("#nine .circle"));
const section9 = nineCircles[0].closest('.set');
const answerDisplay9 = section9.querySelector('.answer-display');
let nineClickCount = 0;
nineGrid.addEventListener("click", () => {
  if (nineClickCount === 0) {
    // First click: fill all 9 dots sky blue
    nineCircles.forEach(c => {
      c.classList.remove(...COLOR_CLASSES);
      c.classList.add("sky");
    });
    nineClickCount = 1;
    speakNumber(9);
    if (answerDisplay9) {
      answerDisplay9.textContent = '9';
      answerDisplay9.classList.add('show');
    }
  } else {
    // Reset
    nineCircles.forEach(c => {
      c.classList.remove("sky", ...COLOR_CLASSES);
    });
    nineClickCount = 0;
    if (answerDisplay9) {
      answerDisplay9.textContent = '';
      answerDisplay9.classList.remove('show');
    }
    speakNumber(0);
  }
});

// Helper function to get top right corner indices for a grid
function getTopRightCornerIndices(gridSize, count) {
  // Top right corner: top row, rightmost positions
  // For a grid of size n, top row indices are: 0, 1, 2, ..., n-1
  // We want the rightmost 'count' positions: n-1, n-2, ..., n-count
  const indices = [];
  for (let i = 0; i < count && i < gridSize; i++) {
    indices.push(gridSize - 1 - i); // Top row, from right to left
  }
  return indices.sort((a, b) => a - b); // Sort ascending for easier use
}

// Helper to get triangle pattern (3, 2, 1) in top right corner for 6 dots
function getTrianglePatternIndices(gridSize) {
  // Triangle pattern in top-right corner:
  // 3 dots in first row, 2 dots in second row, 1 dot in third row
  // All touching the right side
  // For 4x4: row 0 has cols 1,2,3; row 1 has cols 2,3; row 2 has col 3
  // Indices: [1, 2, 3, 6, 7, 11]
  const indices = [];
  
  // Row 0 (first row): 3 dots - cols gridSize-3, gridSize-2, gridSize-1
  if (gridSize >= 3) {
    indices.push(0 * gridSize + (gridSize - 3));
    indices.push(0 * gridSize + (gridSize - 2));
    indices.push(0 * gridSize + (gridSize - 1));
  }
  
  // Row 1 (second row): 2 dots - cols gridSize-2, gridSize-1
  if (gridSize >= 2) {
    indices.push(1 * gridSize + (gridSize - 2));
    indices.push(1 * gridSize + (gridSize - 1));
  }
  
  // Row 2 (third row): 1 dot - col gridSize-1
  indices.push(2 * gridSize + (gridSize - 1));
  
  return indices;
}

// Helper to get 2x2 square in top right corner
function get2x2TopRightIndices(gridSize) {
  // 2x2 square in top right: rows 0-1, cols gridSize-2 to gridSize-1
  const indices = [];
  for (let row = 0; row < 2 && row < gridSize; row++) {
    for (let col = gridSize - 2; col < gridSize; col++) {
      indices.push(row * gridSize + col);
    }
  }
  return indices;
}

// Helper to get 3x3 square in top right corner
function get3x3TopRightIndices(gridSize) {
  // 3x3 square in top right: rows 0-2, cols gridSize-3 to gridSize-1
  const indices = [];
  for (let row = 0; row < 3 && row < gridSize; row++) {
    for (let col = gridSize - 3; col < gridSize; col++) {
      indices.push(row * gridSize + col);
    }
  }
  return indices;
}

// Helper to get 5 dots pattern (2 in top row, 3 in row below)
function get5DiagonalPatternIndices(gridSize) {
  // 5 dots: 2 dots in top row, 3 dots in row below, all in top-right corner
  // For 5x5: row 0 has cols 3,4; row 1 has cols 2,3,4
  // Indices: [3, 4, 7, 8, 9]
  const indices = [];
  
  // Row 0 (top row): 2 dots - cols gridSize-2, gridSize-1
  if (gridSize >= 2) {
    indices.push(0 * gridSize + (gridSize - 2));
    indices.push(0 * gridSize + (gridSize - 1));
  }
  
  // Row 1 (row below): 3 dots - cols gridSize-3, gridSize-2, gridSize-1
  if (gridSize >= 3) {
    indices.push(1 * gridSize + (gridSize - 3));
    indices.push(1 * gridSize + (gridSize - 2));
    indices.push(1 * gridSize + (gridSize - 1));
  }
  
  return indices;
}

// Helper function to get dot number from index for square 1225
// Pattern: Row 0 goes right to left, Row 1+ goes left to right
function getDotNumberFromIndex1225(idx, gridSize) {
  const row = Math.floor(idx / gridSize);
  const col = idx % gridSize;
  if (row === 0) {
    // First row: number from right to left
    return gridSize - col;
  } else {
    // Subsequent rows: number left to right
    return gridSize + (row - 1) * gridSize + col + 1;
  }
}

// Generic helper function for squares 36×36 through 50×50
// Pattern: Every row goes right to left (zigzag pattern)
function getDotNumberFromIndex36to50(idx, gridSize) {
  const row = Math.floor(idx / gridSize);
  const col = idx % gridSize;
  // Every row goes right to left
  return row * gridSize + (gridSize - col);
}

// Helper function to break down a number into components
function breakDownNumber(num) {
  const str = num.toString();
  const components = [];
  
  if (str.length === 2) {
    // Two-digit: tens and ones
    const tens = parseInt(str[0]) * 10;
    const ones = parseInt(str[1]);
    components.push(tens, ones);
  } else if (str.length === 3) {
    // Three-digit: hundreds, tens, ones
    const hundreds = parseInt(str[0]) * 100;
    const tens = parseInt(str[1]) * 10;
    const ones = parseInt(str[2]);
    components.push(hundreds, tens, ones);
  } else if (str.length === 4) {
    // Four-digit: thousands, hundreds, tens, ones
    // But for squares 31×31 to 50×50, we want to break down based on the pattern
    // Example: 1024 = 1000 + 20 + 4, not 1000 + 0 + 24
    const thousands = parseInt(str[0]) * 1000;
    const remainder = parseInt(str.substring(1));
    if (remainder < 100) {
      // If remainder is 2-digit, treat as tens and ones
      const tens = Math.floor(remainder / 10) * 10;
      const ones = remainder % 10;
      components.push(thousands, tens, ones);
    } else {
      // If remainder is 3-digit, treat as hundreds, tens, ones
      const hundreds = Math.floor(remainder / 100) * 100;
      const tens = Math.floor((remainder % 100) / 10) * 10;
      const ones = remainder % 10;
      components.push(thousands, hundreds, tens, ones);
    }
  }
  
  return components;
}

// Color mapping for different numbers
const COLOR_MAP = {
  1: "red", 2: "orange", 3: "yellow", 4: "green", 5: "blue",
  6: "purple", 7: "brown", 8: "pink", 9: "sky", 10: "red-final"
};

// NUMBER 16 – two clicks: first 10 red, then 6 purple (triangle in top-right)
let sixteenClickCount = 0;
const sixteenCircles = Array.from(document.querySelectorAll("#sixteen .circle"));
const section16 = sixteenCircles[0].closest('.set');
const answerDisplay16 = section16.querySelector('.answer-display');
let clickCount16 = 0;
const gridSize16 = 4;
const topRightIndices16 = getTrianglePatternIndices(gridSize16); // 6 dots as triangle

sixteenCircles.forEach(circle => {
  circle.addEventListener("click", () => {
    if (sixteenClickCount === 0) {
      // Fill 10 red dots, excluding the top-right triangle area
      const alreadyFilled = new Set();
      sixteenCircles.forEach((c, i) => {
        if (c.classList.contains("red") || c.classList.contains("purple") || 
            c.classList.contains("orange") || c.classList.contains("yellow") ||
            c.classList.contains("green") || c.classList.contains("blue") ||
            c.classList.contains("brown") || c.classList.contains("pink") ||
            c.classList.contains("sky") || c.classList.contains("red-final")) {
          alreadyFilled.add(i);
        }
      });
      
      // Fill from bottom-left, excluding top-right triangle
      // Collect all available indices first, then take 10
      const allIndices = [];
      for (let row = gridSize16 - 1; row >= 0; row--) {
        for (let col = 0; col < gridSize16; col++) {
          const idx = row * gridSize16 + col;
          if (!topRightIndices16.includes(idx) && !alreadyFilled.has(idx)) {
            allIndices.push(idx);
          }
        }
      }
      const indicesToFill = allIndices.slice(0, 10);
      
      indicesToFill.forEach(i => {
        const c = sixteenCircles[i];
        c.classList.remove(...COLOR_CLASSES);
        c.classList.add("red");
      });
      sixteenClickCount = 1;
      speakNumber(10);
    } else if (sixteenClickCount === 1) {
      // Fill 6 purple dots in triangle pattern in top-right
      topRightIndices16.forEach(i => {
        const c = sixteenCircles[i];
        c.classList.remove(...COLOR_CLASSES);
        c.classList.add("purple");
      });
      sixteenClickCount = 2;
      speakNumber(16);
      // All dots are now filled (10 red + 6 purple = 16), show the answer
      answerDisplay16.textContent = '16';
      answerDisplay16.classList.add('show');
    } else {
      sixteenCircles.forEach(c => {
        c.classList.remove("red", "purple", ...COLOR_CLASSES);
      });
      sixteenClickCount = 0;
      answerDisplay16.textContent = '';
      answerDisplay16.classList.remove('show');
      speakNumber(0);
    }
  });
});

// Generate all squares from 5^2 to 25^2
function generateSquare(n) {
  const square = n * n;
  const gridSize = n;
  
  // Create section
  const section = document.createElement('section');
  section.className = 'set';
  section.dataset.square = square;
  section.dataset.base = n;
  
  const h2 = document.createElement('h2');
  h2.textContent = `${n}²`;
  section.appendChild(h2);
  
  const grid = document.createElement('div');
  grid.className = `grid-dynamic`;
  grid.id = `square-${square}`;
  grid.style.gridTemplateColumns = `repeat(${gridSize}, var(--circle-total))`;
  grid.style.gridTemplateRows = `repeat(${gridSize}, var(--circle-total))`;
  grid.style.width = `calc(var(--circle-total) * ${gridSize})`;
  grid.style.height = `calc(var(--circle-total) * ${gridSize})`;
  
  // For 256, 225, 441, 1156, and 1225, make grid position relative so we can absolutely position separated dots relative to it
  // 841 doesn't need relative positioning since dots don't move
  // For squares that may have separated/moving dots, make grid position relative
  if (square === 256 || square === 225 || square === 441 || square === 1156 || square === 1225 || (square > 1225 && square <= 2500)) {
    grid.style.position = 'relative';
  }
  
  // For 26×26 through 29×29, make grid bigger to accommodate numbers
  // But exclude 676, 729, 784, 841 and 900 - keep them smaller
  
  // For 35×35 through 50×50, make grid bigger to accommodate numbers
  // 1156 (34×34) and 1225 (35×35) use regular size like square 33
  if (square > 1156 && square <= 2500) {
    grid.classList.add(`grid-${square}`);
  }
  
  // Create circles
  for (let i = 0; i < square; i++) {
    const circle = document.createElement('div');
    circle.className = 'circle';
    // For 26×26 through 29×29, add numbers inside each circle and make circles bigger
    // But exclude 676, 729, 784, 841 and 900 - keep them smaller
    // For 34×34 through 50×50, add numbers with special numbering:
    // Top-right 10×10 = 1-100, Top-left 10×10 = 101-200
    // For 1156, use sequential numbering 1-1156
    if (square === 1156) {
      // Add circle class for sizing (same size as square 33)
      circle.classList.add(`circle-${square}`);
      
      // Calculate row and column for this circle
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      
      let dotNumber;
      if (row === 0) {
        // First row: number from right to left (col 33 = 1, col 32 = 2, ..., col 0 = 34)
        dotNumber = gridSize - col; // col 33 → 1, col 32 → 2, ..., col 0 → 34
      } else {
        // Subsequent rows: number left to right
        // Row 1 starts at 35 (after row 0's 34 dots)
        // Row r starts at: 34 + (r - 1) * 34 + 1 + col = 34 + (r - 1) * 34 + col + 1
        dotNumber = gridSize + (row - 1) * gridSize + col + 1;
      }
      
      // Store dot number in data attribute (no visible number displayed)
      circle.dataset.dotNumber = dotNumber.toString();
    } else if (square === 1225) {
      // For 1225 (35×35), number from top-right corner going left, then down left-to-right
      // Row 0: top-right (col 34) = 1, going left to top-left (col 0) = 35
      // Row 1+: continue left-to-right (col 0 = 36, col 1 = 37, etc.)
      // Add circle class for sizing (same size as square 33)
      circle.classList.add(`circle-${square}`);
      
      // Calculate row and column for this circle
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      
      let dotNumber;
      if (row === 0) {
        // First row: number from right to left (col 34 = 1, col 33 = 2, ..., col 0 = 35)
        dotNumber = gridSize - col; // col 34 → 1, col 33 → 2, ..., col 0 → 35
      } else {
        // Subsequent rows: number left to right
        // Row 1 starts at 36 (after row 0's 35 dots)
        // Row r starts at: 35 + (r - 1) * 35 + 1 + col = 35 + (r - 1) * 35 + col + 1
        dotNumber = gridSize + (row - 1) * gridSize + col + 1;
      }
      
      // Store dot number in data attribute (no visible number displayed)
      circle.dataset.dotNumber = dotNumber.toString();
    } else if (square > 1225 && square <= 2500) {
      // For squares 36×36 (1296) through 50×50 (2500), number from top-right corner going left
      // Row 0: right to left (col gridSize-1 = 1, col gridSize-2 = 2, ..., col 0 = gridSize)
      // Row 1+: also right to left (zigzag pattern - every row goes right to left)
      // Add circle class for sizing
      circle.classList.add(`circle-${square}`);
      
      // Calculate row and column for this circle
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      
      let dotNumber;
      // Every row goes right to left
      // Row 0: col gridSize-1 = 1, col gridSize-2 = 2, ..., col 0 = gridSize
      // Row 1: col gridSize-1 = gridSize+1, col gridSize-2 = gridSize+2, ..., col 0 = gridSize*2
      // Row r: starts at r * gridSize + 1, goes right to left
      dotNumber = row * gridSize + (gridSize - col);
      
      // Store dot number in data attribute (not displayed)
      circle.dataset.dotNumber = dotNumber.toString();
    }
    grid.appendChild(circle);
  }
  
  section.appendChild(grid);
  
  // Add answer display
  const answerDisplay = document.createElement('div');
  answerDisplay.className = 'answer-display';
  answerDisplay.dataset.answer = square;
  section.appendChild(answerDisplay);
  
  // Setup click handlers
  const circles = Array.from(grid.querySelectorAll('.circle'));
  let clickCount = 0;
  // Track separated circles for 256 and 225
  const separatedCircles = [];
  let components = breakDownNumber(square);
  // Special: 900 - just one click, all 900 dots sky blue
  if (square === 900) {
    components = [900];
  }
  // Special: 1225 - 1000 red, then 200 orange, then 20 orange, then 5 blue
  if (square === 1225) {
    components = [1000, 200, 20, 5];
  }
  // Special: 1296 - 1000 red (first click), nothing (second click), 90 sky blue (third click), 6 purple (fourth click)
  if (square === 1296) {
    components = [1000, 0, 90, 6];
  }
  // For squares 31×31 to 50×50, map to corresponding smaller square patterns
  // Pattern: n×n maps to (60-n)×(60-n) for the last 2 digits
  // Example: 31×31 (961) maps to 19×19 (361) for the 61 pattern
  const sourceSquare = n > 30 ? (60 - n) * (60 - n) : null;
  const totalClicks = components.length;
  
  // Get top right corner indices for ones place
  const onesValue = components[components.length - 1];
  let topRightIndices = [];
  
  // Special patterns for ones place - ALL ones place numbers go in top right corner
  // 6 dots: purple triangle pattern in top-right corner (for 16, 36, 196, 256, 576)
  // 9 dots: sky blue 3x3 square in top-right corner (for 49, 169, 289, 529)
  if (onesValue === 6) {
    // Triangle pattern for 6 (1, 2, 3 diagonal) - PURPLE
    topRightIndices = getTrianglePatternIndices(gridSize);
  } else if (onesValue === 4) {
    // 2x2 square for 4 (including 324)
    topRightIndices = get2x2TopRightIndices(gridSize);
  } else if (onesValue === 9) {
    // 3x3 square for 9 - SKY BLUE
    topRightIndices = get3x3TopRightIndices(gridSize);
  } else if (onesValue === 5) {
    // For 225: 5 blue dots in a vertical line in the rightmost column of the 5×5 rectangle (col 14, rows 0-4)
    // For 25: 5 blue dots in a vertical line in the rightmost column (col 4, rows 0-4)
    // For 625: 5 blue dots are dots 21-25 (row 0, cols 20-24)
    // For other squares: 2x2 square + 1 diagonal for 5
    if (square === 225) {
      // Vertical line: 5 dots in column 14 (rightmost column of the 5×5), rows 0-4
      topRightIndices = [];
      for (let row = 0; row < 5 && row < gridSize; row++) {
        topRightIndices.push(row * gridSize + 14);
      }
    } else if (square === 25) {
      // Vertical line: 5 dots in column 4 (rightmost column), rows 0-4
      topRightIndices = [];
      for (let row = 0; row < 5 && row < gridSize; row++) {
        topRightIndices.push(row * gridSize + 4);
      }
    } else if (square === 625) {
      // Dots 25, 50, 75, 100, 125 are blue on 3rd click
      topRightIndices = [];
      for (let dot of [25, 50, 75, 100, 125]) {
        topRightIndices.push(dot - 1); // Convert to index
      }
    } else {
      topRightIndices = get5DiagonalPatternIndices(gridSize);
    }
  } else if (onesValue === 1 && square === 441) {
    // For 441: 1 red dot at top right corner (row 0, col 20), will be offset
    topRightIndices = [0 * gridSize + 20];
  } else if (onesValue === 1 && square === 841) {
    // For 841: 1 red dot at top right corner (row 0, col 28), will be offset
    topRightIndices = [0 * gridSize + 28];
  } else {
    // Default: top row rightmost positions
    topRightIndices = getTopRightCornerIndices(gridSize, onesValue);
  }
  
  // Helper to get bottom left indices (for hundreds place)
  function getBottomLeftIndices(gridSize, count) {
    const indices = [];
    // Start from bottom row, left side
    for (let row = gridSize - 1; row >= 0 && indices.length < count; row--) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!topRightIndices.includes(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get upper left indices (for tens place when needed)
  function getUpperLeftIndices(gridSize, count) {
    const indices = [];
    // Start from top row, left side
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!topRightIndices.includes(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get indices around ones place (for tens place separation in 3-digit numbers)
  function getIndicesAroundOnes(gridSize, count, topRightIndices, alreadyFilled) {
    const indices = [];
    const topRightSet = new Set(topRightIndices);
    const filledSet = new Set(alreadyFilled);
    
    // Get positions around the top right corner, working inward
    // Start from top rows, near the right side but not in ones place
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = gridSize - 1; col >= 0 && indices.length < count; col--) {
        const idx = row * gridSize + col;
        if (!topRightSet.has(idx) && !filledSet.has(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Helper to get upper left indices (for tens place in 2-digit numbers, or second component in 3-digit)
  function getUpperLeftIndices(gridSize, count, excludeIndices, alreadyFilled) {
    const indices = [];
    const excludeSet = new Set(excludeIndices || []);
    const filledSet = new Set(alreadyFilled || []);
    
    // Start from top row, left side
    for (let row = 0; row < gridSize && indices.length < count; row++) {
      for (let col = 0; col < gridSize && indices.length < count; col++) {
        const idx = row * gridSize + col;
        if (!excludeSet.has(idx) && !filledSet.has(idx)) {
          indices.push(idx);
        }
      }
    }
    return indices.slice(0, count);
  }
  
  // Make the entire grid clickable, not just individual circles
  grid.addEventListener("click", (e) => {
    // Ignore clicks on separated circles (they have data-originalRow attribute)
    if (e.target.dataset.originalRow !== undefined) {
      return;
    }
    
    // Check if we should reset (clicking after all components are filled)
    // For 441: clickCount will be 3 after 3 clicks (0, 1, 2), so 4th click should reset
    // Also check if answer is already showing (for numbers like 100 where we show answer early)
    const answerIsShowing = answerDisplay && answerDisplay.classList.contains('show');
    const nonZeroComponents = components.filter(c => c > 0);
    const processedNonZero = components.slice(0, clickCount).filter(c => c > 0).length;
    if (clickCount >= totalClicks || (answerIsShowing && processedNonZero >= nonZeroComponents.length)) {
      // Complete reset - go back to initial state (all black dots, nothing colored, nothing hidden)
      // For 441, be extra aggressive about removing the red dot
      if (square === 441) {
        // Remove ALL red circles first (most aggressive)
        const allRed = grid.querySelectorAll('.circle.red');
        allRed.forEach(rc => {
          // Remove if it's not in the original circles array (it's a separated circle)
          if (rc && rc.parentNode && !circles.includes(rc)) {
            rc.parentNode.removeChild(rc);
          }
        });
        
        // Remove all absolutely positioned circles (separated circles)
        const allAbsolute = Array.from(grid.children).filter(child => 
          child.style && child.style.position === 'absolute' && !circles.includes(child)
        );
        allAbsolute.forEach(ac => {
          if (ac && ac.parentNode) {
            ac.parentNode.removeChild(ac);
          }
        });
      }
      
      // Remove from the array
      separatedCircles.forEach(sc => {
        if (sc && sc.parentNode) {
          sc.parentNode.removeChild(sc);
        }
      });
      separatedCircles.length = 0;
      
      // Remove ALL separated circles by data attributes (these are the ones we created)
      const allSeparated = grid.querySelectorAll('[data-original-row][data-original-col]');
      allSeparated.forEach(sc => {
        // Only remove if it's NOT in the original circles array (it's a separated circle we created)
        if (sc && sc.parentNode && !circles.includes(sc)) {
          sc.parentNode.removeChild(sc);
        }
      });
      
      // Now completely reset ALL ORIGINAL circles to initial state
      circles.forEach(c => {
        // Remove all color classes INCLUDING "red" (red is not in COLOR_CLASSES array)
        c.classList.remove('red', ...COLOR_CLASSES);
        // Reset all styles to initial state
        c.style.visibility = '';
        c.style.display = '';
        c.style.position = '';
        c.style.zIndex = '';
        c.style.left = '';
        c.style.top = '';
        c.style.opacity = '';
      });
      
      // Aggressive check for ALL squares: remove ANY remaining red circles that are children of grid
      // This ensures no red dots are left behind (like for 81, 100, 441, etc.)
      const allGridChildren = Array.from(grid.children);
      allGridChildren.forEach(child => {
        if (child.classList && child.classList.contains('red') && !circles.includes(child)) {
          if (child && child.parentNode) {
            child.parentNode.removeChild(child);
          }
        }
        // Also remove red class from any circles that might still have it
        if (child.classList && child.classList.contains('red') && circles.includes(child)) {
          child.classList.remove('red');
        }
      });
      
      // Extra check for 441: explicitly ensure row 0, col 20 is black and visible
      if (square === 441) {
        const idx = 0 * gridSize + 20;
        if (circles[idx]) {
          // Force remove red class
          circles[idx].classList.remove('red', ...COLOR_CLASSES);
          circles[idx].style.visibility = '';
          circles[idx].style.display = '';
          circles[idx].style.position = '';
          circles[idx].style.zIndex = '';
          circles[idx].style.left = '';
          circles[idx].style.top = '';
          circles[idx].style.opacity = '';
        }
      }
      
      // Extra check for 81 (9×9): ensure all red dots are removed
      if (square === 81) {
        circles.forEach(c => {
          c.classList.remove('red', ...COLOR_CLASSES);
        });
      }
      
      // Extra check for 100 (10×10): ensure all red dots are removed
      if (square === 100) {
        circles.forEach(c => {
          c.classList.remove('red', ...COLOR_CLASSES);
        });
      }
      
      // Reset click count and display
      clickCount = 0;
      answerDisplay.textContent = '';
      answerDisplay.classList.remove('show');
      speakNumber(0);
      return;
    }
    
    // Process clicks on the grid itself or on regular circles
    if (clickCount < totalClicks) {
        const componentValue = components[clickCount];
        const isOnesPlace = (clickCount === totalClicks - 1);
        // For place detection: first component is "hundreds" place (even if it's thousands),
        // second is "tens" place, last is "ones" place
        // This works for both 3-digit (e.g., 289 = [200, 80, 9]) and 4-digit numbers that break down to 3 components (e.g., 1089 = [1000, 80, 9])
        const isHundredsPlace = (clickCount === 0 && components.length >= 3);
        const isTensPlace = (clickCount === 1 && components.length >= 3) || (clickCount === 0 && components.length === 2);
        
        // Initialize indicesToFill early so it can be set by special handlers
        let indicesToFill = [];
        let is1296SpecialClick = false;
        
        // Track already filled indices (check for any color class) - needed by handlers
        const alreadyFilled = new Set();
        circles.forEach((c, i) => {
          if (c.classList.contains("red") || c.classList.contains("orange") || 
              c.classList.contains("yellow") || c.classList.contains("green") ||
              c.classList.contains("blue") || c.classList.contains("purple") ||
              c.classList.contains("brown") || c.classList.contains("pink") ||
              c.classList.contains("sky") || c.classList.contains("red-final")) {
            alreadyFilled.add(i);
          }
        });
        
        // If component value is 0, skip filling but still increment clickCount
        // Exception: square 1225 second click has 200 dots, not 0
        // Exception: square 1296 second click should fill remaining black dots orange
        if (componentValue === 0 && !(square === 1225 && clickCount === 1) && !(square === 1296 && clickCount === 1)) {
          clickCount++;
          if (square === 1296) {
            // For 1296, speak cumulative totals: "1000", "1200", "1290", "1296"
            // Components are [1000, 0, 90, 6], but we treat the second as 200 for cumulative
            let cumulativeTotal;
            if (clickCount === 1) {
              cumulativeTotal = 1000;
            } else if (clickCount === 2) {
              cumulativeTotal = 1200; // 1000 + 200
            } else if (clickCount === 3) {
              cumulativeTotal = 1290; // 1000 + 200 + 90
            } else if (clickCount === 4) {
              cumulativeTotal = 1296; // 1000 + 200 + 90 + 6
            } else {
              cumulativeTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
            }
            speakNumber(cumulativeTotal);
          } else {
            const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
            speakNumber(currentTotal);
          }
          
          // Show answer when all components are processed
          // For numbers like 100 where components are [100, 0, 0], show answer after processing non-zero components
          const nonZeroComponents = components.filter(c => c > 0);
          const processedNonZero = components.slice(0, clickCount).filter(c => c > 0).length;
          if ((clickCount >= totalClicks || processedNonZero >= nonZeroComponents.length) && answerDisplay) {
            answerDisplay.textContent = square;
            answerDisplay.classList.add('show');
          }
          return; // Exit early, don't try to fill 0 dots
        }
        
        // For 1296 second click, fill remaining black dots orange
        if (square === 1296 && clickCount === 1 && componentValue === 0) {
          // Second click: Fill all remaining black dots (that will still be black after 4th click) with orange
          // Red dots (first click): 281-288, 297-324, 333-360, 361-1296
          const redDotNumbers = new Set();
          for (let dot = 281; dot <= 288; dot++) redDotNumbers.add(dot);
          for (let dot = 297; dot <= 324; dot++) redDotNumbers.add(dot);
          for (let dot = 333; dot <= 360; dot++) redDotNumbers.add(dot);
          for (let dot = 361; dot <= 1296; dot++) redDotNumbers.add(dot);
          
          // Sky blue dots (third click): 4-10, 39-46, 74-82, 109-118, 145-154, 181-190, 217-226, 253-262, 289-297, 325-332, 360-367
          const skyBlueDotNumbers = new Set();
          for (let dot = 4; dot <= 10; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 39; dot <= 46; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 74; dot <= 82; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 109; dot <= 118; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 145; dot <= 154; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 181; dot <= 190; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 217; dot <= 226; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 253; dot <= 262; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 289; dot <= 297; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 325; dot <= 332; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 360; dot <= 367; dot++) skyBlueDotNumbers.add(dot);
          
          // Purple dots (fourth click): triangle pattern (6 dots at top-right)
          const topRightIndices1296 = getTrianglePatternIndices(gridSize);
          const purpleDotNumbers = new Set();
          topRightIndices1296.forEach(idx => {
            const circle = circles[idx];
            let dotNumber;
            if (circle && circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else if (circle) {
              const row = Math.floor(idx / gridSize);
              const col = idx % gridSize;
              dotNumber = row * gridSize + (gridSize - col);
            }
            if (dotNumber) purpleDotNumbers.add(dotNumber);
          });
          
          // Find all dots that are NOT red, sky blue, or purple (these will be black after 4th click)
          const orangeDotNumbers = [];
          for (let dot = 1; dot <= 1296; dot++) {
            if (!redDotNumbers.has(dot) && !skyBlueDotNumbers.has(dot) && !purpleDotNumbers.has(dot)) {
              orangeDotNumbers.push(dot);
            }
          }
          
          // Find circles by their dot numbers and fill with orange
          const allIndices = [];
          circles.forEach((circle, idx) => {
            let dotNumber;
            if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              const row = Math.floor(idx / gridSize);
              const col = idx % gridSize;
              dotNumber = row * gridSize + (gridSize - col);
            }
            
            if (dotNumber && orangeDotNumbers.includes(dotNumber) && !alreadyFilled.has(idx)) {
              allIndices.push(idx);
            }
          });
          
          indicesToFill = allIndices;
          is1296SpecialClick = true;
          // Note: clickCount will be incremented after filling, and voice feedback will happen then
        } else if (square === 1296 && clickCount === 2) {
          // Third click: Fill specific dot numbers with sky blue
          // Dot numbers: 4-10, 39-46, 74-82, 109-118, 145-154, 181-190, 217-226, 253-262, 289-297, 325-332, 360-367
          is1296SpecialClick = true;
          // Ensure we don't return early - continue to filling
          const skyBlueDotNumbers = new Set();
          for (let dot = 4; dot <= 10; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 39; dot <= 46; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 74; dot <= 82; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 109; dot <= 118; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 145; dot <= 154; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 181; dot <= 190; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 217; dot <= 226; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 253; dot <= 262; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 289; dot <= 297; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 325; dot <= 332; dot++) skyBlueDotNumbers.add(dot);
          for (let dot = 360; dot <= 367; dot++) skyBlueDotNumbers.add(dot);
          
          // Find circles by their dot numbers
          const allIndices = [];
          circles.forEach((circle, idx) => {
            let dotNumber;
            if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              const row = Math.floor(idx / gridSize);
              const col = idx % gridSize;
              dotNumber = row * gridSize + (gridSize - col);
            }
            if (dotNumber && skyBlueDotNumbers.has(dotNumber)) {
              // Include even if already filled - we'll change them to sky blue
              allIndices.push(idx);
            }
          });
          indicesToFill = allIndices;
        } else if (square === 1296 && clickCount === 3) {
          // Fourth click: Fill 6 purple dots (the top-right corner pattern)
          is1296SpecialClick = true;
          const topRightIndices1296 = getTrianglePatternIndices(gridSize);
          indicesToFill = topRightIndices1296.filter(i => !alreadyFilled.has(i));
        }
        
        // For 1156: second click fills remaining black dots red and moves them up
        // Third click fills specific dots blue
        // Note: Second click (clickCount === 1) will proceed to fill red dots
        
        // Get color based on first digit of component
        const componentStr = componentValue.toString();
        const firstDigit = parseInt(componentStr[0]);
        const colorKey = firstDigit || 10;
        let color = COLOR_MAP[colorKey] || "red";
        
        // Special: 625 and 676 first click (hundreds) should be purple, not yellow
        if ((square === 625 || square === 676) && isHundredsPlace && components.length === 3) {
          color = "purple";
        }
        
        // Special: 729 and 784 first click (700) should be brown (following pattern of 7s being brown)
        if ((square === 729 || square === 784) && isHundredsPlace && components.length === 3) {
          color = "brown";
        }
        
        // Special: 625 and 729 second click (tens) should be orange
        if ((square === 625 || square === 729) && isTensPlace && components.length === 3) {
          color = "orange";
        }
        
        // Special: 784 second click (80) should be pink
        if (square === 784 && isTensPlace && components.length === 3) {
          color = "pink";
        }
        
        // Special: 676 second click should be brown
        if (square === 676 && isTensPlace && components.length === 3) {
          color = "brown";
        }
        
        // Special: 729 third click (ones) should be sky blue, matching 529 pattern
        if (square === 729 && isOnesPlace && components.length === 3) {
          color = "sky";
        }
        
        // Special: 784 third click (ones) should be green (2×2 square)
        if (square === 784 && isOnesPlace && components.length === 3) {
          color = "green";
        }
        
        // Special: 841 first click (800) should be pink (following pattern of 8s being pink)
        if (square === 841 && isHundredsPlace && components.length === 3) {
          color = "pink";
        }
        
        // Special: 841 second click (40) should be green (following pattern of 4s being green)
        if (square === 841 && isTensPlace && components.length === 3) {
          color = "green";
        }
        
        // Special: 841 third click (ones) should be red (1 red dot)
        if (square === 841 && isOnesPlace && components.length === 3) {
          color = "red";
        }
        
        // Special: 900 - all 900 dots should be sky blue on first (and only) click
        if (square === 900) {
          color = "sky";
        }
        
        // For squares 31×31 to 50×50, determine colors based on source square pattern
        if (square >= 961 && square <= 2500 && n > 30) {
          // Find the source square with the same last 2 digits
          const lastTwoDigits = square % 100;
          let sourceN = 0;
          let sourceSquare = 0;
          // Find the smaller square with the same last 2 digits
          for (let i = 1; i < n; i++) {
            const testSquare = i * i;
            if (testSquare % 100 === lastTwoDigits) {
              sourceN = i;
              sourceSquare = testSquare;
              break;
            }
          }
          // Map colors from source square patterns
          if (sourceSquare === 361) {
            // 31×31 (961) maps to 19×19 (361): 900 (hundreds), 60 purple (tens), 1 red (ones)
            if (isHundredsPlace) {
              // Determine color based on first digit of hundreds (9 = sky blue, but 900 is special)
              // Actually, 900 should be sky blue, but we're breaking it down as 900 + 60 + 1
              // So hundreds is 900, which starts with 9, so sky blue
              color = "sky";
            } else if (isTensPlace) {
              color = "purple"; // 60 purple
            } else if (isOnesPlace) {
              color = "red"; // 1 red
            }
          } else if (sourceSquare === 324) {
            // 32×32 (1024) maps to 18×18 (324): 1000 (hundreds), 20 orange (tens), 4 green (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 starts with 1
            } else if (isTensPlace) {
              color = "orange"; // 20 orange
            } else if (isOnesPlace) {
              color = "green"; // 4 green
            }
          } else if (sourceSquare === 289) {
            // 33×33 (1089) maps to 17×17 (289): 1000 (hundreds), 80 pink (tens), 9 sky blue (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 starts with 1
            } else if (isTensPlace) {
              color = "pink"; // 80 pink
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue
            }
          } else if (sourceSquare === 256) {
            // 34×34 (1156) maps to 16×16 (256): 1000 (hundreds), 100 red (tens), 50 blue (third click), 6 purple (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1000 starts with 1
            } else if (square === 1156 && clickCount === 1) {
              color = "red"; // Second click: red dots
            } else if (square === 1156 && clickCount === 2) {
              color = "blue"; // Third click: blue dots
            } else if (isOnesPlace) {
              color = "purple"; // 6 purple
            }
          } else if (sourceSquare === 225 || square === 1225) {
            if (square === 1225) {
              // 35×35 (1225): 1000 red (first click), 200 orange (second click), 20 orange (third click), 5 blue (fourth click)
              if (clickCount === 0) {
                color = "red"; // 1000 red dots
              } else if (clickCount === 1) {
                color = "orange"; // 200 orange dots
              } else if (clickCount === 2) {
                color = "orange"; // 20 orange dots
              } else if (clickCount === 3) {
                color = "blue"; // 5 blue dots
              }
            } else {
              // Original 225 mapping for other squares
              // 35×35 (1225) maps to 15×15 (225): 1200 (hundreds), 20 orange (tens), 5 blue (ones)
              if (isHundredsPlace) {
                color = COLOR_MAP[1] || "red"; // 1200 starts with 1
              } else if (isTensPlace) {
                color = "orange"; // 20 orange
              } else if (isOnesPlace) {
                color = "blue"; // 5 blue
              }
            }
          } else if (sourceSquare === 196) {
            // 36×36 (1296): 1000 red (first click), orange (second click), 90 sky blue (third click), 6 purple (fourth click)
            if (square === 1296) {
              if (clickCount === 0) {
                color = "red"; // 1000 red dots
              } else if (clickCount === 1) {
                color = "orange"; // Remaining black dots turn orange
              } else if (clickCount === 2) {
                color = "sky"; // 90 sky blue dots
              } else if (clickCount === 3) {
                color = "purple"; // 6 purple dots
              }
            } else {
              // Other squares mapping to 196: 1200 (hundreds), 90 purple (tens), 6 purple (ones)
              if (isHundredsPlace) {
                color = COLOR_MAP[1] || "red"; // 1200 starts with 1
              } else if (isTensPlace || isOnesPlace) {
                color = "purple"; // 90 purple and 6 purple
              }
            }
          } else if (sourceSquare === 169) {
            // 37×37 (1369) maps to 13×13 (169): 1300 (hundreds), 60 purple (tens), 9 sky blue (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1300 starts with 1
            } else if (isTensPlace) {
              color = "purple"; // 60 purple
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue
            }
          } else if (sourceSquare === 144) {
            // 38×38 (1444) maps to 12×12 (144): 1400 (hundreds), 40 green (tens), 4 green (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1400 starts with 1
            } else if (isTensPlace || isOnesPlace) {
              color = "green"; // 40 green and 4 green
            }
          } else if (sourceSquare === 121) {
            // 39×39 (1521) maps to 11×11 (121): 1500 (hundreds), 20 orange (tens), 1 red (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1500 starts with 1
            } else if (isTensPlace) {
              color = "orange"; // 20 orange
            } else if (isOnesPlace) {
              color = "red"; // 1 red
            }
          } else if (sourceSquare === 100) {
            // 40×40 (1600) maps to 10×10 (100): 1600 (all filled on first click)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1600 starts with 1
            }
          } else if (sourceSquare === 81) {
            // 41×41 (1681) maps to 9×9 (81): 1600 (hundreds), 80 pink (tens), 1 red (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1600 starts with 1
            } else if (isTensPlace) {
              color = "pink"; // 80 pink
            } else if (isOnesPlace) {
              color = "red"; // 1 red
            }
          } else if (sourceSquare === 64) {
            // 42×42 (1764) maps to 8×8 (64): 1700 (hundreds), 60 purple (tens), 4 green (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1700 starts with 1
            } else if (isTensPlace) {
              color = "purple"; // 60 purple
            } else if (isOnesPlace) {
              color = "green"; // 4 green
            }
          } else if (sourceSquare === 49) {
            // 43×43 (1849) maps to 7×7 (49): 1800 (hundreds), 40 green (tens), 9 sky blue (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1800 starts with 1
            } else if (isTensPlace) {
              color = "green"; // 40 green
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue
            }
          } else if (sourceSquare === 36) {
            // 44×44 (1936) maps to 6×6 (36): 1900 (hundreds), 30 yellow (tens), 6 purple (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[1] || "red"; // 1900 starts with 1
            } else if (isTensPlace) {
              color = "yellow"; // 30 yellow
            } else if (isOnesPlace) {
              color = "purple"; // 6 purple
            }
          } else if (sourceSquare === 25) {
            // 45×45 (2025) maps to 5×5 (25): 2000 (hundreds), 20 orange (tens), 5 blue (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2000 starts with 2
            } else if (isTensPlace) {
              color = "orange"; // 20 orange
            } else if (isOnesPlace) {
              color = "blue"; // 5 blue
            }
          } else if (sourceSquare === 16) {
            // 46×46 (2116) maps to 4×4 (16): 2100 (hundreds), 10 red (tens), 6 purple (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2100 starts with 2
            } else if (isTensPlace) {
              color = "red"; // 10 red
            } else if (isOnesPlace) {
              color = "purple"; // 6 purple
            }
          } else if (sourceSquare === 9) {
            // 47×47 (2209) maps to 3×3 (9): 2200 (hundreds), 0 (tens), 9 sky blue (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2200 starts with 2
            } else if (isOnesPlace) {
              color = "sky"; // 9 sky blue
            }
          } else if (sourceSquare === 4) {
            // 48×48 (2304) maps to 2×2 (4): 2300 (hundreds), 0 (tens), 4 green (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2300 starts with 2
            } else if (isOnesPlace) {
              color = "green"; // 4 green
            }
          } else if (sourceSquare === 1) {
            // 49×49 (2401) maps to 1×1 (1): 2400 (hundreds), 0 (tens), 1 red (ones)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2400 starts with 2
            } else if (isOnesPlace) {
              color = "red"; // 1 red
            }
          } else if (sourceSquare === 0 || sourceN === 0) {
            // 50×50 (2500) maps to 0×0 (0): 2500 (all filled on first click)
            if (isHundredsPlace) {
              color = COLOR_MAP[2] || "orange"; // 2500 starts with 2
            }
          }
        }
        
        // Special: 676 - override component breakdown to [233, 227, 216] instead of [600, 70, 6]
        // This ensures voice says correct numbers: 233, 460 (233+227), 676 (233+227+216)
        if (square === 676) {
          // We'll handle the voice separately, but need to ensure correct totals
        }
        
        // alreadyFilled already calculated above for 1296 handlers
        // indicesToFill already declared above for 1296 special handling
        
        // Special handling for 1156 - third click fills specific dots blue
        if (square === 1156 && clickCount === 2) {
          // Third click: fill specific dots blue
          // Dots to turn blue: 4-8, 66-61, 101-95, 136-129, 170-163, 204-197, 238-231
          const blueDotNumbers = new Set();
          
          // Add all the dot number ranges
          for (let dot = 4; dot <= 8; dot++) blueDotNumbers.add(dot);
          for (let dot = 61; dot <= 66; dot++) blueDotNumbers.add(dot);
          for (let dot = 95; dot <= 101; dot++) blueDotNumbers.add(dot);
          for (let dot = 129; dot <= 136; dot++) blueDotNumbers.add(dot);
          for (let dot = 163; dot <= 170; dot++) blueDotNumbers.add(dot);
          for (let dot = 197; dot <= 204; dot++) blueDotNumbers.add(dot);
          for (let dot = 231; dot <= 238; dot++) blueDotNumbers.add(dot);
          
          // Convert dot numbers to indices by checking each circle's dot number
          const blueDots = [];
          circles.forEach((circle, idx) => {
            // For 1156, get dot number from data attribute or calculate from index
            let dotNumber;
            if (square === 1156) {
              if (circle.dataset.dotNumber) {
                dotNumber = parseInt(circle.dataset.dotNumber, 10);
              } else {
                // Calculate from index if data attribute not set
                const row = Math.floor(idx / gridSize);
                const col = idx % gridSize;
                if (row === 0) {
                  dotNumber = gridSize - col;
                } else {
                  dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                }
              }
            } else {
              const numberSpan = circle.querySelector('.circle-number');
              if (numberSpan) {
                dotNumber = parseInt(numberSpan.textContent, 10);
              }
            }
            if (dotNumber && blueDotNumbers.has(dotNumber)) {
              blueDots.push(idx);
            }
          });
          
          // Include all blue dots, even if they're already filled (red) - we'll change them to blue
          indicesToFill = blueDots;
        } else if (square === 1156 && clickCount === 1) {
          // Second click: fill remaining black dots red (excluding dots that will turn blue or purple)
          // Dots that will turn blue on 3rd click: 4-8, 61-66, 95-101, 129-136, 163-170, 197-204, 231-238
          // Dots that will turn purple on 4th click: 1, 2, 3, 67, 68, 102
          const blueDotNumbers = new Set();
          for (let dot = 4; dot <= 8; dot++) blueDotNumbers.add(dot);
          for (let dot = 61; dot <= 66; dot++) blueDotNumbers.add(dot);
          for (let dot = 95; dot <= 101; dot++) blueDotNumbers.add(dot);
          for (let dot = 129; dot <= 136; dot++) blueDotNumbers.add(dot);
          for (let dot = 163; dot <= 170; dot++) blueDotNumbers.add(dot);
          for (let dot = 197; dot <= 204; dot++) blueDotNumbers.add(dot);
          for (let dot = 231; dot <= 238; dot++) blueDotNumbers.add(dot);
          
          const purpleDotNumbers = new Set([1, 2, 3, 67, 68, 102]);
          
          // Find all black dots (dots that are not filled yet)
          const blackDots = [];
          circles.forEach((circle, idx) => {
            // For 1156, get dot number from data attribute or calculate from index
            let dotNumber;
            if (square === 1156) {
              if (circle.dataset.dotNumber) {
                dotNumber = parseInt(circle.dataset.dotNumber, 10);
              } else {
                // Calculate from index if data attribute not set
                const row = Math.floor(idx / gridSize);
                const col = idx % gridSize;
                if (row === 0) {
                  dotNumber = gridSize - col;
                } else {
                  dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                }
              }
            } else {
              const numberSpan = circle.querySelector('.circle-number');
              if (numberSpan) {
                dotNumber = parseInt(numberSpan.textContent, 10);
              }
            }
            if (dotNumber) {
              // Only include if it's not already filled AND not in blue/purple lists
              if (!alreadyFilled.has(idx) && !blueDotNumbers.has(dotNumber) && !purpleDotNumbers.has(dotNumber)) {
                blackDots.push(idx);
              }
            }
          });
          
          indicesToFill = blackDots;
        } else if (square === 900) {
          // Special handling for 900 - fill all 900 dots with sky blue on first (and only) click
          const allIndices = [];
          for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
              const idx = row * gridSize + col;
              allIndices.push(idx);
            }
          }
          // Fill all 900 dots
          indicesToFill = allIndices
            .filter(i => !alreadyFilled.has(i))
            .slice(0, componentValue);
        } else if (isOnesPlace) {
          // Ones place: use the pre-calculated top right indices
          if (square === 729) {
            // Special: 729 - explicitly fill the 3×3 square (rows 0-2, cols 24-26)
            const allIndices = [];
            for (let row = 0; row < 3 && row < gridSize; row++) {
              for (let col = 24; col < 27 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices;
          } else if (square === 784) {
            // Special: 784 - explicitly fill the 2×2 square (rows 0-1, cols 26-27)
            const allIndices = [];
            for (let row = 0; row < 2 && row < gridSize; row++) {
              for (let col = 26; col < 28 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices;
          } else if (square === 841) {
            // Special: 841 - explicitly fill the 1 red dot at top-right corner (row 0, col 28)
            const allIndices = [];
            const topRightIdx = 0 * gridSize + 28;
            if (!alreadyFilled.has(topRightIdx)) {
              allIndices.push(topRightIdx);
            }
            indicesToFill = allIndices;
          } else if (square >= 961 && square <= 2500 && n > 30 && isOnesPlace) {
            // For squares 31×31 (961) through 50×50 (2500), map ones place pattern from source square
            // Find the source square with the same last 2 digits
            const lastTwoDigits = square % 100;
            let sourceN = 0;
            let sourceSquare = 0;
            // Find the smaller square with the same last 2 digits
            for (let i = 1; i < n; i++) {
              const testSquare = i * i;
              if (testSquare % 100 === lastTwoDigits) {
                sourceN = i;
                sourceSquare = testSquare;
                break;
              }
            }
            const sourceGridSize = sourceN;
            
            if (sourceSquare === 361) {
              // 31×31 (961) maps to 19×19 (361) - 1 red dot at top-right corner
              // Map relative to top-right corner: row 0, col 18 in 19×19 → row 0, col 30 in 31×31
              const allIndices = [];
              const sourceGridSize = 19;
              const targetGridSize = gridSize;
              // Red dot is at top-right corner: row 0, col 18 in 19×19
              // Map to top-right corner in 31×31: row 0, col 30
              const sourceCol = 18; // Top-right corner in 19×19
              const distanceFromRight = sourceGridSize - 1 - sourceCol; // Should be 0
              const targetCol = targetGridSize - 1 - distanceFromRight; // Top-right corner in 31×31
              const targetRow = 0; // Top row
              const topRightIdx = targetRow * gridSize + targetCol;
              if (!alreadyFilled.has(topRightIdx)) {
                allIndices.push(topRightIdx);
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - 4 green dots in 2x2 square at top-right corner
              // Map relative to top-right corner: rows 0-1, cols 16-17 in 18×18 → rows 0-1, cols 30-31 in 32×32
              const allIndices = [];
              const sourceGridSize = 18;
              const targetGridSize = gridSize; // Should be 32
              // Map the 2x2 square: rows 0-1, cols 16-17 (top-right corner in 18×18)
              for (let sourceRow = 0; sourceRow < 2; sourceRow++) {
                for (let sourceCol = 16; sourceCol <= 17; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    if (!alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 289) {
              // 33×33 (1089) maps to 17×17 (289) - 9 sky blue dots in 3x3 square at top-right corner
              // Map relative to top-right corner: rows 0-2, cols 14-16 in 17×17 → rows 0-2, cols 30-32 in 33×33
              const allIndices = [];
              const sourceGridSize = 17;
              const targetGridSize = gridSize; // Should be 33
              // Map the 3x3 square: rows 0-2, cols 14-16 (top-right corner in 17×17)
              for (let sourceRow = 0; sourceRow < 3; sourceRow++) {
                for (let sourceCol = 14; sourceCol <= 16; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    if (!alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 225 || square === 1225) {
              if (square === 1225 && clickCount === 3) {
                // 35×35 (1225) - Fourth click: 5 blue dots in column 1 (rightmost), rows 0-4
                // These dots were moved up on the 3rd click, so we need to find the separated circles
                // Column 1 from right = column 34 (index)
                const allIndices = [];
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  const idx = row * gridSize + (gridSize - 1); // Column 34 (rightmost)
                  // Check if this dot was already moved (exists as separated circle)
                  const existingSeparated = separatedCircles.find(sc => {
                    const scRow = parseInt(sc.dataset.originalRow);
                    const scCol = parseInt(sc.dataset.originalCol);
                    return scRow === row && scCol === gridSize - 1;
                  });
                  if (existingSeparated) {
                    // This dot is already separated, we'll color it blue in the processing loop
                    // Add a special marker so we know to process it
                    allIndices.push(idx);
                  } else if (!alreadyFilled.has(idx)) {
                    // Dot is still in original position
                    allIndices.push(idx);
                  }
                }
                indicesToFill = allIndices;
              } else if (square === 1225) {
                // For other clicks, use default behavior
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices.slice(0, componentValue);
              } else {
                // Original 225 mapping logic for other squares
                const allIndices = [];
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  const idx = row * gridSize + (gridSize - 1);
                  if (!alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
                indicesToFill = allIndices;
              }
            } else if (sourceSquare === 169) {
              // 37×37 (1369) maps to 13×13 (169) - 9 sky blue dots in 3x3 square
              const allIndices = [];
              // Map the 3x3 square: rows 0-2, cols 10-12 → rows 0-2, cols (10+columnShift)-(12+columnShift)
              for (let row = 0; row < 3 && row < gridSize; row++) {
                for (let col = 10 + columnShift; col <= 12 + columnShift && col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 144) {
              // 38×38 (1444) maps to 12×12 (144) - 4 green dots in 2x2 square
              const allIndices = [];
              // Map the 2x2 square: rows 0-1, cols 10-11 → rows 0-1, cols (10+columnShift)-(11+columnShift)
              for (let row = 0; row < 2 && row < gridSize; row++) {
                for (let col = 10 + columnShift; col <= 11 + columnShift && col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices;
            } else if (sourceSquare === 256) {
              // 34×34 (1156) - 6 purple dots on 4th click (ones place)
              // Use specific dot numbers: 1, 2, 3, 67, 68, 102
              const purpleDotNumbers = new Set();
              purpleDotNumbers.add(1);
              purpleDotNumbers.add(2);
              purpleDotNumbers.add(3);
              purpleDotNumbers.add(67);
              purpleDotNumbers.add(68);
              purpleDotNumbers.add(102);
              
              // Convert dot numbers to indices by checking each circle's dot number
              const allIndices = [];
              circles.forEach((circle, idx) => {
                // For 1156, get dot number from data attribute or calculate from index
                let dotNumber;
                if (square === 1156) {
                  if (circle.dataset.dotNumber) {
                    dotNumber = parseInt(circle.dataset.dotNumber, 10);
                  } else {
                    // Calculate from index if data attribute not set
                    const row = Math.floor(idx / gridSize);
                    const col = idx % gridSize;
                    if (row === 0) {
                      dotNumber = gridSize - col;
                    } else {
                      dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                    }
                  }
                } else {
                  const numberSpan = circle.querySelector('.circle-number');
                  if (numberSpan) {
                    dotNumber = parseInt(numberSpan.textContent, 10);
                  }
                }
                if (dotNumber && purpleDotNumbers.has(dotNumber)) {
                  allIndices.push(idx);
                }
              });
              
              indicesToFill = allIndices;
            } else {
              indicesToFill = topRightIndices.filter(i => !alreadyFilled.has(i));
            }
          } else {
            indicesToFill = topRightIndices.filter(i => !alreadyFilled.has(i));
          }
        } else if (square === 1225 && clickCount === 1) {
          // 35×35 (1225) - Second click: 200 orange dots (the ones that remain black after 4th click)
          // Exclude: 1000 red dots (first click), 20 orange dots (third click), 5 blue dots (fourth click)
          // Third click dots: 2-5, 66-69, 101-104, 136-139, 171-174
          // Fourth click dots: column 34 (rightmost), rows 0-4 = dots 1, 70, 105, 140, 175
          const excludedDotNumbers = new Set();
          // Third click orange dots
          for (let dot = 2; dot <= 5; dot++) excludedDotNumbers.add(dot);
          for (let dot = 66; dot <= 69; dot++) excludedDotNumbers.add(dot);
          for (let dot = 101; dot <= 104; dot++) excludedDotNumbers.add(dot);
          for (let dot = 136; dot <= 139; dot++) excludedDotNumbers.add(dot);
          for (let dot = 171; dot <= 174; dot++) excludedDotNumbers.add(dot);
          // Fourth click blue dots
          excludedDotNumbers.add(1); // Row 0, col 34
          excludedDotNumbers.add(70); // Row 1, col 34
          excludedDotNumbers.add(105); // Row 2, col 34
          excludedDotNumbers.add(140); // Row 3, col 34
          excludedDotNumbers.add(175); // Row 4, col 34
          
          // Find all black dots (not filled yet) that are not in the excluded list
          const allIndices = [];
          circles.forEach((circle, idx) => {
            let dotNumber;
            if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              // Calculate from index if data attribute not set
              dotNumber = getDotNumberFromIndex1225(idx, gridSize);
            }
            if (!excludedDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
              allIndices.push(idx);
            }
          });
          indicesToFill = allIndices.slice(0, 200); // Exactly 200 orange dots
        } else if (square === 1225 && clickCount === 2) {
          // 35×35 (1225) - Third click: 20 orange dots at specific dot numbers
          // Dot numbers: 2-5, 66-69, 101-104, 136-139, 171-174
          const orangeDotNumbers = new Set();
          // 2 through 5
          for (let dot = 2; dot <= 5; dot++) orangeDotNumbers.add(dot);
          // 69 through 66 (backwards, so 66-69)
          for (let dot = 66; dot <= 69; dot++) orangeDotNumbers.add(dot);
          // 104 through 101 (backwards, so 101-104)
          for (let dot = 101; dot <= 104; dot++) orangeDotNumbers.add(dot);
          // 139 through 136 (backwards, so 136-139)
          for (let dot = 136; dot <= 139; dot++) orangeDotNumbers.add(dot);
          // 174 through 171 (backwards, so 171-174)
          for (let dot = 171; dot <= 174; dot++) orangeDotNumbers.add(dot);
          
          // Find circles by their dot numbers
          const allIndices = [];
          circles.forEach((circle, idx) => {
            let dotNumber;
            if (circle.dataset.dotNumber) {
              dotNumber = parseInt(circle.dataset.dotNumber, 10);
            } else {
              // Calculate from index if data attribute not set
              dotNumber = getDotNumberFromIndex1225(idx, gridSize);
            }
            if (orangeDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
              allIndices.push(idx);
            }
          });
          indicesToFill = allIndices;
        } else if (is1296SpecialClick) {
          // 1296 third/fourth clicks already handled above - skip other handlers
        } else if (isHundredsPlace) {
          // Hundreds place: start from bottom left, fill all the way to top
          if (square === 144) {
            // Special: 144 - fill 100 red, but leave space for 40 green (rows 2-5, left 10 cols) and 4 (top right 2x2)
            const allIndices = [];
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip top right 2x2 (for 4) and rows 2-5, left 10 cols (for 40 green)
                if (!topRightIndices.includes(idx) && 
                    !(row >= 2 && row < 6 && col < 10)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 169) {
            // Special: 169 - 100 red at bottom, leave space for 60 purple and 9 sky
            const allIndices = [];
            // Fill from bottom, leave top 3 rows for 60 purple and 9 sky
            // Fill bottom rows first
            for (let row = gridSize - 1; row >= 3 && allIndices.length < componentValue; row--) {
              for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill remaining from row 3, avoiding the top right 3x3 area
            for (let col = 0; col < gridSize - 3 && allIndices.length < componentValue; col++) {
              const idx = 3 * gridSize + col;
              if (!topRightIndices.includes(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 361) {
            // Special: 361 - 300 yellow, leave space for 60 purple + 1 red
            // Pattern exactly as specified:
            // Row 0: 1 yellow + 7 purple + 1 red
            // Row 1: 1 yellow + 8 purple
            // Rows 2-5: 8 purple each
            // Row 6: 7 purple
            // Row 7: 6 purple
            // Total: 60 purple + 1 red = 61 positions
            // Pattern: Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            const allIndices = [];
            // Fill from bottom, leaving the specified areas empty
            // Note: col 10 in rows 0-1 should be filled with yellow (not skipped)
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip row 0: cols 11-18 (7 purple + 1 red), but fill col 10 (yellow)
                if (row === 0 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip row 1: cols 11-18 (8 purple), but fill col 10 (yellow)
                if (row === 1 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip rows 2-5: cols 11-18 (8 purple each)
                if (row >= 2 && row <= 5 && col >= 11 && col <= 18) {
                  continue;
                }
                // Skip row 6: cols 12-18 (7 purple)
                if (row === 6 && col >= 12 && col <= 18) {
                  continue;
                }
                // Skip row 7: cols 13-18 (6 purple)
                if (row === 7 && col >= 13 && col <= 18) {
                  continue;
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 441) {
            // Special: 441 - 400 green, need to leave space for 41 (8×5 rectangle + 1 diagonal dot)
            // Row 0, col 12 (13th dot in top row) should be green on first click
            // Row 0, col 20 (top-right corner) should remain BLACK until third click (when it becomes red)
            // Row 5, col 12 (diagonal dot from bottom-left of rectangle) should remain black until second click
            const allIndices = [];
            // Fill from bottom, but skip:
            // - The entire 8×5 rectangle on the right (rows 0-4, cols 13-20)
            // - Row 4, col 12 (diagonal dot that will be part of the 41)
            // BUT: Include row 0, col 12 (13th dot in top row) - it should be green
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the entire 8×5 rectangle area (rows 0-4, cols 13-20)
                if (row >= 0 && row < 5 && col >= 13 && col < 21) {
                  continue;
                }
                // Skip row 5, col 12 (diagonal dot that will be part of the 41 on second click)
                if (row === 5 && col === 12) {
                  continue;
                }
                // Include row 0, col 12 (13th dot in top row) - it should be green
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 225) {
            // Special: 225 - 200 orange, leave exactly 25 black dots in a 5×5 rectangle (rows 0-4, cols 10-14)
            const allIndices = [];
            // Fill from bottom, leaving exactly the 5×5 rectangle (rows 0-4, cols 10-14) empty
            // Fill all rows from bottom up, skipping only the 5×5 area
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip the 5×5 rectangle area (rows 0-4, cols 10-14)
                if (row < 5 && col >= 10 && col <= 14) {
                  continue; // Skip this position - it's in the 5×5 area
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 289) {
            // Special: 289 - 200 orange, leave clean top-right area for 80 pink + 9 sky blue (89 total)
            // We need exactly 89 positions empty (289 - 200 = 89)
            // Leave: rows 0-8, cols 8-16 (9 rows × 9 cols = 81) + row 9, cols 9-16 (1 row × 8 cols = 8) = 89 positions
            // This ensures a clean top-right corner with no orange dots
            const allIndices = [];
            // Fill from bottom, leaving the top-right area empty
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip rows 0-8, cols 8-16 (9 rows × 9 cols = 81 positions)
                if (row >= 0 && row <= 8 && col >= 8 && col <= 16) {
                  continue;
                }
                // Skip row 9, cols 9-16 (1 row × 8 cols = 8 positions)
                if (row === 9 && col >= 9 && col <= 16) {
                  continue;
                }
                // Total skipped: 81 + 8 = 89 positions, leaving exactly 200 available for orange
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 324) {
            // Special: 324 - 300 yellow, leave space for 20 orange + 4 green
            // Pattern: 4 rows (rows 0-3) × 5 columns (cols 13-17) + 1 row (row 4) × 4 columns (cols 14-17)
            // The 4 green are in a 2x2 square at rows 0-1, cols 16-17
            // Top part: 4 rows × 5 cols = 20 positions, minus 4 green = 16 orange
            // Bottom row: 1 row × 4 cols (cols 14-17) = 4 orange (moved 2 positions to the right)
            // Total = 20 orange
            const allIndices = [];
            // Fill from bottom, leaving:
            // - rows 0-3, cols 13-17 (for 16 orange + 4 green in top part)
            // - row 4, cols 14-17 (for 4 orange in bottom row, moved 2 positions right)
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                // Skip rows 0-3, cols 13-17 (the top part for orange + green)
                if (row >= 0 && row <= 3 && col >= 13 && col <= 17) {
                  continue;
                }
                // Skip row 4, cols 14-17 (the bottom row for orange, moved 2 positions right)
                if (row === 4 && col >= 14 && col <= 17) {
                  continue;
                }
                const idx = row * gridSize + col;
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 484) {
            // Special: 484 - Simple pattern: everything green except the 9×9 square
            // The 9×9 rectangle: rows 0-8, cols 13-21 (top-right corner area)
            // Fill all dots except the 9×9 square = 484 - 81 = 403 green dots
            // PLUS: dots 482, 483, 484 should be green (these are in the 9×9 area but user wants them green)
            // MINUS: dots 189, 211, 212 should be black (user wants them excluded from green)
            const nineByNineIndices = [];
            for (let row = 0; row < 9; row++) {
              for (let col = 13; col < 22; col++) {
                nineByNineIndices.push(row * gridSize + col);
              }
            }
            // Dots to exclude (make black): 189, 211, 212
            // Dot number N is at index N-1
            // Dot 189: index 188, row 8, col 12
            // Dot 211: index 210, row 9, col 12
            // Dot 212: index 211, row 9, col 13
            const blackDots = [188, 210, 211]; // indices for dots 189, 211, 212
            
            // Dots 482, 483, 484 are already outside the 9×9 (row 21), so they're automatically included
            // Simple: fill everything except the 9×9 square, but exclude black dots
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the entire 9×9 square
                if (nineByNineIndices.includes(idx)) {
                  continue;
                }
                // Skip black dots (189, 211, 212)
                if (blackDots.includes(idx)) {
                  continue;
                }
                // Include all other dots (including 482, 483, 484 which are outside 9×9)
                allIndices.push(idx);
              }
            }
            // Should be 403 - 3 (black dots) = 400 green dots total
            // Dots 482-484 are already included (they're outside the 9×9)
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, 400);
          } else if (square === 529) {
            // Special: 529 - 500 blue, leave space for 20 orange (4×5 rectangle) and 9 (top right 3x3)
            // The 20 orange rectangle: rows 0-3, cols 15-19 (4 rows × 5 cols = 20)
            // The 9 sky blue: rows 0-2, cols 20-22 (3×3 in top-right)
            const orangeRectangleIndices = [];
            for (let row = 0; row < 4; row++) {
              for (let col = 15; col < 20; col++) {
                orangeRectangleIndices.push(row * gridSize + col);
              }
            }
            const allIndices = [];
            // Fill from bottom, leaving space for 20 orange rectangle and 3×3 square
            for (let row = gridSize - 1; row >= 0; row--) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip the 3×3 square (top-right)
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                // Skip the 20 orange rectangle (rows 0-3, cols 15-19)
                if (orangeRectangleIndices.includes(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 576) {
            // Special: 576 - 500 blue, with specific black dots
            // Row 1: dots 17-24 (indices 16-23) are black
            // Row 2: dots 41-48 (indices 40-47) are black
            // Row 3: dots 65-72 (indices 64-71) are black
            // Row 4: dots 89-96 (indices 88-95) are black
            // Row 5: dots 113-120 (indices 112-119) are black
            // Row 6: dots 137-144 (indices 136-143) are black
            // Row 7: dots 161-168 (indices 160-167) are black
            // Row 8: dots 184-192 (indices 183-191) are black
            // Dot 207 (index 206) is black
            const blackDots = new Set();
            // Row 1 (0-indexed row 0): dots 17-24
            for (let dot = 17; dot <= 24; dot++) {
              blackDots.add(dot - 1); // Convert to index
            }
            // Row 2 (0-indexed row 1): dots 41-48
            for (let dot = 41; dot <= 48; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 3 (0-indexed row 2): dots 64-72 (added 64)
            for (let dot = 64; dot <= 72; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 4 (0-indexed row 3): dots 88-96 (added 88)
            for (let dot = 88; dot <= 96; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 5 (0-indexed row 4): dots 112-120 (added 112)
            for (let dot = 112; dot <= 120; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 6 (0-indexed row 5): dots 136-144 (added 136)
            for (let dot = 136; dot <= 144; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 7 (0-indexed row 6): dots 160-168 (added 160)
            for (let dot = 160; dot <= 168; dot++) {
              blackDots.add(dot - 1);
            }
            // Row 8 (0-indexed row 7): dots 184-192 (added 184, 208 is blue not black)
            for (let dot = 184; dot <= 192; dot++) {
              // Skip dot 208 (index 207) - it's blue
              if (dot === 208) continue;
              blackDots.add(dot - 1);
            }
            // Dots 209, 210, 211, 212, 213, 214 are black
            blackDots.add(208); // Dot 209 (index 208)
            blackDots.add(209); // Dot 210 (index 209)
            blackDots.add(210); // Dot 211 (index 210)
            blackDots.add(211); // Dot 212 (index 211)
            blackDots.add(212); // Dot 213 (index 212)
            blackDots.add(213); // Dot 214 (index 213)
            
            // Also include the 6-dot pattern (ones place) as black dots
            // These will turn purple on the 3rd click
            topRightIndices.forEach(idx => {
              blackDots.add(idx);
            });
            
            // Dots 571-576 should be blue (not black)
            // Remove them from black list if they were added
            for (let dot = 571; dot <= 576; dot++) {
              blackDots.delete(dot - 1); // Convert to index and remove
            }
            
            // Count: 74 specified black + 6 ones pattern = 80 black dots total
            // But user says 76 black dots... let me verify the count:
            // Row 1: 17-24 = 8 dots
            // Row 2: 41-48 = 8 dots
            // Row 3: 65-72 = 8 dots
            // Row 4: 89-96 = 8 dots
            // Row 5: 113-120 = 8 dots
            // Row 6: 137-144 = 8 dots
            // Row 7: 161-168 = 8 dots
            // Row 8: 184-192 = 9 dots
            // Dot 207 = 1 dot
            // Total specified: 8+8+8+8+8+8+8+9+1 = 74
            // Plus 6-dot pattern = 80 black dots
            // User wants 76, so maybe I'm counting wrong or missing 2?
            // For now, using 80 black dots (74 specified + 6 ones pattern)
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (including the 6-dot pattern)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Should be 500 blue dots (576 - 80 black = 496... but user wants 500)
            // Maybe the count is actually 76 black? Let me use componentValue which should be 500
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 676) {
            // Special: 676 - 600 purple dots on first click, 76 black dots in top-right corner
            // Use same VISUAL pattern as 24×24 (576) - same shape/arrangement in top-right corner
            // Pattern: rows 0-1 have rightmost 8 cols, rows 2-7 have rightmost 9 cols (row 7 excludes one), row 8 has 6 specific dots
            const blackDots = new Set();
            // Row 0: rightmost 8 columns (cols 18-25)
            for (let col = 18; col < 26; col++) {
              blackDots.add(0 * gridSize + col);
            }
            // Row 1: rightmost 8 columns (cols 18-25)
            for (let col = 18; col < 26; col++) {
              blackDots.add(1 * gridSize + col);
            }
            // Row 2: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(2 * gridSize + col);
            }
            // Row 3: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(3 * gridSize + col);
            }
            // Row 4: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(4 * gridSize + col);
            }
            // Row 5: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(5 * gridSize + col);
            }
            // Row 6: rightmost 9 columns (cols 17-25)
            for (let col = 17; col < 26; col++) {
              blackDots.add(6 * gridSize + col);
            }
            // Row 7: rightmost 9 columns (cols 17-25), but exclude one to match 24×24 pattern
            for (let col = 17; col < 26; col++) {
              if (col === 17) continue; // Exclude one to match pattern
              blackDots.add(7 * gridSize + col);
            }
            // Row 8: cols 19-24 (6 dots) - same relative position as 24×24's row 8, cols 17-22
            for (let col = 19; col < 25; col++) {
              blackDots.add(8 * gridSize + col);
            }
            
            // Also include the 6-dot pattern (ones place) as black dots
            // These will turn purple on the 3rd click
            topRightIndices.forEach(idx => {
              blackDots.add(idx);
            });
            
            // Dots 200 and 227 should be black on first click (not purple)
            // Dot 200: index 199
            // Dot 227: index 226
            blackDots.add(199); // Dot 200
            blackDots.add(226); // Dot 227
            
            // Dots 233 and 676 should be purple on first click (not black)
            // Dot 233: index 232
            // Dot 676: index 675
            // Remove them from blackDots if they were added
            blackDots.delete(232); // Dot 233
            blackDots.delete(675); // Dot 676
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (including the 6-dot pattern, dots 200 and 227)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
            }
            }
            // Fill 600 purple dots (including dots 233 and 676)
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 729) {
            // Special: 729 - 700 purple dots on first click, 29 black dots in top-right corner
            // Pattern matches 23×23 (529) visually: 4×5 rectangle + 3×3 square
            // For 27×27: rectangle is rows 0-3, cols 19-23 (4 rows × 5 cols = 20)
            // Square is rows 0-2, cols 24-26 (3×3 in top-right, same as get3x3TopRightIndices)
            const blackDots = new Set();
            // 4×5 rectangle: rows 0-3, cols 19-23
            for (let row = 0; row < 4; row++) {
              for (let col = 19; col < 24; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            // 3×3 square: rows 0-2, cols 24-26 (top-right corner)
            // This matches get3x3TopRightIndices for gridSize 27
            for (let row = 0; row < 3; row++) {
              for (let col = 24; col < 27; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (the 29 dots: 20 in rectangle + 9 in square)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 700 purple dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 784) {
            // Special: 784 - 700 brown dots on first click, 84 black dots in top-right corner
            // Pattern matches 22×22 (484) visually, mapped exactly:
            // 22×22: 9×9 square at rows 0-8, cols 13-21, plus dots 189, 211, 212
            // 28×28: 9×9 square at rows 0-8, cols 19-27 (shifted right by 6), plus equivalent dots
            const blackDots = new Set();
            // 9×9 square: rows 0-8, cols 19-27 (matching visual position from 22×22's cols 13-21)
            // In 22×22: cols 13-21 (9 columns, starting 9 columns from right edge: 22-9=13)
            // In 28×28: cols 19-27 (9 columns, starting 9 columns from right edge: 28-9=19)
            for (let row = 0; row < 9; row++) {
              for (let col = 19; col < 28; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            // Additional black dots (matching 22×22 pattern):
            // 22×22: dot 189 (row 8, col 12), dot 211 (row 9, col 12), dot 212 (row 9, col 13)
            // 28×28: equivalent positions shifted right by 6 columns:
            //   row 8, col 18 (was col 12 in 22×22)
            //   row 9, col 18 (was col 12 in 22×22)
            //   row 9, col 19 (was col 13 in 22×22)
            blackDots.add(8 * gridSize + 18);  // row 8, col 18
            blackDots.add(9 * gridSize + 18);  // row 9, col 18
            blackDots.add(9 * gridSize + 19);  // row 9, col 19
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (the 84 dots: 81 in 9×9 + 3 additional = 84)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 700 brown dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square === 841) {
            // Special: 841 - 800 pink dots on first click, 41 black dots in top-right corner
            // Pattern matches 21×21 (441) visually, mapped exactly:
            // 21×21: 8×5 rectangle at rows 0-4, cols 13-20, diagonal at row 5, col 12, top-right at row 0, col 20
            // 29×29: 8×5 rectangle at rows 0-4, cols 21-28 (shifted right by 8), diagonal at row 5, col 20, top-right at row 0, col 28
            const blackDots = new Set();
            // 8×5 rectangle: rows 0-4, cols 21-28 (matching visual position from 21×21's cols 13-20)
            // In 21×21: cols 13-20 (8 columns, starting 8 columns from right edge: 21-8=13)
            // In 29×29: cols 21-28 (8 columns, starting 8 columns from right edge: 29-8=21)
            for (let row = 0; row < 5; row++) {
              for (let col = 21; col < 29; col++) {
                blackDots.add(row * gridSize + col);
              }
            }
            // Diagonal dot: row 5, col 20 (was row 5, col 12 in 21×21, shifted right by 8)
            blackDots.add(5 * gridSize + 20);
            
            // Fill all dots except the black ones
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots (the 41 dots: 40 in 8×5 rectangle + 1 diagonal = 41)
                if (blackDots.has(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 800 brown dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else if (square >= 961 && square <= 2500 && n > 30) {
            // For squares 31×31 (961) through 50×50 (2500), map pattern from corresponding smaller square
            // Find the source square with the same last 2 digits
            // Example: 31×31 (961), last 2 digits = 61, so map from 19×19 (361)
            const lastTwoDigits = square % 100;
            let sourceN = 0;
            let sourceSquare = 0;
            // Find the smaller square with the same last 2 digits
            for (let i = 1; i < n; i++) {
              const testSquare = i * i;
              if (testSquare % 100 === lastTwoDigits) {
                sourceN = i;
                sourceSquare = testSquare;
                break;
              }
            }
            const sourceGridSize = sourceN;
            
            // Map the pattern from the source square
            if (sourceSquare === 361) {
              // 31×31 (961) maps to 19×19 (361) - pattern for 61 (60 purple + 1 red)
              // Map relative to top-right corner: row 0, col 18 in 19×19 → row 0, col 30 in 31×31
              // Map each dot by its distance from the right edge
              // First click: 900 dots (leaving 61 black dots matching 361 pattern in top-right corner)
              const blackDots = new Set();
              const sourceGridSize = 19;
              const targetGridSize = gridSize;
              // Map each dot from 19×19 to 31×31 by relative position from top-right corner
              // 19×19 pattern positions (relative to top-right at row 0, col 18):
              // Row 0: cols 11-18 (8 dots: 7 purple + 1 red at col 18)
              // Row 1: cols 11-18 (8 purple)
              // Rows 2-5: cols 11-18 (8 purple each)
              // Row 6: cols 12-18 (7 purple)
              // Row 7: cols 13-18 (6 purple)
              for (let sourceRow = 0; sourceRow < 8; sourceRow++) {
                let sourceStartCol, sourceEndCol;
                if (sourceRow === 0) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow === 1) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow >= 2 && sourceRow <= 5) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow === 6) {
                  sourceStartCol = 12;
                  sourceEndCol = 18;
                } else if (sourceRow === 7) {
                  sourceStartCol = 13;
                  sourceEndCol = 18;
                }
                // Map each column by distance from right edge
                for (let sourceCol = sourceStartCol; sourceCol <= sourceEndCol; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    blackDots.add(targetRow * gridSize + targetCol);
                  }
                }
              }
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - pattern for 24 (20 orange + 4 green)
              // Map relative to top-right corner: row 0, col 17 in 18×18 → row 0, col 31 in 32×32
              // Map each dot by its distance from the right edge
              // First click: 1000 dots (leaving 24 black dots matching 324 pattern in top-right corner)
              const blackDots = new Set();
              const sourceGridSize = 18;
              const targetGridSize = gridSize; // Should be 32
              // Map each dot from 18×18 to 32×32 by relative position from top-right corner
              // Pattern in 18×18: rows 0-3, cols 13-17 + row 4, cols 14-17
              // The 4 green are in a 2x2 square at rows 0-1, cols 16-17
              for (let sourceRow = 0; sourceRow < 4; sourceRow++) {
                for (let sourceCol = 13; sourceCol <= 17; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    blackDots.add(targetRow * gridSize + targetCol);
                  }
                }
              }
              // Bottom row: row 4, cols 14-17
              for (let sourceCol = 14; sourceCol <= 17; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 4; // Row 4
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  blackDots.add(targetRow * gridSize + targetCol);
                }
              }
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 289) {
              // 33×33 (1089) maps to 17×17 (289) - pattern for 89 (80 pink + 9 sky blue)
              // Map relative to top-right corner: row 0, col 16 in 17×17 → row 0, col 32 in 33×33
              // Map each dot by its distance from the right edge
              // First click: 1000 dots (leaving 89 black dots matching 289 pattern in top-right corner)
              const blackDots = new Set();
              const sourceGridSize = 17;
              const targetGridSize = gridSize; // Should be 33
              // Map each dot from 17×17 to 33×33 by relative position from top-right corner
              // Pattern in 17×17: rows 0-8, cols 8-16 + row 9, cols 9-16
              // Rows 0-8: cols 8-16 (9 rows × 9 cols = 81)
              for (let sourceRow = 0; sourceRow < 9; sourceRow++) {
                for (let sourceCol = 8; sourceCol <= 16; sourceCol++) {
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    blackDots.add(targetRow * gridSize + targetCol);
                  }
                }
              }
              // Row 9: cols 9-16 (1 row × 8 cols = 8)
              for (let sourceCol = 9; sourceCol <= 16; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 9; // Row 9
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  blackDots.add(targetRow * gridSize + targetCol);
                }
              }
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 256) {
              // 34×34 (1156) - First click: exactly 1000 red dots, specific black dots stay black
              // Row 0: All red EXCEPT dots 1-18 (so dots 19-34 are red)
              // Row 1: All red EXCEPT dots 68-51 (so dots 35-50 are red, dots 51-68 are black)
              // Row 2: All red EXCEPT dots 102-85 (so dots 69-84 are red, dots 85-102 are black)
              // Row 3: All red EXCEPT dots 130-119 and 131-136 (so dots 103-118 are red, dots 119-136 are black)
              // Row 4: All red EXCEPT dots 170-153 (so dots 137-152 are red, dots 153-170 are black)
              // Row 5: All red EXCEPT dots 204-187 (so dots 171-186 are red, dots 187-204 are black)
              // Row 6: All red EXCEPT dots 238-221 (so dots 205-220 are red, dots 221-238 are black)
              // Row 7: All red EXCEPT dots 265-255 (so dots 239-254 are red, dots 255-265 are black)
              // Row 8: All red EXCEPT dots 299-289 (so dots 266-288 are red, dots 289-299 are black)
              // Row 9: All red EXCEPT dots 333-323 (so dots 300-322 are red, dots 323-333 are black)
              // Rows 10-33: All red EXCEPT dots 1154-1156 should be red (not black)
              
              // Build set of black dot numbers
              const blackDotNumbers = new Set();
              
              // Row 0: dots 1-18 are black
              for (let dot = 1; dot <= 18; dot++) blackDotNumbers.add(dot);
              
              // Row 1: dots 68-51 are black (going backwards from 68 to 51)
              for (let dot = 51; dot <= 68; dot++) blackDotNumbers.add(dot);
              
              // Row 2: dots 102-85 are black
              for (let dot = 85; dot <= 102; dot++) blackDotNumbers.add(dot);
              
              // Row 3: dots 130-119 and 131-136 are black
              for (let dot = 119; dot <= 136; dot++) blackDotNumbers.add(dot);
              
              // Row 4: dots 170-153 are black
              for (let dot = 153; dot <= 170; dot++) blackDotNumbers.add(dot);
              
              // Row 5: dots 204-187 are black
              for (let dot = 187; dot <= 204; dot++) blackDotNumbers.add(dot);
              
              // Row 6: dots 238-221 are black
              for (let dot = 221; dot <= 238; dot++) blackDotNumbers.add(dot);
              
              // Row 7: dots 265-255 are black (except dot 265 which should be red)
              for (let dot = 255; dot <= 264; dot++) blackDotNumbers.add(dot);
              
              // Row 8: dots 299-289 are black (except dot 299 which should be red)
              for (let dot = 289; dot <= 298; dot++) blackDotNumbers.add(dot);
              
              // Row 9: dots 333-323 are black (except dot 333 which should be red)
              for (let dot = 323; dot <= 332; dot++) blackDotNumbers.add(dot);
              
              // Remove specific dots that should be red: 265, 299, 333, 1154-1156
              blackDotNumbers.delete(265);
              blackDotNumbers.delete(299);
              blackDotNumbers.delete(333);
              blackDotNumbers.delete(1154);
              blackDotNumbers.delete(1155);
              blackDotNumbers.delete(1156);
              
              // Convert dot numbers to indices by checking each circle's dot number
              const blackDots = new Set();
              circles.forEach((circle, idx) => {
                // For 1156, get dot number from data attribute or calculate from index
                let dotNumber;
                if (square === 1156) {
                  if (circle.dataset.dotNumber) {
                    dotNumber = parseInt(circle.dataset.dotNumber, 10);
                  } else {
                    // Calculate from index if data attribute not set
                    const row = Math.floor(idx / gridSize);
                    const col = idx % gridSize;
                    if (row === 0) {
                      dotNumber = gridSize - col;
                    } else {
                      dotNumber = gridSize + (row - 1) * gridSize + col + 1;
                    }
                  }
                } else {
                  const numberSpan = circle.querySelector('.circle-number');
                  if (numberSpan) {
                    dotNumber = parseInt(numberSpan.textContent, 10);
                  }
                }
                if (dotNumber && blackDotNumbers.has(dotNumber)) {
                  blackDots.add(idx);
                }
              });
              
              // Fill all dots except the black ones
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  // Skip black dots
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              
              // Fill exactly 1000 red dots
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, 1000);
            } else if (sourceSquare === 225 || square === 1225) {
              // 35×35 (1225) - First click: 1000 red dots filled from bottom, leaving top black
              // Leave columns 29-34 (columns 6-1 from right), rows 0-4 black for orange and blue on clicks 3-4
              if (square === 1225 && clickCount === 0) {
                const blackDots = new Set();
                // Columns 29-34 (columns 6-1 from right), rows 0-4 = 30 dots to leave black for later clicks
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  for (let col = gridSize - 6; col < gridSize && col >= 0; col++) {
                    blackDots.add(row * gridSize + col);
                  }
                }
                
                // Fill from bottom rows upward, leaving top rows black
                const allIndices = [];
                // Start from bottom row and work upward
                for (let row = gridSize - 1; row >= 0; row--) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    // Skip the black dots reserved for orange and blue
                    if (!blackDots.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, 1000); // Exactly 1000 red dots from bottom
              } else if (square === 1225) {
                // For other clicks, use default behavior
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    allIndices.push(idx);
                  }
                }
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, componentValue);
              } else {
                // Original 225 mapping logic for other squares
                const blackDots = new Set();
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  for (let col = gridSize - 5; col < gridSize && col >= 0; col++) {
                    blackDots.add(row * gridSize + col);
                  }
                }
                
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!blackDots.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i))
                  .slice(0, componentValue);
              }
            } else if (sourceSquare === 196) {
              // 36×36 (1296): 1000 red (first click), nothing (second click), 90 sky blue (third click), 6 purple (fourth click)
              // Skip this handler if we already handled 1296 third/fourth clicks above
              if (square === 1296 && !is1296SpecialClick) {
                if (clickCount === 2) {
                  // Third click: Fill specific dot numbers with sky blue
                  // Dot numbers: 4-10, 39-46, 74-82, 109-118, 145-154, 181-190, 217-226, 253-262, 289-297, 325-333, 360-367
                  const skyBlueDotNumbers = new Set();
                  // 4 through 10
                  for (let dot = 4; dot <= 10; dot++) skyBlueDotNumbers.add(dot);
                  // 39 through 46
                  for (let dot = 39; dot <= 46; dot++) skyBlueDotNumbers.add(dot);
                  // 74 through 82
                  for (let dot = 74; dot <= 82; dot++) skyBlueDotNumbers.add(dot);
                  // 109 through 118 (assuming "1 through 118" was a typo)
                  for (let dot = 109; dot <= 118; dot++) skyBlueDotNumbers.add(dot);
                  // 145 through 154
                  for (let dot = 145; dot <= 154; dot++) skyBlueDotNumbers.add(dot);
                  // 181 through 190
                  for (let dot = 181; dot <= 190; dot++) skyBlueDotNumbers.add(dot);
                  // 217 through 226
                  for (let dot = 217; dot <= 226; dot++) skyBlueDotNumbers.add(dot);
                  // 253 through 262
                  for (let dot = 253; dot <= 262; dot++) skyBlueDotNumbers.add(dot);
                  // 289 through 297
                  for (let dot = 289; dot <= 297; dot++) skyBlueDotNumbers.add(dot);
                  // 325 through 333
                  for (let dot = 325; dot <= 333; dot++) skyBlueDotNumbers.add(dot);
                  // 360 through 367
                  for (let dot = 360; dot <= 367; dot++) skyBlueDotNumbers.add(dot);
                  
                  // Find circles by their dot numbers
                  const allIndices = [];
                  circles.forEach((circle, idx) => {
                    const numberSpan = circle.querySelector('.circle-number');
                    if (numberSpan) {
                      const dotNumber = parseInt(numberSpan.textContent, 10);
                      if (dotNumber && skyBlueDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
                        allIndices.push(idx);
                      }
                    } else if (circle.dataset.dotNumber) {
                      // Fallback to data attribute if number span doesn't exist
                      const dotNumber = parseInt(circle.dataset.dotNumber, 10);
                      if (dotNumber && skyBlueDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
                        allIndices.push(idx);
                      }
                    }
                  });
                  indicesToFill = allIndices;
                } else if (clickCount === 3) {
                  // Fourth click: Fill 6 purple dots (the top-right corner pattern)
                  indicesToFill = topRightIndices.filter(i => !alreadyFilled.has(i));
                } else if (clickCount === 0) {
                  // First click: Fill specific dot numbers with red
                  // Dot numbers: 281-288, 297-324, 333-360, 361-1296
                  const redDotNumbers = new Set();
                  // 281 to 288
                  for (let dot = 281; dot <= 288; dot++) redDotNumbers.add(dot);
                  // 297 to 324
                  for (let dot = 297; dot <= 324; dot++) redDotNumbers.add(dot);
                  // 333 to 360
                  for (let dot = 333; dot <= 360; dot++) redDotNumbers.add(dot);
                  // 361 to 1296
                  for (let dot = 361; dot <= 1296; dot++) redDotNumbers.add(dot);
                  
                  // Find circles by their dot numbers
                  const allIndices = [];
                  circles.forEach((circle, idx) => {
                    // Get dot number from data attribute or calculate
                    let dotNumber;
                    if (circle.dataset.dotNumber) {
                      dotNumber = parseInt(circle.dataset.dotNumber, 10);
                    } else {
                      const row = Math.floor(idx / gridSize);
                      const col = idx % gridSize;
                      dotNumber = row * gridSize + (gridSize - col);
                    }
                    
                    if (dotNumber && redDotNumbers.has(dotNumber) && !topRightIndices.includes(idx)) {
                      allIndices.push(idx);
                    }
                  });
                  
                  indicesToFill = allIndices
                    .filter(i => !alreadyFilled.has(i))
                    .slice(0, componentValue);
                } else {
                  // Other clicks: handled by default pattern
                  const allIndices = getBottomLeftIndices(gridSize, componentValue + onesValue);
                  indicesToFill = allIndices
                    .filter(i => !alreadyFilled.has(i) && !topRightIndices.includes(i))
                    .slice(0, componentValue);
                }
              } else {
                // Other squares mapping to 196: use default pattern
                const allIndices = getBottomLeftIndices(gridSize, componentValue + onesValue);
                indicesToFill = allIndices
                  .filter(i => !alreadyFilled.has(i) && !topRightIndices.includes(i))
                  .slice(0, componentValue);
              }
            } else if (sourceSquare === 169) {
              // 37×37 (1369) maps to 13×13 (169) - pattern for 69 (60 purple + 9 sky blue)
              // First click: 1300 dots (leaving 69 black dots matching 169 pattern)
              const blackDots = new Set();
              // Map the 169 pattern: top 3 rows for 60 purple + 9 sky blue
              // The 9 sky blue is in a 3x3 square at rows 0-2, cols 10-12
              // The 60 purple fills the rest of the top area
              // For simplicity, leave top 3 rows, rightmost area
              for (let row = 0; row < 3; row++) {
                for (let col = 10 + columnShift; col < sourceGridSize + columnShift && col < gridSize; col++) {
                  blackDots.add(row * gridSize + col);
                }
              }
              
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 144) {
              // 38×38 (1444) maps to 12×12 (144) - pattern for 44 (40 green + 4 green)
              // Actually, 144 breaks down as 100 + 40 + 4, so we're mapping 40 + 4
              // First click: 1400 dots (leaving 44 black dots matching 144 pattern)
              const blackDots = new Set();
              // Map the 144 pattern: rows 2-5, cols 0-9 (40 green) + 2x2 square (4 green)
              // The 2x2 square is at rows 0-1, cols 10-11
              // The 40 green is in rows 2-5, left 10 cols
              // For the mapped pattern, shift appropriately
              // 2x2 square: rows 0-1, cols 10-11 → rows 0-1, cols (10+columnShift)-(11+columnShift)
              for (let row = 0; row < 2; row++) {
                for (let col = 10 + columnShift; col <= 11 + columnShift && col < gridSize; col++) {
                  blackDots.add(row * gridSize + col);
                }
              }
              // 40 green: rows 2-5, cols 0-9 → rows 2-5, cols (0+columnShift)-(9+columnShift)
              for (let row = 2; row < 6; row++) {
                for (let col = 0 + columnShift; col <= 9 + columnShift && col < gridSize; col++) {
                  blackDots.add(row * gridSize + col);
                }
              }
              
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!blackDots.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 121) {
              // 39×39 (1521) maps to 11×11 (121) - pattern for 21 (20 orange + 1 red)
              // First click: 1500 dots (leaving 21 black dots matching 121 pattern)
              // Need to check 121 pattern - likely similar to other patterns
              const allIndices = getBottomLeftIndices(gridSize, componentValue + onesValue);
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i) && !topRightIndices.includes(i))
                .slice(0, componentValue);
            } else if (sourceSquare === 100) {
              // 40×40 (1600) maps to 10×10 (100) - pattern for 00 (all filled on first click)
              // Actually, 100 is just one click, so 1600 should also be one click
              // But we're breaking it down, so handle accordingly
              const allIndices = [];
              for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  allIndices.push(idx);
                }
              }
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i))
                .slice(0, componentValue);
            } else {
              // Default: fill from bottom left
              const allIndices = getBottomLeftIndices(gridSize, componentValue + onesValue);
              indicesToFill = allIndices
                .filter(i => !alreadyFilled.has(i) && !topRightIndices.includes(i))
                .slice(0, componentValue);
            }
          } else if (square === 625) {
            // Special: 625 - 600 purple dots on first click
            // Black dots: 21-25, 46-50, 71-75, 96-100, 121-125 (25 dots total)
            // The rest (600 dots) should be purple
            const blackDots = new Set();
            // Add black dots: 21-25, 46-50, 71-75, 96-100, 121-125
            for (let dot of [21, 22, 23, 24, 25, 46, 47, 48, 49, 50, 71, 72, 73, 74, 75, 96, 97, 98, 99, 100, 121, 122, 123, 124, 125]) {
              blackDots.add(dot - 1); // Convert to index
            }
            
            const allIndices = [];
            // Fill all dots except the black ones
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip black dots
                if (blackDots.has(idx)) {
                  continue;
                }
                // Skip top right 5-dot pattern (dots 21-25 are already excluded above)
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                allIndices.push(idx);
              }
            }
            // Fill 600 purple dots
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i))
              .slice(0, componentValue);
          } else {
            // Default: start from bottom left
            const allIndices = getBottomLeftIndices(gridSize, componentValue + onesValue);
            indicesToFill = allIndices
              .filter(i => !alreadyFilled.has(i) && !topRightIndices.includes(i))
              .slice(0, componentValue);
          }
        } else if (isTensPlace && components.length === 3) {
          // Tens place in 3-digit number
          if (square === 144) {
            // Special: 144 - 40 green as 4 rows of 10, in rows 2-5
            // Place in rows 2-5, left 10 columns
            const allIndices = [];
            // Fill 4 rows of 10, starting at row 2
            for (let row = 2; row < 6 && row < gridSize; row++) {
              for (let col = 0; col < 10 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 169) {
            // Special: 169 - 60 purple to the left of the 9, fill all 60
            const allIndices = [];
            // Fill area to the left of top right 3x3, and below
            // Start from top rows, left side
            for (let row = 0; row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 225) {
            // Special: 225 - 20 orange in a 5×5 rectangle (5 columns × 5 rows)
            // Fill only the first 4 columns (cols 10-13) × 5 rows (rows 0-4) = 20 orange dots
            // Leave the rightmost column (col 14) black for now (will turn blue on 3rd click)
            // Position: rows 0-4, cols 10-13 (4 columns × 5 rows = 20 dots)
            // These stay attached in the grid, NOT separated like the 6 purple dots
            const allIndices = [];
            // Create 5 rows of 4 dots each (4 columns × 5 rows = 20 dots)
            // Only fill cols 10-13, leaving col 14 black (will be blue on 3rd click)
            for (let row = 0; row < 5 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 10; col < 14 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Don't include topRightIndices (the 5 blue dots in col 14) or already filled
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 289) {
            // Special: 289 - 80 pink, fill the top-right area we left empty, excluding the 9 sky blue (3×3)
            // The area we left empty: rows 0-8, cols 8-16 (81 positions) + row 9, cols 9-16 (8 positions) = 89 positions
            // The 9 sky blue dots are in rows 0-2, cols 14-16 (3×3 in top-right)
            // Fill 89 - 9 = 80 pink dots in the top-right area
            const allIndices = [];
            // Fill rows 0-8, cols 8-16 (excluding the 9 cyan in rows 0-2, cols 14-16)
            for (let row = 0; row < 9 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 8; col < 17 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Exclude the 9 sky blue dots (rows 0-2, cols 14-16) and already filled dots
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill row 9, cols 9-16 (excluding any overlaps)
            for (let col = 9; col < 17 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 9 * gridSize + col;
              // Exclude already filled dots
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 324) {
            // Special: 324 - 20 orange in pattern: 4 rows × 5 cols (top) + 1 row × 4 cols (bottom)
            // The 4 green are in a 2x2 square at rows 0-1, cols 16-17 (top-right corner)
            // Top part: 4 rows (rows 0-3) × 5 columns (cols 13-17) = 20 positions, minus 4 green = 16 orange
            // Bottom row: 1 row (row 4) × 4 columns (cols 14-17) = 4 orange (moved 2 positions to the right)
            // Total = 20 orange
            const allIndices = [];
            // Fill top part: rows 0-3, cols 13-17 (excluding the 2x2 green)
            for (let row = 0; row < 4 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 13; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                // Exclude the 4 green dots (2x2 at rows 0-1, cols 16-17) and already filled dots
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Fill bottom row: row 4, cols 14-17 (moved 2 positions to the right)
            for (let col = 14; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 4 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 361) {
            // Special: 361 - 60 purple exactly as specified:
            // Row 0: 1 yellow (col 11) + 7 purple (cols 12-18, but red is at col 18, so cols 12-17 = 6 purple, col 18 = red)
            // Actually: Row 0 has 7 purple + 1 red, so if red is at col 18, then cols 12-17 = 6 purple... 
            // Let me interpret: Row 0 has 7 purple dots in the purple section, plus 1 red = 8 total in that section
            // Row 1: 1 yellow (col 11) + 8 purple (cols 12-18, but only 7 columns, so maybe cols 11-18 with yellow at 11?)
            // Actually, re-reading: "the first as yellow and then it has 7 purple dot and one red dot"
            // So row 0: yellow + 7 purple + 1 red
            // If red is at col 18, and we have 7 purple before it: cols 11-17 = 1 yellow + 7 purple, col 18 = red
            // Row 1: yellow + 8 purple = cols 11 (yellow) + cols 12-18 (7 purple, but they said 8...)
            // Maybe: Row 1: col 11 (yellow) + cols 12-19 (8 purple) but col 19 doesn't exist in 19×19
            // Let me assume: Row 0: col 11 (yellow) + cols 12-18 (7 purple + 1 red at 18)
            // Row 1: col 11 (yellow) + cols 12-18 (8 purple, but only 7 columns available)
            // I think the pattern might be: Row 0: col 11 (yellow) + cols 12-18 (7 purple + 1 red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            // Let me implement based on the description more literally
            const allIndices = [];
            // Row 0: 1 yellow (col 11) + 7 purple (cols 12-17) + 1 red (col 18) - red excluded here
            // Row 1: 1 yellow (col 11) + 8 purple (cols 12-18, but only 7 available, so cols 12-18)
            // Actually, let me count: if row 1 has 8 purple and we start at col 12, we need cols 12-19, but only have 12-18
            // So maybe: Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Row 0: col 11 (yellow) + cols 12-17 (6 purple) + col 18 (red) = but that's 6 purple, not 7
            // Let me try: Row 0: col 11 (yellow) + cols 12-18 (7 positions: 6 purple + 1 red)
            // But they said 7 purple, so maybe: Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red)
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            // Rows 2-5: cols 11-18 (8 purple each)
            // Row 6: cols 12-18 (7 purple)
            // Row 7: cols 13-18 (6 purple)
            // Let me implement this pattern
            // Row 0: col 10 (yellow) + cols 11-17 (7 purple) + col 18 (red, excluded)
            for (let col = 11; col < 18 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 0 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Row 1: col 10 (yellow) + cols 11-18 (8 purple)
            for (let col = 11; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 1 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Rows 2-5: cols 11-18 (8 purple each)
            for (let row = 2; row < 6 && row < gridSize && allIndices.length < componentValue; row++) {
              for (let col = 11; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Row 6: cols 12-18 (7 purple)
            for (let col = 12; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 6 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            // Row 7: cols 13-18 (6 purple)
            for (let col = 13; col < 19 && col < gridSize && allIndices.length < componentValue; col++) {
              const idx = 7 * gridSize + col;
              if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                allIndices.push(idx);
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square >= 961 && square <= 2500 && n > 30 && isTensPlace) {
            // For squares 31×31 (961) through 50×50 (2500), map tens place pattern from source square
            // Find the source square with the same last 2 digits
            // For 31×31 (961), last 2 digits = 61, so map from 19×19 (361)
            const lastTwoDigits = square % 100;
            let sourceN = 0;
            let sourceSquare = 0;
            // Find the smaller square with the same last 2 digits
            for (let i = 1; i < n; i++) {
              const testSquare = i * i;
              if (testSquare % 100 === lastTwoDigits) {
                sourceN = i;
                sourceSquare = testSquare;
                break;
              }
            }
            const sourceGridSize = sourceN;
            
            // Check for 1156 FIRST before other sourceSquare checks
            // For 1156, clicks 2-4 do nothing visually (only first click fills dots)
            if (false && square === 1156 && isTensPlace) {
              // 34×34 (1156) - red dots on second click (DISABLED - no visual changes on clicks 2-4)
              // EXACT dots that should turn red and move up 1 dot distance:
              // Row 1: 207-214, 10, 9
              // Row 2: 221-228, 20, 19
              // Row 3: 235-242, 30, 29
              // Row 4: 249-256, 40, 39
              // Row 5: 263-270, 50, 49
              // Row 6: 277-284, 60, 59
              // Row 7: 291-298, 70, 69
              // Row 8: 305-312 (NOT 80, 79 - these should stay black)
              // Row 9: 319-326 (NOT 90, 89 - these should stay black)
              // Row 10: 333-340 (NOT 100, 99 - these should stay black)
              // Also: dots 1151-1156 should turn red
              // Dots that MUST stay BLACK: 4-8, 13-18, 22-28, 31-38, 41-48, 53-58, 80, 79, 90, 89, 100, 99
              
              // Build EXACT set of dots that should be red - ONLY THESE DOTS
              const redDotNumbers = new Set();
              
              // Add ranges (80 dots total) - ALL 10 rows
              for (let dot = 207; dot <= 214; dot++) redDotNumbers.add(dot); // Row 1
              for (let dot = 221; dot <= 228; dot++) redDotNumbers.add(dot); // Row 2
              for (let dot = 235; dot <= 242; dot++) redDotNumbers.add(dot); // Row 3
              for (let dot = 249; dot <= 256; dot++) redDotNumbers.add(dot); // Row 4
              for (let dot = 263; dot <= 270; dot++) redDotNumbers.add(dot); // Row 5
              for (let dot = 277; dot <= 284; dot++) redDotNumbers.add(dot); // Row 6
              for (let dot = 291; dot <= 298; dot++) redDotNumbers.add(dot); // Row 7
              for (let dot = 305; dot <= 312; dot++) redDotNumbers.add(dot); // Row 8
              for (let dot = 319; dot <= 326; dot++) redDotNumbers.add(dot); // Row 9
              for (let dot = 333; dot <= 340; dot++) redDotNumbers.add(dot); // Row 10
              
              // Add individual dots (14 dots total) - ONLY rows 1-7, NOT rows 8-10
              const individualDots = [9,10,20,19,30,29,40,39,50,49,60,59,70,69];
              individualDots.forEach(dot => redDotNumbers.add(dot));
              
              // Add dots 1151-1156
              for (let dot = 1151; dot <= 1156; dot++) redDotNumbers.add(dot);
              
              // Build set of dots that MUST stay BLACK - remove these from red set
              const blackDotNumbers = new Set();
              for (let dot = 4; dot <= 8; dot++) blackDotNumbers.add(dot);
              for (let dot = 13; dot <= 18; dot++) blackDotNumbers.add(dot);
              for (let dot = 22; dot <= 28; dot++) blackDotNumbers.add(dot);
              for (let dot = 31; dot <= 38; dot++) blackDotNumbers.add(dot);
              for (let dot = 41; dot <= 48; dot++) blackDotNumbers.add(dot);
              for (let dot = 53; dot <= 58; dot++) blackDotNumbers.add(dot);
              // Dots 80, 79, 90, 89, 100, 99 MUST stay black
              blackDotNumbers.add(80);
              blackDotNumbers.add(79);
              blackDotNumbers.add(90);
              blackDotNumbers.add(89);
              blackDotNumbers.add(100);
              blackDotNumbers.add(99);
              
              // CRITICAL: Remove black dots from red set - they should NEVER be red
              blackDotNumbers.forEach(dot => redDotNumbers.delete(dot));
              
              // Find circles by matching their displayed number EXACTLY
              const redDots = [];
              for (let idx = 0; idx < circles.length; idx++) {
                const circle = circles[idx];
                const numberSpan = circle.querySelector('.circle-number');
                if (numberSpan && numberSpan.textContent) {
                  const text = numberSpan.textContent.trim();
                  const dotNumber = parseInt(text, 10);
                  // Only add if dotNumber is EXACTLY in redDotNumbers and NOT in blackDotNumbers
                  if (!isNaN(dotNumber) && dotNumber > 0 && redDotNumbers.has(dotNumber) && !blackDotNumbers.has(dotNumber)) {
                    redDots.push(idx);
                  }
                }
              }
              
              // Only include dots that aren't already filled from first click
              indicesToFill = redDots.filter(i => !alreadyFilled.has(i));
              
              // Final verification: we should have exactly 100 dots (or fewer if some were already filled)
              // If we have more than 100, something is wrong
              if (indicesToFill.length > 100) {
                // This shouldn't happen, but limit to 100 just in case
                indicesToFill = indicesToFill.slice(0, 100);
              }
            } else if (sourceSquare === 361) {
              // 31×31 (961) maps to 19×19 (361) - 60 purple dots
              // Map relative to top-right corner: row 0, col 18 in 19×19 → row 0, col 30 in 31×31
              // Map each purple dot by its distance from the right edge (excluding the red dot)
              const allIndices = [];
              const sourceGridSize = 19;
              const targetGridSize = gridSize; // Should be 31
              // Map each purple dot from 19×19 to 31×31 by relative position from top-right corner
              // Pattern in 19×19: rows 0-7, cols 11-18 (with row 0 excluding col 18 which is red)
              // In 31×31: rows 0-7, cols 23-30 (with row 0 excluding col 30 which is red)
              for (let sourceRow = 0; sourceRow < 8; sourceRow++) {
                let sourceStartCol, sourceEndCol;
                if (sourceRow === 0) {
                  sourceStartCol = 11;
                  sourceEndCol = 17; // Exclude col 18 (red dot)
                } else if (sourceRow === 1) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow >= 2 && sourceRow <= 5) {
                  sourceStartCol = 11;
                  sourceEndCol = 18;
                } else if (sourceRow === 6) {
                  sourceStartCol = 12;
                  sourceEndCol = 18;
                } else if (sourceRow === 7) {
                  sourceStartCol = 13;
                  sourceEndCol = 18;
                }
                // Map each column by distance from right edge
                for (let sourceCol = sourceStartCol; sourceCol <= sourceEndCol; sourceCol++) {
                  // Calculate distance from right edge in source grid (19×19)
                  // col 18 → distance 0, col 17 → distance 1, ..., col 11 → distance 7
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid (31×31) maintaining same distance from right edge
                  // distance 0 → col 30, distance 1 → col 29, ..., distance 7 → col 23
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row (0-7)
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    // Exclude the red dot (top-right corner) and already filled dots
                    const isRedDot = (targetRow === 0 && targetCol === targetGridSize - 1);
                    if (!isRedDot && !topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - 20 orange dots
              // Map relative to top-right corner: row 0, col 17 in 18×18 → row 0, col 31 in 32×32
              // Map each orange dot by its distance from the right edge (excluding the 4 green dots)
              const allIndices = [];
              const sourceGridSize = 18;
              const targetGridSize = gridSize; // Should be 32
              // Map each orange dot from 18×18 to 32×32 by relative position from top-right corner
              // Pattern in 18×18: rows 0-3, cols 13-17 (excluding 2x2 green at rows 0-1, cols 16-17) + row 4, cols 14-17
              // Top part: rows 0-3, cols 13-17 (excluding 2x2 green)
              for (let sourceRow = 0; sourceRow < 4; sourceRow++) {
                for (let sourceCol = 13; sourceCol <= 17; sourceCol++) {
                  // Exclude the 2x2 green square (rows 0-1, cols 16-17)
                  if (sourceRow < 2 && sourceCol >= 16 && sourceCol <= 17) {
                    continue;
                  }
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    // Exclude the 2x2 green square in target grid (rows 0-1, cols 30-31)
                    const isGreenSquare = (targetRow < 2 && targetCol >= targetGridSize - 2 && targetCol <= targetGridSize - 1);
                    if (!isGreenSquare && !topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              // Bottom row: row 4, cols 14-17
              for (let sourceCol = 14; sourceCol <= 17; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 4; // Row 4
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  const idx = targetRow * gridSize + targetCol;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 289) {
              // 33×33 (1089) maps to 17×17 (289) - 80 pink dots
              // Map relative to top-right corner: rows 0-8, cols 8-16 + row 9, cols 9-16 (excluding 3x3 sky blue)
              // The 3x3 sky blue is at rows 0-2, cols 14-16 in 17×17, which maps to rows 0-2, cols 30-32 in 33×33
              const allIndices = [];
              const sourceGridSize = 17;
              const targetGridSize = gridSize; // Should be 33
              // Map each pink dot from 17×17 to 33×33 by relative position from top-right corner
              // Pattern in 17×17: rows 0-8, cols 8-16 + row 9, cols 9-16 (excluding 3x3 sky blue at rows 0-2, cols 14-16)
              // Rows 0-8: cols 8-16 (excluding 3x3 sky blue)
              for (let sourceRow = 0; sourceRow < 9; sourceRow++) {
                for (let sourceCol = 8; sourceCol <= 16; sourceCol++) {
                  // Exclude the 3x3 sky blue square (rows 0-2, cols 14-16)
                  if (sourceRow < 3 && sourceCol >= 14 && sourceCol <= 16) {
                    continue;
                  }
                  // Calculate distance from right edge in source grid
                  const distanceFromRight = sourceGridSize - 1 - sourceCol;
                  // Map to target grid maintaining same distance from right edge
                  const targetCol = targetGridSize - 1 - distanceFromRight;
                  const targetRow = sourceRow; // Keep same row
                  if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                    const idx = targetRow * gridSize + targetCol;
                    // Exclude the 3x3 sky blue square in target grid (rows 0-2, cols 30-32) and already filled dots
                    const isSkyBlueSquare = (targetRow < 3 && targetCol >= targetGridSize - 3 && targetCol <= targetGridSize - 1);
                    if (!isSkyBlueSquare && !topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
              }
              // Row 9: cols 9-16
              for (let sourceCol = 9; sourceCol <= 16; sourceCol++) {
                const distanceFromRight = sourceGridSize - 1 - sourceCol;
                const targetCol = targetGridSize - 1 - distanceFromRight;
                const targetRow = 9; // Row 9
                if (targetRow < gridSize && targetCol >= 0 && targetCol < gridSize) {
                  const idx = targetRow * gridSize + targetCol;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 324) {
              // 32×32 (1024) maps to 18×18 (324) - 20 orange dots
              const allIndices = [];
              // Map the 324 pattern: rows 0-3, cols 13-17 (excluding 2x2 green) + row 4, cols 14-17
              // Top part: rows 0-3, cols 13-17 (excluding 2x2 green at rows 0-1, cols 16-17)
              for (let row = 0; row < 4 && row < gridSize; row++) {
                for (let col = 13 + columnShift; col < 18 + columnShift && col < gridSize; col++) {
                  // Exclude the 2x2 green square (rows 0-1, cols 16-17)
                  if (row < 2 && col >= 16 + columnShift && col <= 17 + columnShift) {
                    continue;
                  }
                  const idx = row * gridSize + col;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              // Bottom row: row 4, cols 14-17
              for (let col = 14 + columnShift; col < 18 + columnShift && col < gridSize; col++) {
                const idx = 4 * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 225 || square === 1225) {
              if (square === 1225 && clickCount === 2) {
                // 35×35 (1225) - Third click: 20 orange dots at specific dot numbers
                // Dot numbers: 2-5, 66-69, 101-104, 136-139, 171-174
                const orangeDotNumbers = new Set();
                // 2 through 5
                for (let dot = 2; dot <= 5; dot++) orangeDotNumbers.add(dot);
                // 69 through 66 (backwards, so 66-69)
                for (let dot = 66; dot <= 69; dot++) orangeDotNumbers.add(dot);
                // 104 through 101 (backwards, so 101-104)
                for (let dot = 101; dot <= 104; dot++) orangeDotNumbers.add(dot);
                // 139 through 136 (backwards, so 136-139)
                for (let dot = 136; dot <= 139; dot++) orangeDotNumbers.add(dot);
                // 174 through 171 (backwards, so 171-174)
                for (let dot = 171; dot <= 174; dot++) orangeDotNumbers.add(dot);
                
                // Find circles by their dot numbers
                const allIndices = [];
                circles.forEach((circle, idx) => {
                  const numberSpan = circle.querySelector('.circle-number');
                  if (numberSpan) {
                    const dotNumber = parseInt(numberSpan.textContent, 10);
                    if (orangeDotNumbers.has(dotNumber) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                });
                indicesToFill = allIndices;
              } else if (square === 1225) {
                // For other clicks, use default behavior
                const allIndices = [];
                for (let row = 0; row < gridSize; row++) {
                  for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices.slice(0, componentValue);
              } else {
                // Original 225 mapping logic for other squares
                const allIndices = [];
                for (let row = 0; row < 5 && row < gridSize; row++) {
                  for (let col = gridSize - 5; col < gridSize - 1 && col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                      allIndices.push(idx);
                    }
                  }
                }
                indicesToFill = allIndices.slice(0, componentValue);
              }
            } else if (sourceSquare === 169) {
              // 37×37 (1369) maps to 13×13 (169) - 60 purple dots
              const allIndices = [];
              // Map the 169 pattern: fill area to the left of top right 3x3
              // The 3x3 sky blue is at rows 0-2, cols 10-12
              // Fill the rest of the top area (60 purple)
              for (let row = 0; row < gridSize && allIndices.length < componentValue; row++) {
                for (let col = 0; col < gridSize && allIndices.length < componentValue; col++) {
                  const idx = row * gridSize + col;
                  // Exclude the 3x3 sky blue square (rows 0-2, cols 10-12)
                  if (row < 3 && col >= 10 + columnShift && col <= 12 + columnShift) {
                    continue;
                  }
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else if (sourceSquare === 144) {
              // 38×38 (1444) maps to 12×12 (144) - 40 green dots
              const allIndices = [];
              // Map the 144 pattern: rows 2-5, left 10 cols (40 green)
              for (let row = 2; row < 6 && row < gridSize; row++) {
                for (let col = 0 + columnShift; col < 10 + columnShift && col < gridSize; col++) {
                  const idx = row * gridSize + col;
                  if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                    allIndices.push(idx);
                  }
                }
              }
              indicesToFill = allIndices.slice(0, componentValue);
            } else {
              // Default: fill around ones place
              indicesToFill = getIndicesAroundOnes(gridSize, componentValue, topRightIndices, alreadyFilled);
            }
          } else if (square === 441) {
            // Special: 441 - 41 dots total: 40 in 8×5 rectangle + 1 diagonal dot
            // All 41 should offset together on second click
            // BUT: row 0, col 20 (top-right of rectangle) stays BLACK until third click
            const allIndices = [];
            // 8×5 rectangle: rows 0-4, cols 13-20 (40 positions total)
            // Fill 39 positions in the rectangle (excluding row 0, col 20 which stays black)
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 13; col < 21 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Exclude row 0, col 20 - it stays black until third click
                if (row === 0 && col === 20) {
                  continue;
                }
                // Include the other 39 positions in the rectangle
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Add the diagonal dot (row 5, col 12) - diagonal from bottom-left of rectangle (row 4, col 13)
            // This makes 40 dots total (39 in rectangle + 1 diagonal)
            const diagonalIdx = 5 * gridSize + 12;
            // Ensure diagonal dot is included - add it at the end to guarantee it's in the 40
            if (!alreadyFilled.has(diagonalIdx) && !allIndices.includes(diagonalIdx)) {
              allIndices.push(diagonalIdx);
            }
            // We need 41 dots total, but row 0, col 20 stays black
            // So we fill 40 dots here (39 in rectangle + 1 diagonal)
            // The 41st dot (row 0, col 20) will be filled on the third click as red
            // Make sure we get exactly 40 dots (componentValue is 40)
            // Ensure diagonal dot is always included in the final list
            indicesToFill = allIndices.slice(0, componentValue);
            if (!indicesToFill.includes(diagonalIdx) && allIndices.includes(diagonalIdx)) {
              // Replace the last item with diagonal dot to ensure it's included
              indicesToFill[indicesToFill.length - 1] = diagonalIdx;
            }
          } else if (square === 484) {
            // Special: 484 - 80 pink total
            // Keep all green dots from first click, fill remaining black dots with pink
            // Except: dots 21, 22, 43, 44 stay black (these are the 2×2 square in top-right)
            // Dots 21, 22, 43, 44: indices 20, 21, 42, 43
            // Dot 21: row 0, col 20
            // Dot 22: row 0, col 21
            // Dot 43: row 1, col 20
            // Dot 44: row 1, col 21
            const blackDotsToKeep = [20, 21, 42, 43]; // indices for dots 21, 22, 43, 44
            
            // Fill all black dots (not already filled) with pink, except the 4 black dots to keep
            const allIndices = [];
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip dots that are already filled (green from first click)
                if (alreadyFilled.has(idx)) {
                  continue;
                }
                // Skip the 4 black dots that should stay black (21, 22, 43, 44)
                if (blackDotsToKeep.includes(idx)) {
                  continue;
                }
                // Fill all other black dots with pink
                allIndices.push(idx);
              }
            }
            // Should be 80 pink dots (484 - 400 green - 4 black = 80)
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 841) {
            // Special: 841 - 40 green dots on second click
            // Pattern matches 21×21 (441): 8×5 rectangle + 1 diagonal dot, but top-right stays black
            // 8×5 rectangle: rows 0-4, cols 21-28 (40 positions total)
            // Fill 39 positions in the rectangle (excluding row 0, col 28 which stays black)
            // Plus 1 diagonal dot (row 5, col 20)
            const allIndices = [];
            // 8×5 rectangle: rows 0-4, cols 21-28 (40 positions total)
            // Fill 39 positions in the rectangle (excluding row 0, col 28 which stays black)
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 21; col < 29 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Exclude row 0, col 28 - it stays black until third click
                if (row === 0 && col === 28) {
                  continue;
                }
                // Include the other 39 positions in the rectangle
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            // Add the diagonal dot (row 5, col 20) - diagonal from bottom-left of rectangle (row 4, col 21)
            // This makes 40 dots total (39 in rectangle + 1 diagonal)
            const diagonalIdx = 5 * gridSize + 20;
            // Ensure diagonal dot is included - add it at the end to guarantee it's in the 40
            if (!alreadyFilled.has(diagonalIdx) && !allIndices.includes(diagonalIdx)) {
              allIndices.push(diagonalIdx);
            }
            // We need 41 dots total, but row 0, col 28 stays black
            // So we fill 40 dots here (39 in rectangle + 1 diagonal)
            // The 41st dot (row 0, col 28) will be filled on the third click as red
            // Make sure we get exactly 40 dots (componentValue is 40)
            // Ensure diagonal dot is always included in the final list
            indicesToFill = allIndices.slice(0, componentValue);
            if (!indicesToFill.includes(diagonalIdx) && allIndices.includes(diagonalIdx)) {
              // Replace the last item with diagonal dot to ensure it's included
              indicesToFill[indicesToFill.length - 1] = diagonalIdx;
            }
          } else if (square === 529) {
            // Special: 529 - 20 orange in a 4×5 rectangle (rows 0-3, cols 15-19)
            const allIndices = [];
            // Fill exactly the 4×5 rectangle: rows 0-3, cols 15-19
            for (let row = 0; row < 4 && row < gridSize; row++) {
              for (let col = 15; col < 20 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 676) {
            // Special: 676 - 70 brown dots on second click, same pattern as 576
            // Fill remaining black dots with brown, except the 6-dot pattern (ones place)
            // The 6-dot pattern stays black and will turn purple on 3rd click
            const allIndices = [];
            // Fill all black dots except the 6-dot pattern (ones place)
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip dots that are already filled (purple from first click)
                if (alreadyFilled.has(idx)) {
                  continue;
                }
                // Skip the 6-dot pattern (ones place) - these stay black until 3rd click
                if (topRightIndices.includes(idx)) {
                  continue;
                }
                // Fill all other black dots with brown
                allIndices.push(idx);
              }
            }
            // Fill exactly 70 brown dots
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 729) {
            // Special: 729 - 20 brown dots on second click in 4×5 rectangle (rows 0-3, cols 19-23)
            const allIndices = [];
            // Fill exactly the 4×5 rectangle: rows 0-3, cols 19-23
            for (let row = 0; row < 4 && row < gridSize; row++) {
              for (let col = 19; col < 24 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 784) {
            // Special: 784 - 80 pink dots on second click
            // Fill remaining black dots with pink, except the 2×2 square (rows 0-1, cols 26-27)
            // The 2×2 square stays black and will turn green on 3rd click
            const allIndices = [];
            // Fill all black dots except the 2×2 square
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                // Skip dots that are already filled (brown from first click)
                if (alreadyFilled.has(idx)) {
                  continue;
                }
                // Skip the 2×2 square (rows 0-1, cols 26-27) - these stay black until 3rd click
                if (row >= 0 && row <= 1 && col >= 26 && col <= 27) {
                  continue;
                }
                // Fill all other black dots with pink
                allIndices.push(idx);
              }
            }
            // Fill exactly 80 pink dots
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 625) {
            // Special: 625 - 20 orange dots on second click
            // Turn remaining black dots orange, except 25, 50, 75, 100, 125
            // Black dots to turn orange: 21-24, 46-49, 71-74, 96-99, 121-124 (20 dots)
            const orangeDots = [];
            // Dots 21-24 (exclude 25)
            for (let dot = 21; dot <= 24; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 46-49 (exclude 50)
            for (let dot = 46; dot <= 49; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 71-74 (exclude 75)
            for (let dot = 71; dot <= 74; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 96-99 (exclude 100)
            for (let dot = 96; dot <= 99; dot++) {
              orangeDots.push(dot - 1);
            }
            // Dots 121-124 (exclude 125)
            for (let dot = 121; dot <= 124; dot++) {
              orangeDots.push(dot - 1);
            }
            
            const allIndices = orangeDots.filter(idx => !alreadyFilled.has(idx));
            // Fill exactly 20 orange dots
            indicesToFill = allIndices.slice(0, componentValue);
          } else {
            // Other 3-digit: around/separating the ones place
            indicesToFill = getIndicesAroundOnes(gridSize, componentValue, topRightIndices, alreadyFilled);
          }
        } else if (isTensPlace && components.length === 2) {
          // Tens place in 2-digit number: upper left area (for 49, this is the 40)
          if (square === 25) {
            // Special: 25 - 20 orange in first 4 columns (cols 0-3, rows 0-4), leaving 5 black (col 4, rows 0-4)
            const allIndices = [];
            // Fill 4 columns × 5 rows = 20 orange dots (cols 0-3, rows 0-4)
            // Leave col 4 (rightmost column) for 5 blue dots
            for (let row = 0; row < 5 && row < gridSize; row++) {
              for (let col = 0; col < 4 && col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 36) {
            // Special: 36 - 30 yellow, fill all 30 dots, leaving space for 6 (top right triangle)
            const allIndices = [];
            // Fill all available spaces except top right triangle pattern
            // Collect all indices first, then slice
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else if (square === 49) {
            // Special: 49 - 40 orange, fill all 40 dots, leaving space for 9 (top right 3x3)
            const allIndices = [];
            // Fill all available spaces except top right 3x3
            // Collect all indices first, then slice
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const idx = row * gridSize + col;
                if (!topRightIndices.includes(idx) && !alreadyFilled.has(idx)) {
                  allIndices.push(idx);
                }
              }
            }
            indicesToFill = allIndices.slice(0, componentValue);
          } else {
            indicesToFill = getUpperLeftIndices(gridSize, componentValue, topRightIndices, alreadyFilled);
          }
        } else {
          // Fallback: fill remaining empty spaces
          // Skip this for 1296 third and fourth clicks - we already set indicesToFill
          if (!is1296SpecialClick) {
            for (let i = 0; i < circles.length && indicesToFill.length < componentValue; i++) {
              if (!alreadyFilled.has(i) && !topRightIndices.includes(i)) {
                indicesToFill.push(i);
              }
            }
          }
        }
        
        // Fill the indices (only fill as many as needed)
        const filledCount = { count: 0 };
        // For 441, we need to fill 40 dots on second click (39 in rectangle + 1 diagonal)
        // For 1156, we need to fill 100 dots on second click and move them up
        // Make sure we process all indices, not just up to componentValue
        // For 841, just fill normally (no special processing needed)
        // For 1156, clicks 2-4 should not process any indices (no visual changes)
        // For 1156, allow second click (clickCount === 1) and third click (clickCount === 2) to proceed
        // For 1225, allow third click (clickCount === 2) to proceed and move dots up
        const indicesToProcess = (square === 1156 && clickCount === 1) ? indicesToFill : 
                                  ((square === 441 && isTensPlace) ? indicesToFill : 
                                  ((square === 1225 && clickCount === 2) ? indicesToFill : 
                                  (is1296SpecialClick ? indicesToFill : (indicesToFill || []).slice(0, componentValue))));
        indicesToProcess.forEach(i => {
          const c = circles[i];
          // Only fill if not already filled
          if (!alreadyFilled.has(i)) {
            c.classList.remove(...COLOR_CLASSES);
            c.classList.add(color);
            filledCount.count++;
            
            // For 441, offset ALL 41 dots (tens place) - the entire 8×5 rectangle + 1 diagonal dot
            // All 41 dots should offset together on the second click
            // This includes row 0, col 20 which stays black but also offsets
            // For 1156 second click (clickCount === 1), move 100 red dots up 1 dot distance (vertically only)
            // For 1225 third click (clickCount === 2), move 20 orange dots up 1 dot distance (vertically only)
            // For 841, don't offset - just change colors in place
            if ((square === 441 && isTensPlace) || (square === 1156 && clickCount === 1) || (square === 1225 && clickCount === 2)) {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Check if this dot should offset:
              // For 441: 8×5 rectangle (rows 0-4, cols 13-20) - including row 0, col 20
              //          Diagonal dot (row 5, col 12)
              // For 1156: all 100 red dots on second click move up 1 dot distance (straight up)
              // For 1225: all 20 orange dots + 5 black dots (that will turn blue) on third click move up 1 dot distance (straight up)
              const isInRectangle = (square === 441 && row >= 0 && row < 5 && col >= 13 && col < 21);
              const isDiagonalDot = (square === 441 && row === 5 && col === 12);
              const is1156SecondClick = (square === 1156 && clickCount === 1);
              const is1225ThirdClick = (square === 1225 && clickCount === 2);
              // For 1225 third click: also include the 5 blue dots (column 34, rows 0-4) in movement
              const is1225BlueDot = (square === 1225 && clickCount === 2 && col === gridSize - 1 && row < 5);
              
              if (isInRectangle || isDiagonalDot || is1156SecondClick || is1225ThirdClick || is1225BlueDot) {
                // Hide the original circle in the grid
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (!existingSeparated) {
                  // Create a new circle positioned offset (all 41 move together)
                  // For row 0, col 20 (441) or row 0, col 28 (841), keep it black (don't add color class)
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle'; // Start with no color (black)
                  // If this is not the top-right corner dot, add the color
                  const isTopRightCorner = (square === 441 && row === 0 && col === 20) || 
                                          (square === 841 && row === 0 && col === 28);
                  if (!isTopRightCorner) {
                    separatedCircle.className = `circle ${color}`;
                  }
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '5';
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  
                  // Keep the same size as original circle - copy size classes
                  c.classList.forEach(cls => {
                    if (cls.startsWith('circle-')) {
                      separatedCircle.classList.add(cls);
                    }
                  });
                  
                  // Special handling for diagonal dot - needs to touch rectangle's bottom-left tangentially
                  if (isDiagonalDot) {
                    // For 441: rectangle's bottom-left is at row 4, col 13, diagonal dot at row 5, col 12
                    // For 841: rectangle's bottom-left is at row 4, col 21, diagonal dot at row 5, col 20
                    // After standard offset, move it just a bit closer to touch tangentially:
                    // - Move it to the RIGHT: col + 1.5 (positive = right)
                    // - Move it UP: row - 1.5 (negative = up, since top is measured from top)
                    separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.5 * var(--circle-total))`;
                    separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.5 * var(--circle-total))`;
                    // Ensure it's visible and has green color, and give it a higher z-index so it's on top
                    separatedCircle.className = `circle ${color}`;
                    // Copy size classes
                    c.classList.forEach(cls => {
                      if (cls.startsWith('circle-')) {
                        separatedCircle.classList.add(cls);
                      }
                    });
                    separatedCircle.style.zIndex = '6'; // Slightly higher than rectangle dots to ensure visibility
                  } else if (is1156SecondClick || is1225ThirdClick || is1225BlueDot) {
                    // For 1156 second click: move all 100 red dots UP 1 dot distance (straight up, no left movement)
                    // For 1225 third click: move all 20 orange dots + 5 black dots UP 1 dot distance (straight up, no left movement)
                    // All dots maintain their exact grid spacing relative to each other - they move as a connected unit
                    // UP: negative top value = row - 1 (move up by exactly 1 dot distance)
                    // Keep same horizontal position (no left offset) - use --circle-total (regular size)
                    // Set className first, then add size classes to maintain exact spacing
                    // For blue dots (is1225BlueDot), keep them black (no color class)
                    if (is1225BlueDot) {
                      separatedCircle.className = 'circle'; // Keep black
                    } else {
                      separatedCircle.className = `circle ${color}`; // Orange for orange dots
                    }
                    // Copy size classes AFTER setting className to maintain exact grid spacing
                    c.classList.forEach(cls => {
                      if (cls.startsWith('circle-')) {
                        separatedCircle.classList.add(cls);
                      }
                    });
                    // Use --circle-total (regular size) to maintain exact grid spacing
                    // All dots use the same calculation, so they stay connected tangentially
                    separatedCircle.style.left = `calc(var(--circle-total) * ${col})`;
                    separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1 * var(--circle-total))`;
                    // Ensure no transform or other positioning that could cause separation
                    separatedCircle.style.transform = 'none';
                    separatedCircle.style.margin = '0';
                    separatedCircle.style.padding = '0';
                    
                    // Copy the dot number data attribute if it exists (for squares 1156 and 1225)
                    if (c.dataset.dotNumber) {
                      separatedCircle.dataset.dotNumber = c.dataset.dotNumber;
                    }
                  } else {
                    // Standard offset for all other dots (all 41 move together) - moves RIGHT and UP diagonally
                    // RIGHT: positive left value = col + 1.2
                    // UP: negative top value = row - 1.2
                    separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.2 * var(--circle-total))`;
                    separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.2 * var(--circle-total))`;
                    
                    // Copy the dot number data attribute if it exists (for squares 1156 and 1225)
                    if (c.dataset.dotNumber) {
                      separatedCircle.dataset.dotNumber = c.dataset.dotNumber;
                    } else {
                      // Copy the number span if it exists (for other numbered grids)
                      const originalNumber = c.querySelector('.circle-number');
                      if (originalNumber) {
                        const numberSpan = document.createElement('span');
                        numberSpan.className = 'circle-number';
                        numberSpan.textContent = originalNumber.textContent;
                        separatedCircle.appendChild(numberSpan);
                      }
                    }
                  }
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
            
            // For 441, offset the 1 part (ones place) - red dot at top right corner, offset
            // For 841, don't offset - just change color in place
            if (square === 441 && isOnesPlace) {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process the single dot at top right corner (row 0, col 20)
              if (row === 0 && col === 20) {
                // Hide the original circle in the grid
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index (the black one from second click)
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (existingSeparated) {
                  // Update the existing black separated circle to red
                  // Keep it in the same position as the second click (don't move it again)
                  existingSeparated.classList.remove(...COLOR_CLASSES);
                  existingSeparated.classList.add(color); // Add red color
                  existingSeparated.style.zIndex = '10'; // Higher z-index for red dot
                  // Don't change the position - it stays where it was moved to on the second click
                } else {
                  // Create a new circle positioned offset (right and up from top-right corner)
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = `circle ${color}`;
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '10';
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  
                  // Keep the same size as original circle - copy size classes
                  c.classList.forEach(cls => {
                    if (cls.startsWith('circle-')) {
                      separatedCircle.classList.add(cls);
                    }
                  });
                  
                  // Small offset to the RIGHT and UP (the red dot moves just a little bit more than the 40)
                  // RIGHT: positive left value = col + 1.5 (1.2 + 0.3)
                  // UP: negative top value = row - 1.5 (1.2 + 0.3)
                  separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.5 * var(--circle-total))`;
                  separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.5 * var(--circle-total))`;
                  
                  // Copy the number span if it exists (for numbered grids)
                  const originalNumber = c.querySelector('.circle-number');
                  if (originalNumber) {
                    const numberSpan = document.createElement('span');
                    numberSpan.className = 'circle-number';
                    numberSpan.textContent = originalNumber.textContent;
                    separatedCircle.appendChild(numberSpan);
                  }
                  
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
            
            // For 225, make sure blue dots (ones place) appear on top
            if (square === 225 && isOnesPlace && color === 'blue') {
              c.style.zIndex = '20';
              c.style.position = 'relative';
            }
            
            // For 256, separate the 6 purple dots from the main grid
            // For 1156, keep purple dots in place (don't separate them)
            // For 256 third click: purple dots just change color, don't move
            // (No special handling needed - dots will fill normally in place)
            
            // For 225, separate the entire 5×5 rectangle (20 orange + 5 black) from the main grid
            // On second click: 20 orange dots (cols 10-13, rows 0-4) are separated and filled
            // Also create the 5 black dots in the separated position (col 14, rows 0-4)
            if (square === 225 && isTensPlace && color === 'orange') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the 5×5 area (rows 0-4, cols 10-14)
              if (row >= 0 && row < 5 && col >= 10 && col <= 14) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (!existingSeparated) {
                  // Create a new circle positioned to the right and up, separated from the main grid
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle orange';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '5'; // Lower z-index than blue dots
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Position to the right and up from where the original circle was
                  // Symmetric offset: same distance right and up for balanced separation
                  separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 0.5 * var(--circle-total))`;
                  separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 0.5 * var(--circle-total))`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
            
            // For 225, also separate the 5 blue dots (ones place) in the separated 5×5 rectangle
            // The blue dots should replace the 5 black separated dots in col 14 (rightmost column)
            if (square === 225 && isOnesPlace && color === 'blue') {
              const row = Math.floor(i / gridSize);
              const col = i % gridSize;
              
              // Only process dots that are in the rightmost column (col 14) of the 5×5 area (rows 0-4)
              if (row >= 0 && row < 5 && col === 14) {
                // Hide the original circle in the grid (remove it from the visual grid)
                c.style.visibility = 'hidden';
                
                // Check if we've already created a separated circle for this index (should be a black one from second click)
                const existingSeparated = separatedCircles.find(sc => {
                  const scRow = parseInt(sc.dataset.originalRow);
                  const scCol = parseInt(sc.dataset.originalCol);
                  return scRow === row && scCol === col;
                });
                
                if (existingSeparated) {
                  // If already existing (the black separated dot from second click), just update its color and z-index
                  existingSeparated.classList.remove(...COLOR_CLASSES);
                  existingSeparated.classList.add('blue');
                  existingSeparated.style.zIndex = '20'; // Higher z-index to appear on top
                } else {
                  // Should not happen, but create it if somehow missing
                  const separatedCircle = document.createElement('div');
                  separatedCircle.className = 'circle blue';
                  separatedCircle.style.position = 'absolute';
                  separatedCircle.style.zIndex = '20'; // Higher z-index to appear on top
                  separatedCircle.dataset.originalRow = row;
                  separatedCircle.dataset.originalCol = col;
                  // Position to the right and up from where the original circle was
                  // Same offset as the orange dots so they form the complete 5×5 rectangle
                  separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 0.5 * var(--circle-total))`;
                  separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 0.5 * var(--circle-total))`;
                  separatedCircle.style.display = 'block';
                  separatedCircle.style.visibility = 'visible';
                  separatedCircle.style.opacity = '1';
                  grid.appendChild(separatedCircle);
                  separatedCircles.push(separatedCircle);
                }
              }
            }
          }
        });
        
        // For 441, after filling the 40 dots on second click, also offset the top-right corner dot (stays black)
        // For 841, don't offset - just change colors in place
        // Note: clickCount is 1 on second click (0-indexed: 0=first, 1=second, 2=third)
        if (square === 441 && isTensPlace) {
          const row = 0;
          const col = 20;
          const idx = row * gridSize + col;
          
          // Check if we need to offset the top-right corner dot (even though it's not being filled green)
          const existingSeparated = separatedCircles.find(sc => {
            const scRow = parseInt(sc.dataset.originalRow);
            const scCol = parseInt(sc.dataset.originalCol);
            return scRow === row && scCol === col;
          });
          
          if (!existingSeparated) {
            // Hide the original circle in the grid
            const c = circles[idx];
            if (c) {
              c.style.visibility = 'hidden';
              
              // Create a new circle positioned offset but keep it black
              const separatedCircle = document.createElement('div');
              separatedCircle.className = 'circle'; // Black (no color class)
              separatedCircle.style.position = 'absolute';
              separatedCircle.style.zIndex = '5';
              separatedCircle.dataset.originalRow = row;
              separatedCircle.dataset.originalCol = col;
              
              // Keep the same size as original circle - copy size classes
              c.classList.forEach(cls => {
                if (cls.startsWith('circle-')) {
                  separatedCircle.classList.add(cls);
                }
              });
              
              // Offset to the RIGHT and UP (moves with the other 40) - diagonal movement
              // RIGHT: positive left value = col + 1.2
              // UP: negative top value = row - 1.2
              separatedCircle.style.left = `calc(var(--circle-total) * ${col} + 1.2 * var(--circle-total))`;
              separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1.2 * var(--circle-total))`;
              
              // Copy the number span if it exists (for numbered grids)
              const originalNumber = c.querySelector('.circle-number');
              if (originalNumber) {
                const numberSpan = document.createElement('span');
                numberSpan.className = 'circle-number';
                numberSpan.textContent = originalNumber.textContent;
                separatedCircle.appendChild(numberSpan);
              }
              
              separatedCircle.style.display = 'block';
              separatedCircle.style.visibility = 'visible';
              separatedCircle.style.opacity = '1';
              grid.appendChild(separatedCircle);
              separatedCircles.push(separatedCircle);
            }
          }
        }
        
        // For 225, after filling all 20 orange dots on second click, hide the original 5 black dots and create them in separated position
        if (square === 225 && isTensPlace && filledCount.count === componentValue) {
          // All 20 orange dots filled, now hide the original 5 black dots and create them in separated position
          for (let blackRow = 0; blackRow < 5; blackRow++) {
            const blackCol = 14; // Rightmost column of the 5×5
            const blackIdx = blackRow * gridSize + blackCol;
            
            // Hide the original black circle in the grid
            if (circles[blackIdx]) {
              circles[blackIdx].style.visibility = 'hidden';
            }
            
            // Check if we've already created this separated black circle
            const existingBlack = separatedCircles.find(sc => {
              return parseInt(sc.dataset.originalRow) === blackRow && parseInt(sc.dataset.originalCol) === blackCol;
            });
            
            if (!existingBlack) {
              const separatedBlackCircle = document.createElement('div');
              separatedBlackCircle.className = 'circle'; // Black (no color class)
              separatedBlackCircle.style.position = 'absolute';
              separatedBlackCircle.style.zIndex = '5';
              separatedBlackCircle.dataset.originalRow = blackRow;
              separatedBlackCircle.dataset.originalCol = blackCol;
              separatedBlackCircle.style.left = `calc(var(--circle-total) * ${blackCol} + 0.5 * var(--circle-total))`;
              separatedBlackCircle.style.top = `calc(var(--circle-total) * ${blackRow} - 0.5 * var(--circle-total))`;
              separatedBlackCircle.style.display = 'block';
              separatedBlackCircle.style.visibility = 'visible';
              separatedBlackCircle.style.opacity = '1';
              grid.appendChild(separatedBlackCircle);
              separatedCircles.push(separatedBlackCircle);
            }
            }
          }
        
        // For 1225 fourth click: color the 5 separated black dots blue
        if (square === 1225 && clickCount === 3) {
          // The 5 blue dots are separated circles at column 34 (rightmost), rows 0-4
          for (let row = 0; row < 5 && row < gridSize; row++) {
            const existingSeparated = separatedCircles.find(sc => {
              const scRow = parseInt(sc.dataset.originalRow);
              const scCol = parseInt(sc.dataset.originalCol);
              return scRow === row && scCol === gridSize - 1;
            });
            
            if (existingSeparated) {
              // Change the separated circle from black to blue
              existingSeparated.classList.remove(...COLOR_CLASSES);
              existingSeparated.classList.add('blue');
            }
          }
        }
        
        // For 1225 third click: also move the 5 black dots (that will turn blue on 4th click) up with the orange dots
        if (square === 1225 && clickCount === 2) {
          // The 5 blue dots are in column 34 (rightmost), rows 0-4
          for (let row = 0; row < 5 && row < gridSize; row++) {
            const blueDotIdx = row * gridSize + (gridSize - 1); // Column 34
            const c = circles[blueDotIdx];
            
            // Only process if not already processed (not in indicesToFill)
            if (c && !indicesToFill.includes(blueDotIdx)) {
              // Hide the original circle in the grid
              c.style.visibility = 'hidden';
              
              // Check if we've already created a separated circle for this index
              const existingSeparated = separatedCircles.find(sc => {
                const scRow = parseInt(sc.dataset.originalRow);
                const scCol = parseInt(sc.dataset.originalCol);
                return scRow === row && scCol === gridSize - 1;
              });
              
              if (!existingSeparated) {
                // Create a new circle positioned 1 dot distance up, but keep it black
                const separatedCircle = document.createElement('div');
                separatedCircle.className = 'circle'; // Keep black (no color class)
                separatedCircle.style.position = 'absolute';
                separatedCircle.style.zIndex = '5';
                separatedCircle.dataset.originalRow = row;
                separatedCircle.dataset.originalCol = gridSize - 1;
                
                // Copy size classes
                c.classList.forEach(cls => {
                  if (cls.startsWith('circle-')) {
                    separatedCircle.classList.add(cls);
                  }
                });
                
                // Move up 1 dot distance (same as orange dots)
                separatedCircle.style.left = `calc(var(--circle-total) * ${gridSize - 1})`;
                separatedCircle.style.top = `calc(var(--circle-total) * ${row} - 1 * var(--circle-total))`;
                separatedCircle.style.transform = 'none';
                separatedCircle.style.margin = '0';
                separatedCircle.style.padding = '0';
                
                // Copy the dot number data attribute if it exists (for square 1225)
                if (c.dataset.dotNumber) {
                  separatedCircle.dataset.dotNumber = c.dataset.dotNumber;
                } else {
                  // Copy the number span if it exists (for other squares)
                  const originalNumber = c.querySelector('.circle-number');
                  if (originalNumber) {
                    const numberSpan = document.createElement('span');
                    numberSpan.className = 'circle-number';
                    numberSpan.textContent = originalNumber.textContent;
                    separatedCircle.appendChild(numberSpan);
                  }
                }
                
                separatedCircle.style.display = 'block';
                separatedCircle.style.visibility = 'visible';
                separatedCircle.style.opacity = '1';
                grid.appendChild(separatedCircle);
                separatedCircles.push(separatedCircle);
              }
            }
          }
        }
        
        clickCount++;
        // Special: For square 1225, second click should say "1200", third click should say "1220", and fourth click should say "1225"
        // Special: For square 1296, speak cumulative totals: "1000", "1200", "1290", "1296"
        let numberToSpeak;
        if (square === 1296) {
          // For 1296, speak cumulative totals
          if (clickCount === 1) {
            numberToSpeak = 1000;
          } else if (clickCount === 2) {
            numberToSpeak = 1200; // 1000 + 200
          } else if (clickCount === 3) {
            numberToSpeak = 1290; // 1000 + 200 + 90
          } else if (clickCount === 4) {
            numberToSpeak = 1296; // 1000 + 200 + 90 + 6
          } else {
            const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
            numberToSpeak = currentTotal;
          }
        } else if (square === 1225 && clickCount === 2) {
          numberToSpeak = 1200;
        } else if (square === 1225 && clickCount === 3) {
          numberToSpeak = 1220;
        } else if (square === 1225 && clickCount === 4) {
          numberToSpeak = 1225;
        } else {
          const currentTotal = components.slice(0, clickCount).reduce((a, b) => a + b, 0);
          numberToSpeak = currentTotal;
        }
        speakNumber(numberToSpeak);
        
        // Show answer when all components are filled (all dots are colored)
        // Check if we've processed all non-zero components OR if all dots are filled
        const nonZeroComponents = components.filter(c => c > 0);
        const processedNonZero = components.slice(0, clickCount).filter(c => c > 0).length;
        const allDotsFilled = filledCount.count >= square;
        
        if ((clickCount >= totalClicks || processedNonZeroFinal >= nonZeroComponentsFinal.length || allDotsFilled) && answerDisplay) {
          answerDisplay.textContent = square;
          answerDisplay.classList.add('show');
        }
      }
  });
  
  return section;
}

// Generate squares from 5^2 to 25^2
const moreSquaresContainer = document.getElementById('moreSquares');
if (moreSquaresContainer) {
  // Replace existing 25 section
  const existing25Section = document.querySelector('#square-25')?.closest('.set');
  if (existing25Section) {
    const newSection = generateSquare(5);
    existing25Section.replaceWith(newSection);
  }

  // Generate remaining squares from 6^2 to 30^2
  for (let n = 6; n <= 50; n++) {
    moreSquaresContainer.appendChild(generateSquare(n));
  }
}
</script>

</body>
</html>

